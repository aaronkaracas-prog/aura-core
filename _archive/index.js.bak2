export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // ---- CORS ----
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Max-Age": "86400",
    };
    if (request.method === "OPTIONS") return new Response("", { headers: corsHeaders });

    // ---- helpers ----
    const json = (data, status = 200, extra = {}) =>
      new Response(JSON.stringify(data, null, 2), {
        status,
        headers: { "Content-Type": "application/json", ...corsHeaders, ...extra },
      });

    const text = (body, status = 200, extra = {}) =>
      new Response(body, { status, headers: { ...corsHeaders, ...extra } });

    const getAdminToken = () =>
      env.AURA_ADMIN_TOKEN || env.ADMIN_TOKEN || env.AURA_ADMIN || env.ADMIN;

    const isAdmin = () => {
      const auth = request.headers.get("authorization") || "";
      const token = auth.startsWith("Bearer ") ? auth.slice(7) : "";
      const admin = getAdminToken();
      return Boolean(token && admin && token === admin);
    };

    const r2 = env.AURA_UPLOADS;
    if (!r2) return json({ ok: false, error: "Missing R2 binding AURA_UPLOADS" }, 500);

    const putR2 = async (key, value, contentType) => {
      const body = typeof value === "string" ? value : JSON.stringify(value, null, 2);
      await r2.put(key, body, { httpMetadata: { contentType } });
      return true;
    };

    const getR2Text = async (key) => {
      const obj = await r2.get(key);
      if (!obj) return null;
      return await obj.text();
    };

    const getR2Json = async (key) => {
      const t = await getR2Text(key);
      if (!t) return null;
      try { return JSON.parse(t); } catch { return null; }
    };

    // =========================
    // ROUTES
    // =========================

    // GET /health
    if (url.pathname === "/health" && request.method === "GET") {
      return json({
        ok: true,
        service: "aura-core",
        upload: true,
        control: true,
        ui: "r2-first",
        assets: "r2",
        memory: "r2",
        launch: "enabled",
        integrations: "enabled",
      });
    }

    // POST /ui (admin) -> stores ui/index.html in R2
    if (url.pathname === "/ui" && request.method === "POST") {
      if (!isAdmin()) return json({ error: "unauthorized" }, 401);
      const html = await request.text();
      await putR2("ui/index.html", html, "text/html; charset=utf-8");
      return json({ ok: true, stored: "ui/index.html" });
    }

    // GET / -> serves UI from R2
    if (url.pathname === "/" && request.method === "GET") {
      const obj = await r2.get("ui/index.html");
      if (!obj) return text("UI not uploaded yet", 404, { "Content-Type": "text/plain" });
      return new Response(obj.body, {
        headers: { ...corsHeaders, "Content-Type": "text/html; charset=utf-8" },
      });
    }

    // POST /assets (admin) -> stores config/assets.json
    if (url.pathname === "/assets" && request.method === "POST") {
      if (!isAdmin()) return json({ error: "unauthorized" }, 401);
      const data = await request.json();
      await putR2("config/assets.json", data, "application/json; charset=utf-8");
      return json({ ok: true, stored: "config/assets.json" });
    }

    // GET /assets -> public asset list
    if (url.pathname === "/assets" && request.method === "GET") {
      const data = await getR2Json("config/assets.json");
      if (!data) return json({ ok: true, assets: [] });
      return json(data);
    }

    // POST /memory (admin) -> stores config/ark_dump.txt
    if (url.pathname === "/memory" && request.method === "POST") {
      if (!isAdmin()) return json({ error: "unauthorized" }, 401);
      const dump = await request.text();
      await putR2("config/ark_dump.txt", dump, "text/plain; charset=utf-8");
      return json({ ok: true, stored: "config/ark_dump.txt" });
    }

    // GET /memory (admin) -> read back dump
    if (url.pathname === "/memory" && request.method === "GET") {
      if (!isAdmin()) return json({ error: "unauthorized" }, 401);
      const dump = await getR2Text("config/ark_dump.txt");
      if (!dump) return text("No dump stored", 404, { "Content-Type": "text/plain" });
      return text(dump, 200, { "Content-Type": "text/plain; charset=utf-8" });
    }

    // POST /upload -> file upload to R2
    if (url.pathname === "/upload" && request.method === "POST") {
      const ct = request.headers.get("content-type") || "";
      if (!ct.includes("multipart/form-data")) {
        return json({ error: "expected multipart/form-data" }, 400);
      }
      const form = await request.formData();
      const file = form.get("file");
      if (!file || typeof file === "string") return json({ error: "missing file field 'file'" }, 400);

      const key = `uploads/${Date.now()}-${Math.random().toString(16).slice(2)}-${file.name}`;
      await r2.put(key, await file.arrayBuffer(), {
        httpMetadata: { contentType: file.type || "application/octet-stream" },
      });

      return json({ ok: true, key, url: `https://auras.guide/r2/${encodeURIComponent(key)}` });
    }

    // GET /r2/<key> -> serve an object (public)
    if (url.pathname.startsWith("/r2/") && request.method === "GET") {
      const key = decodeURIComponent(url.pathname.slice(4));
      const obj = await r2.get(key);
      if (!obj) return text("Not found", 404, { "Content-Type": "text/plain" });
      const headers = new Headers(corsHeaders);
      const meta = obj.httpMetadata || {};
      if (meta.contentType) headers.set("Content-Type", meta.contentType);
      return new Response(obj.body, { headers });
    }

    // GET/POST /integrations (admin) -> integration registry
    if (url.pathname === "/integrations" && request.method === "POST") {
      if (!isAdmin()) return json({ error: "unauthorized" }, 401);
      const reg = await request.json();
      await putR2("config/integrations.json", reg, "application/json; charset=utf-8");
      return json({ ok: true, stored: "config/integrations.json" });
    }
    if (url.pathname === "/integrations" && request.method === "GET") {
      if (!isAdmin()) return json({ error: "unauthorized" }, 401);
      const reg = await getR2Json("config/integrations.json");
      return json(reg || { ok: true, integrations: [] });
    }

    // GET /launch/<slug> -> simple launch shell (public)
    if (url.pathname.startsWith("/launch/") && request.method === "GET") {
      const slug = url.pathname.split("/").pop();
      const html = `<!doctype html><html><head><meta charset="utf-8"><title>${slug}</title></head>
      <body style="font-family:system-ui;padding:24px">
      <h1>Launch: ${slug}</h1>
      <p>This is an auto-generated launch shell page.</p>
      </body></html>`;
      return text(html, 200, { "Content-Type": "text/html; charset=utf-8" });
    }

    // GET /stripe/balance (admin) -> verifies Stripe token works
    if (url.pathname === "/stripe/balance" && request.method === "GET") {
      if (!isAdmin()) return json({ error: "unauthorized" }, 401);
      if (!env.STRIPE_API_KEY) return json({ error: "missing STRIPE_API_KEY" }, 500);

      const resp = await fetch("https://api.stripe.com/v1/balance", {
        headers: { Authorization: `Bearer ${env.STRIPE_API_KEY}` },
      });

      const raw = await resp.text();
      let data;
      try { data = JSON.parse(raw); } catch { data = { raw }; }

      return json({ ok: resp.ok, status: resp.status, stripe: data }, resp.ok ? 200 : resp.status);
    }

    // default
    return text("Not Found", 404, { "Content-Type": "text/plain; charset=utf-8" });
  },
};
