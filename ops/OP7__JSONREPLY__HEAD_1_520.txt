function safeJsonParse(s){
  try { return JSON.parse(s); } catch(e){ return null; }
}
var REGISTRY_VERSION = "v1";
// AURA CORE  CANONICAL REBUILD (FULL FILE REPLACEMENT)
// Rebuilt from last known-good 91K source (operator-provided backup)
// Purpose: restore Aura Core command interpreter + registry grammar compatibility
// Timestamp: 2026-02-08
//
// NOTE: This file is intended to be deployed as Wrangler main="src/index.js"
//
// --- BEGIN ORIGINAL CONTENT ---

// === UI_ROUTER_ENTRY ===
// Router shim: classify natural language via INTENT before claim gate
function routeInputBeforeClaimGate(ctx, input) {
  if (!input || typeof input !== 'string') return { passthrough: true };
  const isCommand = /^[A-Z_]+(\s|$)/.test(input.trim());
  if (isCommand) return { passthrough: true };
  // Natural language  intent-first
  return { intentFirst: true, text: input };
}
// === END UI_ROUTER_ENTRY ===

// Canonical build/stamp (rendered in UI header and returned by SHOW_BUILD)
const BUILD = 'AURA_CORE__AUTONOMY_LAYERS__EVIDENCE_ALLOWLIST_HOSTCAPS_OPERATOR_INTENT_PAUSE__MEMORY_SUBSTRATE_V1__REGISTRY_AUDIT__14';
const STAMP = new Date().toISOString();

const autonomyTickKey = `autonomy:tick:v1`;



async function naturalLanguageReply(input, env, activeHost) {
  const text = (input || "").trim();
  if (!text) return "";

  const lower = text.toLowerCase();
  const host = (activeHost && activeHost !== "none") ? activeHost : "frontdesk.network";

  const intentGet = async (tag) => {
    try {
      return await env.AURA_KV.get(`intent:${host}:${tag}`);
    } catch (_) {
      return null;
    }
  };

  const identity = (await intentGet("identity")) || "I am Aura  an autonomous, evidence-first control-plane for ARK Systems. Host-scoped. Persistence-backed. Neutral and non-coercive.";
  const capability = (await intentGet("capability")) || "I can inspect state, manage registries, run herd checks, plan deploys, and execute deployer actions when operator-authorized and evidence requirements are satisfied.";
  const gating = (await intentGet("gating")) || "I only gate verified claims and privileged actions. For planning and questions, I respond directly.";

  // If the user is trying to assert a gated claim, enforce evidence-first
  const claimWords = ["live","deployed","reachable","works","working","up","down","online","offline","dns","resolves","propagated","ssl","https","http","525","520","530","error"];
  const looksLikeClaim = claimWords.some(w => lower.includes(w));
  if (looksLikeClaim) return "NOT WIRED: VERIFIED_FETCH REQUIRED";

  if (lower === "who are you" || lower.startsWith("who are you")) return identity;
  if (lower === "what can you do" || lower.startsWith("what can you do")) return capability + "\n\n" + gating;
  if (lower.includes("what systems") || lower.includes("what do you control") || lower.includes("what can you control")) {
    return capability + "\n\nActive host: " + host + "\nEvidence-first, host-scoped.";
  }
  if (lower.includes("help") || lower === "?" || lower.includes("commands")) {
    return "Type an allowed command (e.g., PING, SHOW_BUILD, SNAPSHOT_STATE).\n\nFor host work: HOST <domain>, then EVIDENCE_PRESENT or VERIFIED_FETCH_URL http://<domain>/";
  }
  if (lower.includes("launch") || lower.includes("deploy") || lower.includes("website") || lower.includes("site")) {
    return "I can plan and execute deployments via DEPLOYER_CALL when operator-authorized.\n\nTell me: domain + desired outcome (landing page vs app) and whether we should VERIFIED_FETCH first for the target host.";
  }

  // Default: answer politely, no gate.
  return identity + "\n\n" + capability;
}

// ==== PATCH: Registry commands bypass claim-gate (2026-01-29) ====
function __registryBypass(token) {
  // Only allow read-only registry operations to bypass claim-gate.
  // Any registry *write* (PUT / IMPORT) must be claim-gated by evidence.
  return token === "REGISTRY_GET" ||
         token === "REGISTRY_LIST" ||
         token === "REGISTRY_FILTER";
}
// ================================================================
const KNOWN_COMMANDS = [
  "PING",
  "SHOW_BUILD",
  "SHOW_CLAIM_GATE",
  "SHOW_ALLOWED_COMMANDS",
  "RUN_SELF_TEST_EVIDENCE",
  "VERIFIED_FETCH_URL",
  "CLEAR_VERIFIED_FETCH",
  "EVIDENCE_PRESENT",
  "SNAPSHOT_STATE",
  "HOST_CAPS_GET",
  "HOST_CAPS_SET",
  "DEPLOYER_CAPS",
  "DEPLOYER_CALL",
  "PAUSE",
  "INTENT_ADD",
  "INTENT_GET",
  "INTENT_CLEAR",
  "SHOW_MEMORY_SCHEMA",
  "REGISTRY_PUT",
  "REGISTRY_GET",
  "REGISTRY_LIST",
  "REGISTRY_FILTER",
  "REGISTRY_IMPORT_ASSETS",
  "REGISTRY_IMPORT_DOMAINS",
  "PORTFOLIO_STATUS",
  "AUDIT_GET",
  "AUDIT_CLEAR",
  "HERD_STATUS",
  "HERD_SELF_TEST",
  "HERD_SWEEP",
  "AUTONOMY_STATUS",
  "AUTONOMY_LAST_TICK",
        "AUTONOMY_LAST_TICK_SET",
  "AUTONOMY_LAST_TICK_SET",
  "AUTONOMY_CAPABILITIES",
  "INTENT_SIMULATE",
  "REGISTRY_AUDIT_TRAIL",
  "AUTONOMY_BUDGET_GET",
  "AUTONOMY_BUDGET_SET",
  "FAILURE_MEMORY_GET",
  "FAILURE_MEMORY_PUT",
  "AUTONOMY_CHARTER_GET",
  "AUTONOMY_CHARTER_SET",
];

const UI_HTML = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aura Core UI</title>
<style>
  :root{
    --bg:#070a12; --panel:#0e1424; --panel2:#0b1020;
    --text:#e8ecff; --muted:#9aa5c7; --line:rgba(255,255,255,.10);
    --accent:#6d5efc; --good:#48d597; --bad:#ff5c7a;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: radial-gradient(1200px 600px at 30% 10%, rgba(109,94,252,.18), transparent 60%),
                radial-gradient(900px 500px at 80% 30%, rgba(72,213,151,.10), transparent 55%),
                var(--bg);
    color:var(--text); height:100vh; display:flex; align-items:center; justify-content:center;
  }
  .wrap{ width:min(980px, 96vw); height:min(720px, 92vh); display:flex; flex-direction:column; gap:12px; }
  .topbar{
    display:flex; align-items:flex-start; justify-content:space-between; gap:16px;
    padding:14px 16px; border:1px solid var(--line); border-radius:16px;
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  .brand{ display:flex; flex-direction:column; gap:2px; }
  .brand .h{ font-size:18px; font-weight:700; letter-spacing:.2px; }
  .brand .s{ font-size:12px; color:var(--muted); }
  .meta{
    display:flex; flex-direction:column; align-items:flex-end; gap:4px;
    font-size:12px; color:var(--muted);
  }
  .meta .row{ display:flex; gap:10px; align-items:center; }
  .dot{ width:8px; height:8px; border-radius:50%; background:var(--good); box-shadow:0 0 0 3px rgba(72,213,151,.14); }
  .panel{
    flex:1; min-height:0;
    border:1px solid var(--line); border-radius:16px;
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    display:flex; flex-direction:column;
  }
  .log{
    flex:1; min-height:0;
    padding:14px; overflow:auto;
    display:flex; flex-direction:column; gap:10px;
  }
  .msg{
    max-width: 90%;
    border:1px solid var(--line);
    background: rgba(7,10,18,.35);
    padding:10px 12px; border-radius:14px;
    white-space:pre-wrap; word-break:break-word; line-height:1.35;
  }
  .msg.me{ align-self:flex-end; background: rgba(109,94,252,.16); border-color: rgba(109,94,252,.35); }
  .msg.aura{ align-self:flex-start; background: rgba(255,255,255,.04); }
  .msg.sys{ align-self:center; max-width:100%; color:var(--muted); background: transparent; border:none; padding:0; }
  .msg.error{ border-color: rgba(255,92,122,.45); background: rgba(255,92,122,.10); }
  .composer{
    border-top:1px solid var(--line);
    padding:12px;
    display:flex; gap:10px; align-items:flex-end;
    background: rgba(0,0,0,.12);
    border-bottom-left-radius:16px; border-bottom-right-radius:16px;
  }
  textarea{
    flex:1; min-height:44px; max-height:140px; resize:vertical;
    padding:10px 12px; border-radius:12px; outline:none;
    border:1px solid var(--line);
    background: rgba(0,0,0,.22);
    color:var(--text); font-size:14px; line-height:1.35;
  }
  textarea::placeholder{ color: rgba(154,165,199,.70); }
  button{
    height:44px; padding:0 16px; border-radius:12px; cursor:pointer;
    border:1px solid rgba(109,94,252,.55);
    background: linear-gradient(180deg, rgba(109,94,252,.95), rgba(109,94,252,.78));
    color:#fff; font-weight:700; letter-spacing:.2px;
    box-shadow: 0 10px 20px rgba(109,94,252,.22);
  }
  button:disabled{ opacity:.55; cursor:not-allowed; box-shadow:none; }
  .hint{
    font-size:12px; color:var(--muted); padding:0 12px 12px 12px;
  }
  code.k{ color:#c7cffc; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="h">Aura Core</div>
        <div class="s">UI route: <code class="k">/ui</code>  POST <code class="k">/chat</code></div>
      </div>
      <div class="meta">
        <div class="row"><span class="dot"></span><span id="status">Ready</span></div>
        <div class="row"><span>Build:</span><span id="build"></span></div>
        <div class="row"><span>Stamp:</span><span id="stamp"></span></div>
        <div class="row"><span>Local:</span><span id="localtime"></span></div>
      </div>
    </div>

    <div class="panel">
      <div id="log" class="log"></div>
      <div class="composer">
        <textarea id="input" placeholder="Type a command (e.g., PING). Enter = send, Shift+Enter = newline"></textarea>
        <button id="send">Send</button>
      </div>
      <div class="hint">
        Tip: Prefer batch mode via PowerShell for multi-line ops. UI is for quick interactive checks.
      </div>
    </div>
  </div>

<script>
(function(){
  const log = document.getElementById('log');
  const input = document.getElementById('input');
  const sendBtn = document.getElementById('send');
  const statusEl = document.getElementById('status');
  const buildEl = document.getElementById('build');
  const stampEl = document.getElementById('stamp');
  const localEl = document.getElementById('localtime');

  function nowLocal(){
    try { return new Date().toLocaleString(); } catch(e){ return String(new Date()); }
  }
  function setStatus(t, isError){
    statusEl.textContent = t;
    statusEl.style.color = isError ? 'var(--bad)' : 'var(--text)';
  }
  function addMsg(kind, text, opts){
    const d = document.createElement('div');
    d.className = 'msg ' + kind + (opts && opts.error ? ' error' : '');
    d.textContent = text;
    log.appendChild(d);
    log.scrollTop = log.scrollHeight;
  }

  async function postChat(raw){
    const r = await fetch('/chat', {
      method:'POST',
      headers:{ 'content-type':'text/plain; charset=utf-8' },
      body: raw
    });
    const txt = await r.text();
    // Worker may return JSON or plain text
    try { return JSON.parse(txt); } catch(e){ return { ok:false, reply: txt }; }
  }

  async function run(cmd){
    const trimmed = (cmd || '').trim();
    if(!trimmed) return;
    addMsg('me', trimmed);
    input.value = '';
    sendBtn.disabled = true;
    setStatus('Working', false);
    try{
      const res = await postChat(trimmed);
      if(res && typeof res === 'object'){
        if(res.ok){
          const reply = res.reply;
          if(typeof reply === 'string'){
            addMsg('aura', reply);
          }else{
            addMsg('aura', JSON.stringify(reply, null, 2));
          }
          setStatus('Ready', false);
        }else{
          addMsg('aura', (res.reply ? (typeof res.reply === 'string' ? res.reply : JSON.stringify(res.reply, null, 2)) : 'ERROR'), {error:true});
          setStatus('Error', true);
        }
      }else{
        addMsg('aura', String(res), {error:true});
        setStatus('Error', true);
      }
    }catch(err){
      addMsg('aura', 'UI ERROR: ' + (err && err.message ? err.message : String(err)), {error:true});
      setStatus('Error', true);
    }finally{
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // Enter-to-send
  input.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' && !e.shiftKey){
      e.preventDefault();
      run(input.value);
    }
  });
  sendBtn.addEventListener('click', ()=> run(input.value));

  // Boot
  localEl.textContent = nowLocal();
  setInterval(()=>{ localEl.textContent = nowLocal(); }, 1000);

  addMsg('sys', 'Connected. Type a command below (e.g., PING).');

  // Pull build/stamp once
  (async ()=>{
    try{
      const res = await postChat('SHOW_BUILD');
      if(res && res.ok && res.reply && res.reply.build){
        buildEl.textContent = res.reply.build;
        stampEl.textContent = res.reply.stamp || '';
      }else{
        buildEl.textContent = 'unknown';
        stampEl.textContent = '';
      }
    }catch(e){
      buildEl.textContent = 'unknown';
      stampEl.textContent = '';
    }
  })();
})();
</script>
</body>
</html>`;


export default {
  async fetch(request, env) {
    try {

    const url = new URL(request.url);

    // ----------------------------
    // Operator auth (explicit only)  computed early (used by NL responses)
    // ----------------------------
    const operatorToken = env.AURA_OPERATOR_TOKEN || env.AURA_OP_TOKEN || env.OPERATOR_TOKEN || "";
    const operatorHeader =
      request.headers.get("x-operator-token") ||
      request.headers.get("X-Operator-Token") ||
      request.headers.get("x-aura-operator") ||
      request.headers.get("X-Aura-Operator") ||
      request.headers.get("x-aura-operator-token") ||
      request.headers.get("X-Aura-Operator-Token") ||
      (() => {
        const a =
          request.headers.get("authorization") ||
          request.headers.get("Authorization") ||
          "";
        const m = a.match(/^Bearer\s+(.+)$/i);
        return m ? m[1] : "";
      })() ||
      "";
    const isOperator = Boolean(operatorToken) && String(operatorHeader || "").trim() === String(operatorToken || "").trim();


    // UI routing (root + /core + /ui)
    if ((request.method === "GET" || request.method === "HEAD") && (url.pathname === "/" || url.pathname === "/core" || url.pathname === "/ui")) {
      if (request.method === "HEAD") {
        return new Response(null, {
          status: 200,
          headers: { "content-type": "text/html; charset=utf-8" }
        });
      }
      const uiHost = (url && url.host) ? url.host.toLowerCase() : (request.headers.get('host')||'').toLowerCase();
      const mutated0 = await injectUiMutations(env, UI_HTML, uiHost);
      const mutated = mutated0 + "\n<!--UI_CALLSITE_HIT-->\n";
      const forced = mutated + '\n<!--AURA_UI_ROUTE_EXEC_PROBE-->\n'; return new Response(forced, { headers: { 'content-type': 'text/html; charset=utf-8' } });
    }

    // /chat is served; everything else 404
    if (url.pathname !== "/chat") {
      return new Response("Not Found", { status: 404 });
    }

    const body = await request.text();
    const bodyTrim = body.trim();

    // Natural language (no-operator): answer without gating unless user asserts a gated claim.
    const firstLine = (bodyTrim.split(/\r?\n/)[0] || '').trim();
    const firstToken = (firstLine.split(/\s+/)[0] || '').toUpperCase();
    const isBatchLike =
      firstToken &&
      (firstToken === 'HOST' ||
        firstToken === 'AURA-OP' ||
        firstToken === 'AURA_OP' ||
        KNOWN_COMMANDS.includes(firstToken));

    const CLAIM_TRIGGER_WORDS = [
      'live','deployed','launched','resolving','propagating','successful','verified','up','online','working',
      'reachable','available','accessible'
    ];
    const hasClaimTrigger = (s) => {
      const t = String(s || '').toLowerCase();
      return CLAIM_TRIGGER_WORDS.some((w) => new RegExp('(^|\\W)' + w + '($|\\W)').test(t));
    };

    if (bodyTrim && !isBatchLike && !hasClaimTrigger(bodyTrim)) {
      const msg =
        `Aura (control-plane)  ${BUILD} @ ${STAMP}\n` +
        `Operator: ${isOperator ? 'YES' : 'NO'} (planning/help allowed; deploy/DNS actions are operator-only)\n\n` +
        `What I can do right now (without VERIFIED_FETCH):\n` +
        `- Explain identity/capabilities and how to operate\n` +
        `- Show allowed commands, build, snapshot, memory schema\n` +
        `- Read registries (GET/LIST/FILTER) within host caps\n\n` +
        `What requires VERIFIED_FETCH and/or operator token:\n` +
        `- Claims like live/deployed/reachable\n` +
        `- Writes (registry puts), deployer calls, DNS changes\n\n` +
        `Next commands to run:\n` +
        `1) SHOW_ALLOWED_COMMANDS\n` +
        `2) SHOW_BUILD\n` +
        `3) SNAPSHOT_STATE\n` +
        `4) SHOW_MEMORY_SCHEMA\n` +
        `5) REGISTRY_LIST domains\n\n` +
        `Tip: In UI, use ALL-CAPS commands. For multi-line ops, use PowerShell batch mode.`;
      return Response.json({ ok: true, reply: msg });
    }

    // ----------------------------
    // Build / policy markers
    // ----------------------------
    // ----------------------------
    // Operator auth (explicit only)
    // ----------------------------
    // operatorToken/operatorHeader/isOperator are computed above (early)

    // If a token is configured and a caller presents a token header that does not match,
    // fail closed (prevents accidental success with a wrong token).
    const operatorHeaderPresent = Boolean(operatorHeader);
    const operatorMismatch = Boolean(operatorToken) && operatorHeaderPresent && operatorHeader !== operatorToken;
    if (operatorMismatch) return Response.json({ ok: true, reply: "UNAUTHORIZED" });

    // ----------------------------
    // Commands (global allowlist)
    // ----------------------------
    const allowedCommands = [
      "PING",
      "SHOW_BUILD",
      "SHOW_CLAIM_GATE",
      "SHOW_ALLOWED_COMMANDS",
      "RUN_SELF_TEST_EVIDENCE",
      "VERIFIED_FETCH_URL",
      "CLEAR_VERIFIED_FETCH",
      "EVIDENCE_PRESENT",
      "SNAPSHOT_STATE",
      "HOST_CAPS_GET",
      "HOST_CAPS_SET",
      "DEPLOYER_CAPS",
      "DEPLOYER_CALL",
      "PAUSE",
      "INTENT_ADD",
      "INTENT_GET",
      "INTENT_CLEAR",
      "SHOW_MEMORY_SCHEMA",
      "REGISTRY_PUT",
      "REGISTRY_GET",
      "REGISTRY_LIST",
      "REGISTRY_FILTER",
      "REGISTRY_IMPORT_ASSETS",
      "REGISTRY_IMPORT_DOMAINS",
      "PORTFOLIO_STATUS",
      "AUDIT_GET",
      "AUDIT_CLEAR",
      "HERD_STATUS",
      "HERD_SELF_TEST",
      "HERD_SWEEP",
  "AUTONOMY_STATUS",
  "AUTONOMY_LAST_TICK",
        "AUTONOMY_LAST_TICK_SET",
  "AUTONOMY_LAST_TICK_SET",
  "AUTONOMY_CAPABILITIES",
  "INTENT_SIMULATE",
  "REGISTRY_AUDIT_TRAIL",
  "AUTONOMY_BUDGET_GET",
  "AUTONOMY_BUDGET_SET",
  "FAILURE_MEMORY_GET",
  "FAILURE_MEMORY_PUT",
  "AUTONOMY_CHARTER_GET",
  "AUTONOMY_CHARTER_SET",
];

    // ----------------------------
    // Helpers
    // ----------------------------
    const normalizeHost = (u) => {
      try {
        return new URL(u).host.toLowerCase();
      } catch {
        return null;
      }
    };

    // Accept either a full URL or a bare domain token.
    const normalizeHostLoose = (s) => {
      if (!s) return null;
      const h = normalizeHost(s);
      if (h) return h;
