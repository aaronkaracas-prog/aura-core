ntinue;
    }

    if (line.startsWith("VERIFIED_FETCH_URL")) {
      const parts = line.split(" ").filter(Boolean);
      const target = parts[1];
      const ev = await doVerifiedFetch(target);
      push("VERIFIED_FETCH_URL", ev);
      if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
      continue;
    }

    if (line.startsWith("EVIDENCE_PRESENT")) {
      const parts = line.split(" ").filter(Boolean);
      const host = normalizeHostLoose(parts[1]) || activeHost;
      if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
      const stored = await env.AURA_KV.get(evidenceKey(host));
      push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
      continue;
    }

    if (line === "SHOW_MEMORY_SCHEMA") {
      push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
      continue;
    }

if (line === "SHOW_BUILD") {
  push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  continue;
}

if (line === "SHOW_CLAIM_GATE") {
  push("SHOW_CLAIM_GATE", {
    trigger_words: [
      "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
    ],
    forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
    requires_verified_fetch_format: true
  });
  continue;
}

if (line === "SHOW_ALLOWED_COMMANDS") {
  push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  continue;
}

        // ----------------------------
    // AUTONOMY PRIMITIVES (batch mode; deterministic state)
    // ----------------------------
    {
      const __host = String(activeHost || "frontdesk.network").toLowerCase();
      const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
      const __charterKey = `AUTONOMY_CHARTER__${__host}`;
      const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
      const __failKey    = `FAILURE_MEMORY__${__host}`;

      const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
      const __defaultCharter = { version: 1, text: "", updated_at: null };

      const __readJsonKV = async (key) => {
        const s = await env.AURA_KV.get(key);
        if (!s) return null;
        const j = safeJsonParse(s);
        return j || null;
      };

      const __capabilities = [
        "AUTONOMY_STATUS",
        "AUTONOMY_LAST_TICK",
        "AUTONOMY_CAPABILITIES",
        "AUTONOMY_BUDGET_GET",
        "AUTONOMY_BUDGET_SET",
        "AUTONOMY_CHARTER_GET",
        "AUTONOMY_CHARTER_SET",
        "FAILURE_MEMORY_GET",
        "FAILURE_MEMORY_PUT",
        "REGISTRY_AUDIT_TRAIL",
        "INTENT_SIMULATE"
      ];

      if (line === "AUTONOMY_LAST_TICK") {
        const last = await env.AURA_KV.get(__tickKey);
        push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: last || null });
        continue;
      }

      if (line === "AUTONOMY_CAPABILITIES") {
        push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
        continue;
      }

      if (line === "AUTONOMY_BUDGET_GET") {
        const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
        push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
        continue;
      }

      if (line === "AUTONOMY_CHARTER_GET") {
        const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
        push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
        continue;
      }

      if (line === "FAILURE_MEMORY_GET") {
        const fm = (await __readJsonKV(__failKey)) || [];
        push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
        continue;
      }

      if (line === "REGISTRY_AUDIT_TRAIL") {
        // Reuse the existing audit substrate as the authoritative trail output for now.
        // Deterministic: returns latest 50 events (or fewer) using existing auditList().
        push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
        continue;
      }

      if (line === "AUTONOMY_STATUS") {
        const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
        const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
        const last = await env.AURA_KV.get(__tickKey);
        push("AUTONOMY_STATUS", {
          ok: true,
          host: __host,
          build: BUILD,
          stamp: nowIso(),
          evidence_present_for_active_host: Boolean(await env.AURA_KV.get(evidenceKey(__host))),
          budget: b,
          charter: c,
          last_tick: last || null,
          capabilities_count: __capabilities.length
        });
        continue;
      }

      // SET/PUT remain envelope-gated (files/packets) ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Â return deterministic schema, no side-effects.
      if (line === "AUTONOMY_BUDGET_SET") {
        push("AUTONOMY_BUDGET_SET", {
          ok: false,
          error: "BAD_REQUEST",
          note: "requires envelope (file/packet) ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Â no inline JSON",
          schema: { cmd: "AUTONOMY_BUDGET_SET", host: __host, budget: { limit: 100, spent: 0, window: "day" } }
        });
        continue;
      }

      if (line === "AUTONOMY_CHARTER_SET") {
        push("AUTONOMY_CHARTER_SET", {
          ok: false,
          error: "BAD_REQUEST",
          note: "requires envelope (file/packet) ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Â no inline JSON",
          schema: { cmd: "AUTONOMY_CHARTER_SET", host: __host, charter: { version: 1, text: "..." } }
        });
        continue;
      }

      if (line === "FAILURE_MEMORY_PUT") {
        push("FAILURE_MEMORY_PUT", {
          ok: false,
          error: "BAD_REQUEST",
          note: "requires envelope (file/packet) ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Â no inline JSON",
          schema: { cmd: "FAILURE_MEMORY_PUT", host: __host, item: { at: nowIso(), code: "X", detail: "..." } }
        });
        continue;
      }

      if (line === "INTENT_SIMULATE") {
        push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
        continue;
      }
    }    if (line === "AUDIT_GET") {
      if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
      push("AUDIT_GET", await auditList(env, 50));
      continue;
    }

    if (line === "AUDIT_CLEAR") {
      if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
      // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
      if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
      // Must have been seeded via VERIFIED_FETCH_URL in THIS same request (not just previously stored KV evidence).
      if (!__seededThisRequest.has(String(activeHost).toLowerCase())) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
      // IMPORTANT: clearing should never crash the Worker.
      // We clear by resetting the sequence pointer; old event keys become unreachable.
      try {
        await env.AURA_KV.put(auditSeqKey, "0");
        await env.AURA_KV.put(auditClearedAtKey, nowIso());
        out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
      } catch (e) {
        out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
      }
      continue;
    }

    if (line === "PORTFOLIO_STATUS") {
      const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
      const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
      const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
      const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;

      const status = {
        build: BUILD,
        stamp: nowIso(),
        registry_version: REGISTRY_VERSION,
        registries: {
          assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
          domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
        }
      };
      push("PORTFOLIO_STATUS", status);
      continue;
    }

    if (line.startsWith("REGISTRY_PUT")) {
      if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }

      const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
      if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }

      const _t = String(args.type).toLowerCase();
      const item = args.item;

      // Legacy convenience: allow domain puts where id omitted but domain provided.
      if ((!item.id || !String(item.id).trim()) && _t === "domains") {
        const maybe = String(item.domain || item.key || "").trim().toLowerCase();
        if (maybe) item.id = maybe;
      }

      if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }

      const _hostToGate = __domainHostFromRegistryEntry(_t, item);
      if (_hostToGate && (_t === "domains" || _t === "assets")) {
        const _ev = await __getHostEvidence(_hostToGate);
        if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
      }

      const put = await registryPut(env, _t, item);
      push("REGISTRY_PUT", put);
      continue;
    }

    if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
      if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }

      const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
      if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
      const items = parsedArgs.items;

      const idsBefore = await registryGetIndex(env, "assets");
      const ids = [...idsBefore];
      let upserts = 0;

      for (const it of items) {
        if (!it || typeof it !== "object") continue;
        const assetId = String(it.id || "").trim();
        if (!assetId) continue;
        const entry = {
          id: assetId,
          name: String(it.name || it.title || it.id || "").trim() || assetId,
          pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
          notes: String(it.notes || "").trim(),
          tags: Array.isArray(it.tags) ? it.tags : [],
          sellability: String(it.sellability || "UNKNOWN").trim(),
          patent_cluster: String(it.patent_cluster || "").trim()
        };
        const put = await registryPut(env, "assets", entry);
        if (put.ok) {
          upserts += 1;
          if (!ids.includes(entry.id)) ids.push(entry.id);
        }
      }

      await registryPutIndex(env, "assets", ids);
      await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
      push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
      continue;
    }

    if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
      if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }

      const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
      if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
      const items = parsedArgs.items;

      const idsBefore = await registryGetIndex(env, "domains");
      const ids = [...idsBefore];
      let upserts = 0;

      for (const it of items) {
        if (!it || typeof it !== "object") continue;
        const domainId = String(it.id || it.domain || "").trim().toLowerCase();
        if (!domainId) continue;
        const entry = {
          id: domainId,
          domain: String(it.domain || it.id || domainId).toLowerCase(),
          pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
          purpose: String(it.purpose || it.notes || "").trim(),
          priority: String(it.priority || "UNKNOWN").trim(),
          status: String(it.status || "UNKNOWN").trim()
        };
        const put = await registryPut(env, "domains", entry);
        if (put.ok) {
          upserts += 1;
          if (!ids.includes(entry.id)) ids.push(entry.id);
        }
      }

      await registryPutIndex(env, "domains", ids);
      await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
      push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
      continue;
    }

    if (line.startsWith("REGISTRY_IMPORT ")) {
      if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
      const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
      const payload = safeJsonParse(jsonPart);
      const typeName = String(payload?.type || "").toLowerCase().trim();
      const normalized =
        typeName === "asset" || typeName === "assets" ? "assets" :
        typeName === "domain" || typeName === "domains" ? "domains" : "";
      const items = Array.isArray(payload?.items) ? payload.items : null;
      if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
      // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
      // keep simple: write through registryPut in a tight loop.
      const idsBefore = await registryGetIndex(env, normalized);
      const ids = [...idsBefore];
      let upserts = 0;
      for (const it of items) {
        if (!it || typeof it !== "object") continue;
        if (normalized === "domains") {
          const domainId = String(it.id || it.domain || "").trim().toLowerCase();
          if (!domainId) continue;
          const entry = {
            id: domainId,
            domain: String(it.domain || it.id || domainId).toLowerCase(),
            pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
            purpose: String(it.purpose || it.notes || "").trim(),
            priority: String(it.priority || "UNKNOWN").trim(),
            status: String(it.status || "UNKNOWN").trim()
          };
          const put = await registryPut(env, "domains", entry);
          if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
        } else {
          const assetId = String(it.id || "").trim();
          if (!assetId) continue;
          const entry = {
            id: assetId,
            name: String(it.name || it.title || it.id || "").trim() || assetId,
            pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
            notes: String(it.notes || "").trim(),
            tags: Array.isArray(it.tags) ? it.tags : [],
            sellability: String(it.sellability || "UNKNOWN").trim(),
            patent_cluster: String(it.patent_cluster || "").trim()
          };
          const put = await registryPut(env, "assets", entry);
          if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
        }
      }
      await registryPutIndex(env, normalized, ids);
      await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
      push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });
      continue;
    }

    if (line.startsWith("REGISTRY_GET")) {
      const args = __parseRegistryGetArgs(line, lines, i, allowedCommands);
      if (!args || !args.type || !args.id) { push("REGISTRY_GET", "BAD_REQUEST"); continue; }
      const e = await registryGet(env, args.type, args.id);
      push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
      continue;
    }

    if (line.startsWith("REGISTRY_LIST")) {
      const parts = line.split(" ").filter(Boolean);
      const type = String(parts[1] || "").toLowerCase();
      const limit = Number(parts[2] || 50);

      // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
      if (!type) {
        const types = ["assets", "domains"];
        const overview = {};
        for (const t of types) {
          try {
            const ids = await registryGetIndex(env, t);
            overview[t] = { type: t, count: ids.length };
          } catch (e) {
            overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
          }
        }
        push("REGISTRY_LIST", { registries: overview });
        continue;
      }

      const payload = await registryList(env, type, limit);
      push(`REGISTRY_LIST ${type}`, payload);
      continue;
    }

    if (line.startsWith("REGISTRY_FILTER")) {
      const raw = line.slice("REGISTRY_FILTER".length).trim();
      let type = "";
      let field = "";
      let value = "";
      let limit = 50;
      let where = null;

      if (raw.startsWith("{")) {
        const obj = safeJsonParse(raw);
        if (!obj || typeof obj !== "object") { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
        type = String(obj.type || "").toLowerCase();
        limit = Number(obj.limit || 50);
        if (obj.where && typeof obj.where === "object") {
          where = obj.where;
        } else {
          field = String(obj.field || "").trim();
          value = String(obj.value ?? "").trim();
        }
      } else {
        const parts = line.split(" ").filter(Boolean);
        type = String(parts[1] || "").toLowerCase();
        field = String(parts[2] || "").trim();
        value = String(parts[3] || "").trim();
        limit = Number(parts[4] || 50);
      }

      if (!type) { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
      const payload = where
        ? await registryFilterWhere(env, type, where, limit)
        : await registryFilter(env, type, field, value, limit);

      // Allow "REGISTRY_FILTER <type>" (no field/value) as a convenience alias for listing that type
      if (!where && (!field || !value)) {
        const payload2 = await registryList(env, type, limit);
        push(`REGISTRY_FILTER ${type}`, payload2);
        continue;
      }

      push(`REGISTRY_FILTER ${type}`, payload);
      continue;
    }

    if (line.startsWith("HOST_CAPS_GET")) {
      const parts = line.split(" ").filter(Boolean);
      const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
      const caps = await getHostCaps(host);
      push("HOST_CAPS_GET", caps || { host, allowed: null });
      continue;
    }

    if (line === "SNAPSHOT_STATE") {
      const safeHost = activeHost || "none";
      const caps = await getHostCaps(activeHost);
      const stored = activeHost ? await env.AURA_KV.get(evidenceKey(activeHost)) : null;
      const snapshot = {
        build: BUILD,
        stamp: new Date().toISOString(),
        operator: isOperator ? "YES" : "NO",
        active_host: safeHost,
        host_caps: caps || null,
        evidence_present_for_active_host: Boolean(await env.AURA_KV.get(evidenceKey(__host)))
      };
      push("SNAPSHOT_STATE", snapshot);
      continue;
    }

    

    
if (line === "HERD_STATUS") {
  let herd = null;
  try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  push("HERD_STATUS", { ok: true, host: (activeHost || null), herd_config: herd || null, stamp: new Date().toISOString() });
  continue;
}
if (line === "HERD_SELF_TEST") {
  push("HERD_SELF_TEST", { ok: true, tests: [{ name: "command_wired", pass: true }], stamp: new Date().toISOString() });
  continue;
}
if (line.startsWith("HERD_SWEEP")) {
  const raw = line.slice("HERD_SWEEP".length).trim();
  const args = raw ? safeJsonParse(raw) : null;

  let herd = null;
  try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}

  const defaultHosts = (herd && typeof herd === "object" && Array.isArray(herd.hosts)) ? herd.hosts : [];
  const hosts = (args && typeof args === "object" && Array.isArray(args.hosts)) ? args.hosts : defaultHosts;
  const limit = (args && typeof args === "object" && typeof args.limit === "number" && args.limit > 0)
    ? Math.floor(args.limit)
    : hosts.length;

  const targets = hosts.slice(0, limit).map((h) => {
    const hostStr = String(h).trim();
    return { host: hostStr, url: `https://${hostStr}/` };
  });

  const results = [];
  for (const t of targets) {
    try {
      const evidence = await doVerifiedFetch(t.url);
      results.push({ host: t.host, url: t.url, ok: true, evidence });

      // Persist latest sweep into registry (no flags; evidence-driven).
      // Writes:
      // - domain_sweep_latest:<host>  (summary)
      // - domains:<host>             (notes_sweep_latest pointer)
      try {
        if (evidence && evidence.ok) {
          const h = String(t.host || "").trim().toLowerCase();
          const diag = (evidence.diagnostics && typeof evidence.diagnostics === "object") ? evidence.diagnostics : {};
          const cf = (diag.cf && typeof diag.cf === "object") ? diag.cf : null;

          const sweepLatest = {
            id: h,
            host: h,
            url: evidence.public_url || evidence.url || t.url,
            probe_url: evidence.probe_url || null,
            fallback_reason: evidence.fallback_reason || null,
            http_status: typeof evidence.http_status === "number" ? evidence.http_status : 0,
            first_line_html: typeof evidence.first_line_html === "string" ? evidence.first_line_html : "",
            body_length: typeof evidence.body_length === "number" ? evidence.body_length : 0,
            ts: diag.ts || nowIso(),
            https_status: (typeof diag.https_status === "number") ? diag.https_status : null,
            cf: cf ? {
              colo: cf.colo || null,
              asn: cf.asn || null,
              asOrganization: cf.asOrganization || null,
              country: cf.country || null,
              regionCode: cf.regionCode || null,
              city: cf.city || null,
              timezone: cf.timezone || null
            } : null
          };

          await registryPut(env, "domain_sweep_latest", sweepLatest);

          const dom = (await registryGet(env, "domains", h)) || { id: h, domain: h };
          const merged = {
            ...dom,
            id: h,
            domain: dom.domain || h,
            notes_sweep_latest: {
              sweep_latest: {
                host: h,
                ts: sweepLatest.ts,
                http_status: sweepLatest.http_status,
                fallback_reason: sweepLatest.fallback_reason,
                url: sweepLatest.url
              }
            }
          };
          await registryPut(env, "domains", merged);
        }
      } catch (__) {
        // Never fail the sweep response because persistence failed.
      }
    } catch (e) {
      results.push({ host: t.host, url: t.url, ok: false, error: String(e) });
    }
  }

  push("HERD_SWEEP", {
    ok: true,
    requested: { hosts, limit },
    swept: results.length,
    results,
    stamp: new Date().toISOString()
  });
  continue;
}
if (line === "DEPLOYER_CAPS") {
      push("DEPLOYER_CAPS", __deployerCaps(env));
      continue;
    }

    if (line.startsWith("DEPLOYER_CALL ")) {
      if (!isOperator) { push("DEPLOYER_CALL", "UNAUTHORIZED"); continue; }
      const jsonPart = line.slice("DEPLOYER_CALL ".length).trim();
      const reqObj = safeJsonParse(jsonPart);
      if (!reqObj || typeof reqObj !== "object") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }

      const serviceName = String(reqObj.service || "").trim();
      if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
      if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }

      const path = String(reqObj.path || "").trim();
      if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }

      // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
      // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
      try {
        const svc = env[serviceName];
        const resp = await __serviceFetch(svc, {
          path,
          method: reqObj.method || "POST",
          headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
          content_type: reqObj.content_type || null,
          body: reqObj.body != null ? reqObj.body : undefined
        });
        push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
      } catch (e) {
        push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
      }
      continue;
    }

// Any unknown tokens in a batch are ignored (deterministic).
  }

  return jsonReply(JSON.stringify(out, null, 2));
}


    // ----------------------------
    // Multi-line simple commands (e.g., HOST x + PING)
    // ----------------------------
    const hasLine = (cmd) => lines.some((l) => l === cmd);

    if (hasLine("PING")) return jsonReply("PONG");

    if (hasLine("PAUSE")) return jsonReply("PAUSED");

    if (hasLine("SHOW_ALLOWED_COMMANDS")) {
      return jsonReply(allowedCommands);
    }

    if (hasLine("SHOW_BUILD")) {
      return jsonReply(
        JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
      );
    }

    if (hasLine("SHOW_CLAIM_GATE")) {
      return jsonReply(
        JSON.stringify(
          {
            trigger_words: [
              "live",
              "deployed",
              "launched",
              "resolving",
              "propagating",
              "successful",
              "verified",
              "up",
              "online",
              "working",
              "reachable"