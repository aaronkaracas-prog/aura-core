
===== HIT @ line 97 (showing 57..177) =====
    57:   }
    58:   if (lower.includes("help") || lower === "?" || lower.includes("commands")) {
    59:     return "Type an allowed command (e.g., PING, SHOW_BUILD, SNAPSHOT_STATE).\n\nFor host work: HOST <domain>, then EVIDENCE_PRESENT or VERIFIED_FETCH_URL http://<domain>/";
    60:   }
    61:   if (lower.includes("launch") || lower.includes("deploy") || lower.includes("website") || lower.includes("site")) {
    62:     return "I can plan and execute deployments via DEPLOYER_CALL when operator-authorized.\n\nTell me: domain + desired outcome (landing page vs app) and whether we should VERIFIED_FETCH first for the target host.";
    63:   }
    64: 
    65:   // Default: answer politely, no gate.
    66:   return identity + "\n\n" + capability;
    67: }
    68: 
    69: // ==== PATCH: Registry commands bypass claim-gate (2026-01-29) ====
    70: function __registryBypass(token) {
    71:   // Only allow read-only registry operations to bypass claim-gate.
    72:   // Any registry *write* (PUT / IMPORT) must be claim-gated by evidence.
    73:   return token === "REGISTRY_GET" ||
    74:          token === "REGISTRY_LIST" ||
    75:          token === "REGISTRY_FILTER";
    76: }
    77: // ================================================================
    78: const KNOWN_COMMANDS = [
    79:   "PING",
    80:   "SHOW_BUILD",
    81:   "SHOW_CLAIM_GATE",
    82:   "SHOW_ALLOWED_COMMANDS",
    83:   "RUN_SELF_TEST_EVIDENCE",
    84:   "VERIFIED_FETCH_URL",
    85:   "CLEAR_VERIFIED_FETCH",
    86:   "EVIDENCE_PRESENT",
    87:   "SNAPSHOT_STATE",
    88:   "HOST_CAPS_GET",
    89:   "HOST_CAPS_SET",
    90:   "DEPLOYER_CAPS",
    91:   "DEPLOYER_CALL",
    92:   "PAUSE",
    93:   "INTENT_ADD",
    94:   "INTENT_GET",
    95:   "INTENT_CLEAR",
    96:   "SHOW_MEMORY_SCHEMA",
    97:   "REGISTRY_PUT",
    98:   "REGISTRY_GET",
    99:   "REGISTRY_LIST",
   100:   "REGISTRY_FILTER",
   101:   "REGISTRY_IMPORT_ASSETS",
   102:   "REGISTRY_IMPORT_DOMAINS",
   103:   "PORTFOLIO_STATUS",
   104:   "AUDIT_GET",
   105:   "AUDIT_CLEAR",
   106:   "HERD_STATUS",
   107:   "HERD_SELF_TEST",
   108:   "HERD_SWEEP",
   109:   "AUTONOMY_STATUS",
   110:   "AUTONOMY_LAST_TICK",
   111:         "AUTONOMY_LAST_TICK_SET",
   112:   "AUTONOMY_LAST_TICK_SET",
   113:   "AUTONOMY_CAPABILITIES",
   114:   "INTENT_SIMULATE",
   115:   "REGISTRY_AUDIT_TRAIL",
   116:   "AUTONOMY_BUDGET_GET",
   117:   "AUTONOMY_BUDGET_SET",
   118:   "FAILURE_MEMORY_GET",
   119:   "FAILURE_MEMORY_PUT",
   120:   "AUTONOMY_CHARTER_GET",
   121:   "AUTONOMY_CHARTER_SET",
   122: ];
   123: 
   124: const UI_HTML = `<!doctype html>
   125: <html lang="en">
   126: <head>
   127: <meta charset="utf-8" />
   128: <meta name="viewport" content="width=device-width,initial-scale=1" />
   129: <title>Aura Core UI</title>
   130: <style>
   131:   :root{
   132:     --bg:#070a12; --panel:#0e1424; --panel2:#0b1020;
   133:     --text:#e8ecff; --muted:#9aa5c7; --line:rgba(255,255,255,.10);
   134:     --accent:#6d5efc; --good:#48d597; --bad:#ff5c7a;
   135:   }
   136:   *{box-sizing:border-box}
   137:   body{
   138:     margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
   139:     background: radial-gradient(1200px 600px at 30% 10%, rgba(109,94,252,.18), transparent 60%),
   140:                 radial-gradient(900px 500px at 80% 30%, rgba(72,213,151,.10), transparent 55%),
   141:                 var(--bg);
   142:     color:var(--text); height:100vh; display:flex; align-items:center; justify-content:center;
   143:   }
   144:   .wrap{ width:min(980px, 96vw); height:min(720px, 92vh); display:flex; flex-direction:column; gap:12px; }
   145:   .topbar{
   146:     display:flex; align-items:flex-start; justify-content:space-between; gap:16px;
   147:     padding:14px 16px; border:1px solid var(--line); border-radius:16px;
   148:     background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
   149:     box-shadow: 0 10px 30px rgba(0,0,0,.35);
   150:   }
   151:   .brand{ display:flex; flex-direction:column; gap:2px; }
   152:   .brand .h{ font-size:18px; font-weight:700; letter-spacing:.2px; }
   153:   .brand .s{ font-size:12px; color:var(--muted); }
   154:   .meta{
   155:     display:flex; flex-direction:column; align-items:flex-end; gap:4px;
   156:     font-size:12px; color:var(--muted);
   157:   }
   158:   .meta .row{ display:flex; gap:10px; align-items:center; }
   159:   .dot{ width:8px; height:8px; border-radius:50%; background:var(--good); box-shadow:0 0 0 3px rgba(72,213,151,.14); }
   160:   .panel{
   161:     flex:1; min-height:0;
   162:     border:1px solid var(--line); border-radius:16px;
   163:     background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
   164:     box-shadow: 0 10px 30px rgba(0,0,0,.35);
   165:     display:flex; flex-direction:column;
   166:   }
   167:   .log{
   168:     flex:1; min-height:0;
   169:     padding:14px; overflow:auto;
   170:     display:flex; flex-direction:column; gap:10px;
   171:   }
   172:   .msg{
   173:     max-width: 90%;
   174:     border:1px solid var(--line);
   175:     background: rgba(7,10,18,.35);
   176:     padding:10px 12px; border-radius:14px;
   177:     white-space:pre-wrap; word-break:break-word; line-height:1.35;

===== HIT @ line 101 (showing 61..181) =====
    61:   if (lower.includes("launch") || lower.includes("deploy") || lower.includes("website") || lower.includes("site")) {
    62:     return "I can plan and execute deployments via DEPLOYER_CALL when operator-authorized.\n\nTell me: domain + desired outcome (landing page vs app) and whether we should VERIFIED_FETCH first for the target host.";
    63:   }
    64: 
    65:   // Default: answer politely, no gate.
    66:   return identity + "\n\n" + capability;
    67: }
    68: 
    69: // ==== PATCH: Registry commands bypass claim-gate (2026-01-29) ====
    70: function __registryBypass(token) {
    71:   // Only allow read-only registry operations to bypass claim-gate.
    72:   // Any registry *write* (PUT / IMPORT) must be claim-gated by evidence.
    73:   return token === "REGISTRY_GET" ||
    74:          token === "REGISTRY_LIST" ||
    75:          token === "REGISTRY_FILTER";
    76: }
    77: // ================================================================
    78: const KNOWN_COMMANDS = [
    79:   "PING",
    80:   "SHOW_BUILD",
    81:   "SHOW_CLAIM_GATE",
    82:   "SHOW_ALLOWED_COMMANDS",
    83:   "RUN_SELF_TEST_EVIDENCE",
    84:   "VERIFIED_FETCH_URL",
    85:   "CLEAR_VERIFIED_FETCH",
    86:   "EVIDENCE_PRESENT",
    87:   "SNAPSHOT_STATE",
    88:   "HOST_CAPS_GET",
    89:   "HOST_CAPS_SET",
    90:   "DEPLOYER_CAPS",
    91:   "DEPLOYER_CALL",
    92:   "PAUSE",
    93:   "INTENT_ADD",
    94:   "INTENT_GET",
    95:   "INTENT_CLEAR",
    96:   "SHOW_MEMORY_SCHEMA",
    97:   "REGISTRY_PUT",
    98:   "REGISTRY_GET",
    99:   "REGISTRY_LIST",
   100:   "REGISTRY_FILTER",
   101:   "REGISTRY_IMPORT_ASSETS",
   102:   "REGISTRY_IMPORT_DOMAINS",
   103:   "PORTFOLIO_STATUS",
   104:   "AUDIT_GET",
   105:   "AUDIT_CLEAR",
   106:   "HERD_STATUS",
   107:   "HERD_SELF_TEST",
   108:   "HERD_SWEEP",
   109:   "AUTONOMY_STATUS",
   110:   "AUTONOMY_LAST_TICK",
   111:         "AUTONOMY_LAST_TICK_SET",
   112:   "AUTONOMY_LAST_TICK_SET",
   113:   "AUTONOMY_CAPABILITIES",
   114:   "INTENT_SIMULATE",
   115:   "REGISTRY_AUDIT_TRAIL",
   116:   "AUTONOMY_BUDGET_GET",
   117:   "AUTONOMY_BUDGET_SET",
   118:   "FAILURE_MEMORY_GET",
   119:   "FAILURE_MEMORY_PUT",
   120:   "AUTONOMY_CHARTER_GET",
   121:   "AUTONOMY_CHARTER_SET",
   122: ];
   123: 
   124: const UI_HTML = `<!doctype html>
   125: <html lang="en">
   126: <head>
   127: <meta charset="utf-8" />
   128: <meta name="viewport" content="width=device-width,initial-scale=1" />
   129: <title>Aura Core UI</title>
   130: <style>
   131:   :root{
   132:     --bg:#070a12; --panel:#0e1424; --panel2:#0b1020;
   133:     --text:#e8ecff; --muted:#9aa5c7; --line:rgba(255,255,255,.10);
   134:     --accent:#6d5efc; --good:#48d597; --bad:#ff5c7a;
   135:   }
   136:   *{box-sizing:border-box}
   137:   body{
   138:     margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
   139:     background: radial-gradient(1200px 600px at 30% 10%, rgba(109,94,252,.18), transparent 60%),
   140:                 radial-gradient(900px 500px at 80% 30%, rgba(72,213,151,.10), transparent 55%),
   141:                 var(--bg);
   142:     color:var(--text); height:100vh; display:flex; align-items:center; justify-content:center;
   143:   }
   144:   .wrap{ width:min(980px, 96vw); height:min(720px, 92vh); display:flex; flex-direction:column; gap:12px; }
   145:   .topbar{
   146:     display:flex; align-items:flex-start; justify-content:space-between; gap:16px;
   147:     padding:14px 16px; border:1px solid var(--line); border-radius:16px;
   148:     background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
   149:     box-shadow: 0 10px 30px rgba(0,0,0,.35);
   150:   }
   151:   .brand{ display:flex; flex-direction:column; gap:2px; }
   152:   .brand .h{ font-size:18px; font-weight:700; letter-spacing:.2px; }
   153:   .brand .s{ font-size:12px; color:var(--muted); }
   154:   .meta{
   155:     display:flex; flex-direction:column; align-items:flex-end; gap:4px;
   156:     font-size:12px; color:var(--muted);
   157:   }
   158:   .meta .row{ display:flex; gap:10px; align-items:center; }
   159:   .dot{ width:8px; height:8px; border-radius:50%; background:var(--good); box-shadow:0 0 0 3px rgba(72,213,151,.14); }
   160:   .panel{
   161:     flex:1; min-height:0;
   162:     border:1px solid var(--line); border-radius:16px;
   163:     background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
   164:     box-shadow: 0 10px 30px rgba(0,0,0,.35);
   165:     display:flex; flex-direction:column;
   166:   }
   167:   .log{
   168:     flex:1; min-height:0;
   169:     padding:14px; overflow:auto;
   170:     display:flex; flex-direction:column; gap:10px;
   171:   }
   172:   .msg{
   173:     max-width: 90%;
   174:     border:1px solid var(--line);
   175:     background: rgba(7,10,18,.35);
   176:     padding:10px 12px; border-radius:14px;
   177:     white-space:pre-wrap; word-break:break-word; line-height:1.35;
   178:   }
   179:   .msg.me{ align-self:flex-end; background: rgba(109,94,252,.16); border-color: rgba(109,94,252,.35); }
   180:   .msg.aura{ align-self:flex-start; background: rgba(255,255,255,.04); }
   181:   .msg.sys{ align-self:center; max-width:100%; color:var(--muted); background: transparent; border:none; padding:0; }

===== HIT @ line 102 (showing 62..182) =====
    62:     return "I can plan and execute deployments via DEPLOYER_CALL when operator-authorized.\n\nTell me: domain + desired outcome (landing page vs app) and whether we should VERIFIED_FETCH first for the target host.";
    63:   }
    64: 
    65:   // Default: answer politely, no gate.
    66:   return identity + "\n\n" + capability;
    67: }
    68: 
    69: // ==== PATCH: Registry commands bypass claim-gate (2026-01-29) ====
    70: function __registryBypass(token) {
    71:   // Only allow read-only registry operations to bypass claim-gate.
    72:   // Any registry *write* (PUT / IMPORT) must be claim-gated by evidence.
    73:   return token === "REGISTRY_GET" ||
    74:          token === "REGISTRY_LIST" ||
    75:          token === "REGISTRY_FILTER";
    76: }
    77: // ================================================================
    78: const KNOWN_COMMANDS = [
    79:   "PING",
    80:   "SHOW_BUILD",
    81:   "SHOW_CLAIM_GATE",
    82:   "SHOW_ALLOWED_COMMANDS",
    83:   "RUN_SELF_TEST_EVIDENCE",
    84:   "VERIFIED_FETCH_URL",
    85:   "CLEAR_VERIFIED_FETCH",
    86:   "EVIDENCE_PRESENT",
    87:   "SNAPSHOT_STATE",
    88:   "HOST_CAPS_GET",
    89:   "HOST_CAPS_SET",
    90:   "DEPLOYER_CAPS",
    91:   "DEPLOYER_CALL",
    92:   "PAUSE",
    93:   "INTENT_ADD",
    94:   "INTENT_GET",
    95:   "INTENT_CLEAR",
    96:   "SHOW_MEMORY_SCHEMA",
    97:   "REGISTRY_PUT",
    98:   "REGISTRY_GET",
    99:   "REGISTRY_LIST",
   100:   "REGISTRY_FILTER",
   101:   "REGISTRY_IMPORT_ASSETS",
   102:   "REGISTRY_IMPORT_DOMAINS",
   103:   "PORTFOLIO_STATUS",
   104:   "AUDIT_GET",
   105:   "AUDIT_CLEAR",
   106:   "HERD_STATUS",
   107:   "HERD_SELF_TEST",
   108:   "HERD_SWEEP",
   109:   "AUTONOMY_STATUS",
   110:   "AUTONOMY_LAST_TICK",
   111:         "AUTONOMY_LAST_TICK_SET",
   112:   "AUTONOMY_LAST_TICK_SET",
   113:   "AUTONOMY_CAPABILITIES",
   114:   "INTENT_SIMULATE",
   115:   "REGISTRY_AUDIT_TRAIL",
   116:   "AUTONOMY_BUDGET_GET",
   117:   "AUTONOMY_BUDGET_SET",
   118:   "FAILURE_MEMORY_GET",
   119:   "FAILURE_MEMORY_PUT",
   120:   "AUTONOMY_CHARTER_GET",
   121:   "AUTONOMY_CHARTER_SET",
   122: ];
   123: 
   124: const UI_HTML = `<!doctype html>
   125: <html lang="en">
   126: <head>
   127: <meta charset="utf-8" />
   128: <meta name="viewport" content="width=device-width,initial-scale=1" />
   129: <title>Aura Core UI</title>
   130: <style>
   131:   :root{
   132:     --bg:#070a12; --panel:#0e1424; --panel2:#0b1020;
   133:     --text:#e8ecff; --muted:#9aa5c7; --line:rgba(255,255,255,.10);
   134:     --accent:#6d5efc; --good:#48d597; --bad:#ff5c7a;
   135:   }
   136:   *{box-sizing:border-box}
   137:   body{
   138:     margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
   139:     background: radial-gradient(1200px 600px at 30% 10%, rgba(109,94,252,.18), transparent 60%),
   140:                 radial-gradient(900px 500px at 80% 30%, rgba(72,213,151,.10), transparent 55%),
   141:                 var(--bg);
   142:     color:var(--text); height:100vh; display:flex; align-items:center; justify-content:center;
   143:   }
   144:   .wrap{ width:min(980px, 96vw); height:min(720px, 92vh); display:flex; flex-direction:column; gap:12px; }
   145:   .topbar{
   146:     display:flex; align-items:flex-start; justify-content:space-between; gap:16px;
   147:     padding:14px 16px; border:1px solid var(--line); border-radius:16px;
   148:     background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
   149:     box-shadow: 0 10px 30px rgba(0,0,0,.35);
   150:   }
   151:   .brand{ display:flex; flex-direction:column; gap:2px; }
   152:   .brand .h{ font-size:18px; font-weight:700; letter-spacing:.2px; }
   153:   .brand .s{ font-size:12px; color:var(--muted); }
   154:   .meta{
   155:     display:flex; flex-direction:column; align-items:flex-end; gap:4px;
   156:     font-size:12px; color:var(--muted);
   157:   }
   158:   .meta .row{ display:flex; gap:10px; align-items:center; }
   159:   .dot{ width:8px; height:8px; border-radius:50%; background:var(--good); box-shadow:0 0 0 3px rgba(72,213,151,.14); }
   160:   .panel{
   161:     flex:1; min-height:0;
   162:     border:1px solid var(--line); border-radius:16px;
   163:     background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
   164:     box-shadow: 0 10px 30px rgba(0,0,0,.35);
   165:     display:flex; flex-direction:column;
   166:   }
   167:   .log{
   168:     flex:1; min-height:0;
   169:     padding:14px; overflow:auto;
   170:     display:flex; flex-direction:column; gap:10px;
   171:   }
   172:   .msg{
   173:     max-width: 90%;
   174:     border:1px solid var(--line);
   175:     background: rgba(7,10,18,.35);
   176:     padding:10px 12px; border-radius:14px;
   177:     white-space:pre-wrap; word-break:break-word; line-height:1.35;
   178:   }
   179:   .msg.me{ align-self:flex-end; background: rgba(109,94,252,.16); border-color: rgba(109,94,252,.35); }
   180:   .msg.aura{ align-self:flex-start; background: rgba(255,255,255,.04); }
   181:   .msg.sys{ align-self:center; max-width:100%; color:var(--muted); background: transparent; border:none; padding:0; }
   182:   .msg.error{ border-color: rgba(255,92,122,.45); background: rgba(255,92,122,.10); }

===== HIT @ line 271 (showing 231..351) =====
   231:         <button id="send">Send</button>
   232:       </div>
   233:       <div class="hint">
   234:         Tip: Prefer batch mode via PowerShell for multi-line ops. UI is for quick interactive checks.
   235:       </div>
   236:     </div>
   237:   </div>
   238: 
   239: <script>
   240: (function(){
   241:   const log = document.getElementById('log');
   242:   const input = document.getElementById('input');
   243:   const sendBtn = document.getElementById('send');
   244:   const statusEl = document.getElementById('status');
   245:   const buildEl = document.getElementById('build');
   246:   const stampEl = document.getElementById('stamp');
   247:   const localEl = document.getElementById('localtime');
   248: 
   249:   function nowLocal(){
   250:     try { return new Date().toLocaleString(); } catch(e){ return String(new Date()); }
   251:   }
   252:   function setStatus(t, isError){
   253:     statusEl.textContent = t;
   254:     statusEl.style.color = isError ? 'var(--bad)' : 'var(--text)';
   255:   }
   256:   function addMsg(kind, text, opts){
   257:     const d = document.createElement('div');
   258:     d.className = 'msg ' + kind + (opts && opts.error ? ' error' : '');
   259:     d.textContent = text;
   260:     log.appendChild(d);
   261:     log.scrollTop = log.scrollHeight;
   262:   }
   263: 
   264:   async function postChat(raw){
   265:     const r = await fetch('/chat', {
   266:       method:'POST',
   267:       headers:{ 'content-type':'text/plain; charset=utf-8' },
   268:       body: raw
   269:     });
   270:     const txt = await r.text();
   271:     // Worker may return JSON or plain text
   272:     try { return JSON.parse(txt); } catch(e){ return { ok:false, reply: txt }; }
   273:   }
   274: 
   275:   async function run(cmd){
   276:     const trimmed = (cmd || '').trim();
   277:     if(!trimmed) return;
   278:     addMsg('me', trimmed);
   279:     input.value = '';
   280:     sendBtn.disabled = true;
   281:     setStatus('Working', false);
   282:     try{
   283:       const res = await postChat(trimmed);
   284:       if(res && typeof res === 'object'){
   285:         if(res.ok){
   286:           const reply = res.reply;
   287:           if(typeof reply === 'string'){
   288:             addMsg('aura', reply);
   289:           }else{
   290:             addMsg('aura', JSON.stringify(reply, null, 2));
   291:           }
   292:           setStatus('Ready', false);
   293:         }else{
   294:           addMsg('aura', (res.reply ? (typeof res.reply === 'string' ? res.reply : JSON.stringify(res.reply, null, 2)) : 'ERROR'), {error:true});
   295:           setStatus('Error', true);
   296:         }
   297:       }else{
   298:         addMsg('aura', String(res), {error:true});
   299:         setStatus('Error', true);
   300:       }
   301:     }catch(err){
   302:       addMsg('aura', 'UI ERROR: ' + (err && err.message ? err.message : String(err)), {error:true});
   303:       setStatus('Error', true);
   304:     }finally{
   305:       sendBtn.disabled = false;
   306:       input.focus();
   307:     }
   308:   }
   309: 
   310:   // Enter-to-send
   311:   input.addEventListener('keydown', (e)=>{
   312:     if(e.key === 'Enter' && !e.shiftKey){
   313:       e.preventDefault();
   314:       run(input.value);
   315:     }
   316:   });
   317:   sendBtn.addEventListener('click', ()=> run(input.value));
   318: 
   319:   // Boot
   320:   localEl.textContent = nowLocal();
   321:   setInterval(()=>{ localEl.textContent = nowLocal(); }, 1000);
   322: 
   323:   addMsg('sys', 'Connected. Type a command below (e.g., PING).');
   324: 
   325:   // Pull build/stamp once
   326:   (async ()=>{
   327:     try{
   328:       const res = await postChat('SHOW_BUILD');
   329:       if(res && res.ok && res.reply && res.reply.build){
   330:         buildEl.textContent = res.reply.build;
   331:         stampEl.textContent = res.reply.stamp || '';
   332:       }else{
   333:         buildEl.textContent = 'unknown';
   334:         stampEl.textContent = '';
   335:       }
   336:     }catch(e){
   337:       buildEl.textContent = 'unknown';
   338:       stampEl.textContent = '';
   339:     }
   340:   })();
   341: })();
   342: </script>
   343: </body>
   344: </html>`;
   345: 
   346: 
   347: export default {
   348:   async fetch(request, env) {
   349:     try {
   350: 
   351:     const url = new URL(request.url);

===== HIT @ line 272 (showing 232..352) =====
   232:       </div>
   233:       <div class="hint">
   234:         Tip: Prefer batch mode via PowerShell for multi-line ops. UI is for quick interactive checks.
   235:       </div>
   236:     </div>
   237:   </div>
   238: 
   239: <script>
   240: (function(){
   241:   const log = document.getElementById('log');
   242:   const input = document.getElementById('input');
   243:   const sendBtn = document.getElementById('send');
   244:   const statusEl = document.getElementById('status');
   245:   const buildEl = document.getElementById('build');
   246:   const stampEl = document.getElementById('stamp');
   247:   const localEl = document.getElementById('localtime');
   248: 
   249:   function nowLocal(){
   250:     try { return new Date().toLocaleString(); } catch(e){ return String(new Date()); }
   251:   }
   252:   function setStatus(t, isError){
   253:     statusEl.textContent = t;
   254:     statusEl.style.color = isError ? 'var(--bad)' : 'var(--text)';
   255:   }
   256:   function addMsg(kind, text, opts){
   257:     const d = document.createElement('div');
   258:     d.className = 'msg ' + kind + (opts && opts.error ? ' error' : '');
   259:     d.textContent = text;
   260:     log.appendChild(d);
   261:     log.scrollTop = log.scrollHeight;
   262:   }
   263: 
   264:   async function postChat(raw){
   265:     const r = await fetch('/chat', {
   266:       method:'POST',
   267:       headers:{ 'content-type':'text/plain; charset=utf-8' },
   268:       body: raw
   269:     });
   270:     const txt = await r.text();
   271:     // Worker may return JSON or plain text
   272:     try { return JSON.parse(txt); } catch(e){ return { ok:false, reply: txt }; }
   273:   }
   274: 
   275:   async function run(cmd){
   276:     const trimmed = (cmd || '').trim();
   277:     if(!trimmed) return;
   278:     addMsg('me', trimmed);
   279:     input.value = '';
   280:     sendBtn.disabled = true;
   281:     setStatus('Working', false);
   282:     try{
   283:       const res = await postChat(trimmed);
   284:       if(res && typeof res === 'object'){
   285:         if(res.ok){
   286:           const reply = res.reply;
   287:           if(typeof reply === 'string'){
   288:             addMsg('aura', reply);
   289:           }else{
   290:             addMsg('aura', JSON.stringify(reply, null, 2));
   291:           }
   292:           setStatus('Ready', false);
   293:         }else{
   294:           addMsg('aura', (res.reply ? (typeof res.reply === 'string' ? res.reply : JSON.stringify(res.reply, null, 2)) : 'ERROR'), {error:true});
   295:           setStatus('Error', true);
   296:         }
   297:       }else{
   298:         addMsg('aura', String(res), {error:true});
   299:         setStatus('Error', true);
   300:       }
   301:     }catch(err){
   302:       addMsg('aura', 'UI ERROR: ' + (err && err.message ? err.message : String(err)), {error:true});
   303:       setStatus('Error', true);
   304:     }finally{
   305:       sendBtn.disabled = false;
   306:       input.focus();
   307:     }
   308:   }
   309: 
   310:   // Enter-to-send
   311:   input.addEventListener('keydown', (e)=>{
   312:     if(e.key === 'Enter' && !e.shiftKey){
   313:       e.preventDefault();
   314:       run(input.value);
   315:     }
   316:   });
   317:   sendBtn.addEventListener('click', ()=> run(input.value));
   318: 
   319:   // Boot
   320:   localEl.textContent = nowLocal();
   321:   setInterval(()=>{ localEl.textContent = nowLocal(); }, 1000);
   322: 
   323:   addMsg('sys', 'Connected. Type a command below (e.g., PING).');
   324: 
   325:   // Pull build/stamp once
   326:   (async ()=>{
   327:     try{
   328:       const res = await postChat('SHOW_BUILD');
   329:       if(res && res.ok && res.reply && res.reply.build){
   330:         buildEl.textContent = res.reply.build;
   331:         stampEl.textContent = res.reply.stamp || '';
   332:       }else{
   333:         buildEl.textContent = 'unknown';
   334:         stampEl.textContent = '';
   335:       }
   336:     }catch(e){
   337:       buildEl.textContent = 'unknown';
   338:       stampEl.textContent = '';
   339:     }
   340:   })();
   341: })();
   342: </script>
   343: </body>
   344: </html>`;
   345: 
   346: 
   347: export default {
   348:   async fetch(request, env) {
   349:     try {
   350: 
   351:     const url = new URL(request.url);
   352: 

===== HIT @ line 290 (showing 250..370) =====
   250:     try { return new Date().toLocaleString(); } catch(e){ return String(new Date()); }
   251:   }
   252:   function setStatus(t, isError){
   253:     statusEl.textContent = t;
   254:     statusEl.style.color = isError ? 'var(--bad)' : 'var(--text)';
   255:   }
   256:   function addMsg(kind, text, opts){
   257:     const d = document.createElement('div');
   258:     d.className = 'msg ' + kind + (opts && opts.error ? ' error' : '');
   259:     d.textContent = text;
   260:     log.appendChild(d);
   261:     log.scrollTop = log.scrollHeight;
   262:   }
   263: 
   264:   async function postChat(raw){
   265:     const r = await fetch('/chat', {
   266:       method:'POST',
   267:       headers:{ 'content-type':'text/plain; charset=utf-8' },
   268:       body: raw
   269:     });
   270:     const txt = await r.text();
   271:     // Worker may return JSON or plain text
   272:     try { return JSON.parse(txt); } catch(e){ return { ok:false, reply: txt }; }
   273:   }
   274: 
   275:   async function run(cmd){
   276:     const trimmed = (cmd || '').trim();
   277:     if(!trimmed) return;
   278:     addMsg('me', trimmed);
   279:     input.value = '';
   280:     sendBtn.disabled = true;
   281:     setStatus('Working', false);
   282:     try{
   283:       const res = await postChat(trimmed);
   284:       if(res && typeof res === 'object'){
   285:         if(res.ok){
   286:           const reply = res.reply;
   287:           if(typeof reply === 'string'){
   288:             addMsg('aura', reply);
   289:           }else{
   290:             addMsg('aura', JSON.stringify(reply, null, 2));
   291:           }
   292:           setStatus('Ready', false);
   293:         }else{
   294:           addMsg('aura', (res.reply ? (typeof res.reply === 'string' ? res.reply : JSON.stringify(res.reply, null, 2)) : 'ERROR'), {error:true});
   295:           setStatus('Error', true);
   296:         }
   297:       }else{
   298:         addMsg('aura', String(res), {error:true});
   299:         setStatus('Error', true);
   300:       }
   301:     }catch(err){
   302:       addMsg('aura', 'UI ERROR: ' + (err && err.message ? err.message : String(err)), {error:true});
   303:       setStatus('Error', true);
   304:     }finally{
   305:       sendBtn.disabled = false;
   306:       input.focus();
   307:     }
   308:   }
   309: 
   310:   // Enter-to-send
   311:   input.addEventListener('keydown', (e)=>{
   312:     if(e.key === 'Enter' && !e.shiftKey){
   313:       e.preventDefault();
   314:       run(input.value);
   315:     }
   316:   });
   317:   sendBtn.addEventListener('click', ()=> run(input.value));
   318: 
   319:   // Boot
   320:   localEl.textContent = nowLocal();
   321:   setInterval(()=>{ localEl.textContent = nowLocal(); }, 1000);
   322: 
   323:   addMsg('sys', 'Connected. Type a command below (e.g., PING).');
   324: 
   325:   // Pull build/stamp once
   326:   (async ()=>{
   327:     try{
   328:       const res = await postChat('SHOW_BUILD');
   329:       if(res && res.ok && res.reply && res.reply.build){
   330:         buildEl.textContent = res.reply.build;
   331:         stampEl.textContent = res.reply.stamp || '';
   332:       }else{
   333:         buildEl.textContent = 'unknown';
   334:         stampEl.textContent = '';
   335:       }
   336:     }catch(e){
   337:       buildEl.textContent = 'unknown';
   338:       stampEl.textContent = '';
   339:     }
   340:   })();
   341: })();
   342: </script>
   343: </body>
   344: </html>`;
   345: 
   346: 
   347: export default {
   348:   async fetch(request, env) {
   349:     try {
   350: 
   351:     const url = new URL(request.url);
   352: 
   353:     // ----------------------------
   354:     // Operator auth (explicit only)  computed early (used by NL responses)
   355:     // ----------------------------
   356:     const operatorToken = env.AURA_OPERATOR_TOKEN || env.AURA_OP_TOKEN || env.OPERATOR_TOKEN || "";
   357:     const operatorHeader =
   358:       request.headers.get("x-operator-token") ||
   359:       request.headers.get("X-Operator-Token") ||
   360:       request.headers.get("x-aura-operator") ||
   361:       request.headers.get("X-Aura-Operator") ||
   362:       request.headers.get("x-aura-operator-token") ||
   363:       request.headers.get("X-Aura-Operator-Token") ||
   364:       (() => {
   365:         const a =
   366:           request.headers.get("authorization") ||
   367:           request.headers.get("Authorization") ||
   368:           "";
   369:         const m = a.match(/^Bearer\s+(.+)$/i);
   370:         return m ? m[1] : "";

===== HIT @ line 294 (showing 254..374) =====
   254:     statusEl.style.color = isError ? 'var(--bad)' : 'var(--text)';
   255:   }
   256:   function addMsg(kind, text, opts){
   257:     const d = document.createElement('div');
   258:     d.className = 'msg ' + kind + (opts && opts.error ? ' error' : '');
   259:     d.textContent = text;
   260:     log.appendChild(d);
   261:     log.scrollTop = log.scrollHeight;
   262:   }
   263: 
   264:   async function postChat(raw){
   265:     const r = await fetch('/chat', {
   266:       method:'POST',
   267:       headers:{ 'content-type':'text/plain; charset=utf-8' },
   268:       body: raw
   269:     });
   270:     const txt = await r.text();
   271:     // Worker may return JSON or plain text
   272:     try { return JSON.parse(txt); } catch(e){ return { ok:false, reply: txt }; }
   273:   }
   274: 
   275:   async function run(cmd){
   276:     const trimmed = (cmd || '').trim();
   277:     if(!trimmed) return;
   278:     addMsg('me', trimmed);
   279:     input.value = '';
   280:     sendBtn.disabled = true;
   281:     setStatus('Working', false);
   282:     try{
   283:       const res = await postChat(trimmed);
   284:       if(res && typeof res === 'object'){
   285:         if(res.ok){
   286:           const reply = res.reply;
   287:           if(typeof reply === 'string'){
   288:             addMsg('aura', reply);
   289:           }else{
   290:             addMsg('aura', JSON.stringify(reply, null, 2));
   291:           }
   292:           setStatus('Ready', false);
   293:         }else{
   294:           addMsg('aura', (res.reply ? (typeof res.reply === 'string' ? res.reply : JSON.stringify(res.reply, null, 2)) : 'ERROR'), {error:true});
   295:           setStatus('Error', true);
   296:         }
   297:       }else{
   298:         addMsg('aura', String(res), {error:true});
   299:         setStatus('Error', true);
   300:       }
   301:     }catch(err){
   302:       addMsg('aura', 'UI ERROR: ' + (err && err.message ? err.message : String(err)), {error:true});
   303:       setStatus('Error', true);
   304:     }finally{
   305:       sendBtn.disabled = false;
   306:       input.focus();
   307:     }
   308:   }
   309: 
   310:   // Enter-to-send
   311:   input.addEventListener('keydown', (e)=>{
   312:     if(e.key === 'Enter' && !e.shiftKey){
   313:       e.preventDefault();
   314:       run(input.value);
   315:     }
   316:   });
   317:   sendBtn.addEventListener('click', ()=> run(input.value));
   318: 
   319:   // Boot
   320:   localEl.textContent = nowLocal();
   321:   setInterval(()=>{ localEl.textContent = nowLocal(); }, 1000);
   322: 
   323:   addMsg('sys', 'Connected. Type a command below (e.g., PING).');
   324: 
   325:   // Pull build/stamp once
   326:   (async ()=>{
   327:     try{
   328:       const res = await postChat('SHOW_BUILD');
   329:       if(res && res.ok && res.reply && res.reply.build){
   330:         buildEl.textContent = res.reply.build;
   331:         stampEl.textContent = res.reply.stamp || '';
   332:       }else{
   333:         buildEl.textContent = 'unknown';
   334:         stampEl.textContent = '';
   335:       }
   336:     }catch(e){
   337:       buildEl.textContent = 'unknown';
   338:       stampEl.textContent = '';
   339:     }
   340:   })();
   341: })();
   342: </script>
   343: </body>
   344: </html>`;
   345: 
   346: 
   347: export default {
   348:   async fetch(request, env) {
   349:     try {
   350: 
   351:     const url = new URL(request.url);
   352: 
   353:     // ----------------------------
   354:     // Operator auth (explicit only)  computed early (used by NL responses)
   355:     // ----------------------------
   356:     const operatorToken = env.AURA_OPERATOR_TOKEN || env.AURA_OP_TOKEN || env.OPERATOR_TOKEN || "";
   357:     const operatorHeader =
   358:       request.headers.get("x-operator-token") ||
   359:       request.headers.get("X-Operator-Token") ||
   360:       request.headers.get("x-aura-operator") ||
   361:       request.headers.get("X-Aura-Operator") ||
   362:       request.headers.get("x-aura-operator-token") ||
   363:       request.headers.get("X-Aura-Operator-Token") ||
   364:       (() => {
   365:         const a =
   366:           request.headers.get("authorization") ||
   367:           request.headers.get("Authorization") ||
   368:           "";
   369:         const m = a.match(/^Bearer\s+(.+)$/i);
   370:         return m ? m[1] : "";
   371:       })() ||
   372:       "";
   373:     const isOperator = Boolean(operatorToken) && String(operatorHeader || "").trim() === String(operatorToken || "").trim();
   374: 

===== HIT @ line 432 (showing 392..512) =====
   392:     const body = await request.text();
   393:     const bodyTrim = body.trim();
   394: 
   395:     // Natural language (no-operator): answer without gating unless user asserts a gated claim.
   396:     const firstLine = (bodyTrim.split(/\r?\n/)[0] || '').trim();
   397:     const firstToken = (firstLine.split(/\s+/)[0] || '').toUpperCase();
   398:     const isBatchLike =
   399:       firstToken &&
   400:       (firstToken === 'HOST' ||
   401:         firstToken === 'AURA-OP' ||
   402:         firstToken === 'AURA_OP' ||
   403:         KNOWN_COMMANDS.includes(firstToken));
   404: 
   405:     const CLAIM_TRIGGER_WORDS = [
   406:       'live','deployed','launched','resolving','propagating','successful','verified','up','online','working',
   407:       'reachable','available','accessible'
   408:     ];
   409:     const hasClaimTrigger = (s) => {
   410:       const t = String(s || '').toLowerCase();
   411:       return CLAIM_TRIGGER_WORDS.some((w) => new RegExp('(^|\\W)' + w + '($|\\W)').test(t));
   412:     };
   413: 
   414:     if (bodyTrim && !isBatchLike && !hasClaimTrigger(bodyTrim)) {
   415:       const msg =
   416:         `Aura (control-plane)  ${BUILD} @ ${STAMP}\n` +
   417:         `Operator: ${isOperator ? 'YES' : 'NO'} (planning/help allowed; deploy/DNS actions are operator-only)\n\n` +
   418:         `What I can do right now (without VERIFIED_FETCH):\n` +
   419:         `- Explain identity/capabilities and how to operate\n` +
   420:         `- Show allowed commands, build, snapshot, memory schema\n` +
   421:         `- Read registries (GET/LIST/FILTER) within host caps\n\n` +
   422:         `What requires VERIFIED_FETCH and/or operator token:\n` +
   423:         `- Claims like live/deployed/reachable\n` +
   424:         `- Writes (registry puts), deployer calls, DNS changes\n\n` +
   425:         `Next commands to run:\n` +
   426:         `1) SHOW_ALLOWED_COMMANDS\n` +
   427:         `2) SHOW_BUILD\n` +
   428:         `3) SNAPSHOT_STATE\n` +
   429:         `4) SHOW_MEMORY_SCHEMA\n` +
   430:         `5) REGISTRY_LIST domains\n\n` +
   431:         `Tip: In UI, use ALL-CAPS commands. For multi-line ops, use PowerShell batch mode.`;
   432:       return Response.json({ ok: true, reply: msg });
   433:     }
   434: 
   435:     // ----------------------------
   436:     // Build / policy markers
   437:     // ----------------------------
   438:     // ----------------------------
   439:     // Operator auth (explicit only)
   440:     // ----------------------------
   441:     // operatorToken/operatorHeader/isOperator are computed above (early)
   442: 
   443:     // If a token is configured and a caller presents a token header that does not match,
   444:     // fail closed (prevents accidental success with a wrong token).
   445:     const operatorHeaderPresent = Boolean(operatorHeader);
   446:     const operatorMismatch = Boolean(operatorToken) && operatorHeaderPresent && operatorHeader !== operatorToken;
   447:     if (operatorMismatch) return Response.json({ ok: true, reply: "UNAUTHORIZED" });
   448: 
   449:     // ----------------------------
   450:     // Commands (global allowlist)
   451:     // ----------------------------
   452:     const allowedCommands = [
   453:       "PING",
   454:       "SHOW_BUILD",
   455:       "SHOW_CLAIM_GATE",
   456:       "SHOW_ALLOWED_COMMANDS",
   457:       "RUN_SELF_TEST_EVIDENCE",
   458:       "VERIFIED_FETCH_URL",
   459:       "CLEAR_VERIFIED_FETCH",
   460:       "EVIDENCE_PRESENT",
   461:       "SNAPSHOT_STATE",
   462:       "HOST_CAPS_GET",
   463:       "HOST_CAPS_SET",
   464:       "DEPLOYER_CAPS",
   465:       "DEPLOYER_CALL",
   466:       "PAUSE",
   467:       "INTENT_ADD",
   468:       "INTENT_GET",
   469:       "INTENT_CLEAR",
   470:       "SHOW_MEMORY_SCHEMA",
   471:       "REGISTRY_PUT",
   472:       "REGISTRY_GET",
   473:       "REGISTRY_LIST",
   474:       "REGISTRY_FILTER",
   475:       "REGISTRY_IMPORT_ASSETS",
   476:       "REGISTRY_IMPORT_DOMAINS",
   477:       "PORTFOLIO_STATUS",
   478:       "AUDIT_GET",
   479:       "AUDIT_CLEAR",
   480:       "HERD_STATUS",
   481:       "HERD_SELF_TEST",
   482:       "HERD_SWEEP",
   483:   "AUTONOMY_STATUS",
   484:   "AUTONOMY_LAST_TICK",
   485:         "AUTONOMY_LAST_TICK_SET",
   486:   "AUTONOMY_LAST_TICK_SET",
   487:   "AUTONOMY_CAPABILITIES",
   488:   "INTENT_SIMULATE",
   489:   "REGISTRY_AUDIT_TRAIL",
   490:   "AUTONOMY_BUDGET_GET",
   491:   "AUTONOMY_BUDGET_SET",
   492:   "FAILURE_MEMORY_GET",
   493:   "FAILURE_MEMORY_PUT",
   494:   "AUTONOMY_CHARTER_GET",
   495:   "AUTONOMY_CHARTER_SET",
   496: ];
   497: 
   498:     // ----------------------------
   499:     // Helpers
   500:     // ----------------------------
   501:     const normalizeHost = (u) => {
   502:       try {
   503:         return new URL(u).host.toLowerCase();
   504:       } catch {
   505:         return null;
   506:       }
   507:     };
   508: 
   509:     // Accept either a full URL or a bare domain token.
   510:     const normalizeHostLoose = (s) => {
   511:       if (!s) return null;
   512:       const h = normalizeHost(s);

===== HIT @ line 447 (showing 407..527) =====
   407:       'reachable','available','accessible'
   408:     ];
   409:     const hasClaimTrigger = (s) => {
   410:       const t = String(s || '').toLowerCase();
   411:       return CLAIM_TRIGGER_WORDS.some((w) => new RegExp('(^|\\W)' + w + '($|\\W)').test(t));
   412:     };
   413: 
   414:     if (bodyTrim && !isBatchLike && !hasClaimTrigger(bodyTrim)) {
   415:       const msg =
   416:         `Aura (control-plane)  ${BUILD} @ ${STAMP}\n` +
   417:         `Operator: ${isOperator ? 'YES' : 'NO'} (planning/help allowed; deploy/DNS actions are operator-only)\n\n` +
   418:         `What I can do right now (without VERIFIED_FETCH):\n` +
   419:         `- Explain identity/capabilities and how to operate\n` +
   420:         `- Show allowed commands, build, snapshot, memory schema\n` +
   421:         `- Read registries (GET/LIST/FILTER) within host caps\n\n` +
   422:         `What requires VERIFIED_FETCH and/or operator token:\n` +
   423:         `- Claims like live/deployed/reachable\n` +
   424:         `- Writes (registry puts), deployer calls, DNS changes\n\n` +
   425:         `Next commands to run:\n` +
   426:         `1) SHOW_ALLOWED_COMMANDS\n` +
   427:         `2) SHOW_BUILD\n` +
   428:         `3) SNAPSHOT_STATE\n` +
   429:         `4) SHOW_MEMORY_SCHEMA\n` +
   430:         `5) REGISTRY_LIST domains\n\n` +
   431:         `Tip: In UI, use ALL-CAPS commands. For multi-line ops, use PowerShell batch mode.`;
   432:       return Response.json({ ok: true, reply: msg });
   433:     }
   434: 
   435:     // ----------------------------
   436:     // Build / policy markers
   437:     // ----------------------------
   438:     // ----------------------------
   439:     // Operator auth (explicit only)
   440:     // ----------------------------
   441:     // operatorToken/operatorHeader/isOperator are computed above (early)
   442: 
   443:     // If a token is configured and a caller presents a token header that does not match,
   444:     // fail closed (prevents accidental success with a wrong token).
   445:     const operatorHeaderPresent = Boolean(operatorHeader);
   446:     const operatorMismatch = Boolean(operatorToken) && operatorHeaderPresent && operatorHeader !== operatorToken;
   447:     if (operatorMismatch) return Response.json({ ok: true, reply: "UNAUTHORIZED" });
   448: 
   449:     // ----------------------------
   450:     // Commands (global allowlist)
   451:     // ----------------------------
   452:     const allowedCommands = [
   453:       "PING",
   454:       "SHOW_BUILD",
   455:       "SHOW_CLAIM_GATE",
   456:       "SHOW_ALLOWED_COMMANDS",
   457:       "RUN_SELF_TEST_EVIDENCE",
   458:       "VERIFIED_FETCH_URL",
   459:       "CLEAR_VERIFIED_FETCH",
   460:       "EVIDENCE_PRESENT",
   461:       "SNAPSHOT_STATE",
   462:       "HOST_CAPS_GET",
   463:       "HOST_CAPS_SET",
   464:       "DEPLOYER_CAPS",
   465:       "DEPLOYER_CALL",
   466:       "PAUSE",
   467:       "INTENT_ADD",
   468:       "INTENT_GET",
   469:       "INTENT_CLEAR",
   470:       "SHOW_MEMORY_SCHEMA",
   471:       "REGISTRY_PUT",
   472:       "REGISTRY_GET",
   473:       "REGISTRY_LIST",
   474:       "REGISTRY_FILTER",
   475:       "REGISTRY_IMPORT_ASSETS",
   476:       "REGISTRY_IMPORT_DOMAINS",
   477:       "PORTFOLIO_STATUS",
   478:       "AUDIT_GET",
   479:       "AUDIT_CLEAR",
   480:       "HERD_STATUS",
   481:       "HERD_SELF_TEST",
   482:       "HERD_SWEEP",
   483:   "AUTONOMY_STATUS",
   484:   "AUTONOMY_LAST_TICK",
   485:         "AUTONOMY_LAST_TICK_SET",
   486:   "AUTONOMY_LAST_TICK_SET",
   487:   "AUTONOMY_CAPABILITIES",
   488:   "INTENT_SIMULATE",
   489:   "REGISTRY_AUDIT_TRAIL",
   490:   "AUTONOMY_BUDGET_GET",
   491:   "AUTONOMY_BUDGET_SET",
   492:   "FAILURE_MEMORY_GET",
   493:   "FAILURE_MEMORY_PUT",
   494:   "AUTONOMY_CHARTER_GET",
   495:   "AUTONOMY_CHARTER_SET",
   496: ];
   497: 
   498:     // ----------------------------
   499:     // Helpers
   500:     // ----------------------------
   501:     const normalizeHost = (u) => {
   502:       try {
   503:         return new URL(u).host.toLowerCase();
   504:       } catch {
   505:         return null;
   506:       }
   507:     };
   508: 
   509:     // Accept either a full URL or a bare domain token.
   510:     const normalizeHostLoose = (s) => {
   511:       if (!s) return null;
   512:       const h = normalizeHost(s);
   513:       if (h) return h;
   514:       const t = String(s).trim().toLowerCase();
   515:       if (!t) return null;
   516:       // Basic sanity: must contain a dot and only valid hostname chars.
   517:       if (!t.includes(".")) return null;
   518:       if (!/^[a-z0-9.-]+$/.test(t)) return null;
   519:       return t;
   520:     };
   521: 
   522:     const extractLastUrl = (txt) => {
   523:       const matches = [...txt.matchAll(/https?:\/\/[^\s]+/g)];
   524:       return matches.length ? matches[matches.length - 1][0] : null;
   525:     };
   526: 
   527:     // Extract a bare domain mention like example.com (no scheme).

===== HIT @ line 471 (showing 431..551) =====
   431:         `Tip: In UI, use ALL-CAPS commands. For multi-line ops, use PowerShell batch mode.`;
   432:       return Response.json({ ok: true, reply: msg });
   433:     }
   434: 
   435:     // ----------------------------
   436:     // Build / policy markers
   437:     // ----------------------------
   438:     // ----------------------------
   439:     // Operator auth (explicit only)
   440:     // ----------------------------
   441:     // operatorToken/operatorHeader/isOperator are computed above (early)
   442: 
   443:     // If a token is configured and a caller presents a token header that does not match,
   444:     // fail closed (prevents accidental success with a wrong token).
   445:     const operatorHeaderPresent = Boolean(operatorHeader);
   446:     const operatorMismatch = Boolean(operatorToken) && operatorHeaderPresent && operatorHeader !== operatorToken;
   447:     if (operatorMismatch) return Response.json({ ok: true, reply: "UNAUTHORIZED" });
   448: 
   449:     // ----------------------------
   450:     // Commands (global allowlist)
   451:     // ----------------------------
   452:     const allowedCommands = [
   453:       "PING",
   454:       "SHOW_BUILD",
   455:       "SHOW_CLAIM_GATE",
   456:       "SHOW_ALLOWED_COMMANDS",
   457:       "RUN_SELF_TEST_EVIDENCE",
   458:       "VERIFIED_FETCH_URL",
   459:       "CLEAR_VERIFIED_FETCH",
   460:       "EVIDENCE_PRESENT",
   461:       "SNAPSHOT_STATE",
   462:       "HOST_CAPS_GET",
   463:       "HOST_CAPS_SET",
   464:       "DEPLOYER_CAPS",
   465:       "DEPLOYER_CALL",
   466:       "PAUSE",
   467:       "INTENT_ADD",
   468:       "INTENT_GET",
   469:       "INTENT_CLEAR",
   470:       "SHOW_MEMORY_SCHEMA",
   471:       "REGISTRY_PUT",
   472:       "REGISTRY_GET",
   473:       "REGISTRY_LIST",
   474:       "REGISTRY_FILTER",
   475:       "REGISTRY_IMPORT_ASSETS",
   476:       "REGISTRY_IMPORT_DOMAINS",
   477:       "PORTFOLIO_STATUS",
   478:       "AUDIT_GET",
   479:       "AUDIT_CLEAR",
   480:       "HERD_STATUS",
   481:       "HERD_SELF_TEST",
   482:       "HERD_SWEEP",
   483:   "AUTONOMY_STATUS",
   484:   "AUTONOMY_LAST_TICK",
   485:         "AUTONOMY_LAST_TICK_SET",
   486:   "AUTONOMY_LAST_TICK_SET",
   487:   "AUTONOMY_CAPABILITIES",
   488:   "INTENT_SIMULATE",
   489:   "REGISTRY_AUDIT_TRAIL",
   490:   "AUTONOMY_BUDGET_GET",
   491:   "AUTONOMY_BUDGET_SET",
   492:   "FAILURE_MEMORY_GET",
   493:   "FAILURE_MEMORY_PUT",
   494:   "AUTONOMY_CHARTER_GET",
   495:   "AUTONOMY_CHARTER_SET",
   496: ];
   497: 
   498:     // ----------------------------
   499:     // Helpers
   500:     // ----------------------------
   501:     const normalizeHost = (u) => {
   502:       try {
   503:         return new URL(u).host.toLowerCase();
   504:       } catch {
   505:         return null;
   506:       }
   507:     };
   508: 
   509:     // Accept either a full URL or a bare domain token.
   510:     const normalizeHostLoose = (s) => {
   511:       if (!s) return null;
   512:       const h = normalizeHost(s);
   513:       if (h) return h;
   514:       const t = String(s).trim().toLowerCase();
   515:       if (!t) return null;
   516:       // Basic sanity: must contain a dot and only valid hostname chars.
   517:       if (!t.includes(".")) return null;
   518:       if (!/^[a-z0-9.-]+$/.test(t)) return null;
   519:       return t;
   520:     };
   521: 
   522:     const extractLastUrl = (txt) => {
   523:       const matches = [...txt.matchAll(/https?:\/\/[^\s]+/g)];
   524:       return matches.length ? matches[matches.length - 1][0] : null;
   525:     };
   526: 
   527:     // Extract a bare domain mention like example.com (no scheme).
   528:     // Returns the last plausible domain token found in the message.
   529:     const extractLastBareDomain = (txt) => {
   530:       // labels + TLD; excludes trailing punctuation due to \b
   531:       const re =
   532:         /\b([a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)+)\b/gi;
   533:       const matches = [];
   534:       let m;
   535:       while ((m = re.exec(txt)) !== null) {
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";

===== HIT @ line 475 (showing 435..555) =====
   435:     // ----------------------------
   436:     // Build / policy markers
   437:     // ----------------------------
   438:     // ----------------------------
   439:     // Operator auth (explicit only)
   440:     // ----------------------------
   441:     // operatorToken/operatorHeader/isOperator are computed above (early)
   442: 
   443:     // If a token is configured and a caller presents a token header that does not match,
   444:     // fail closed (prevents accidental success with a wrong token).
   445:     const operatorHeaderPresent = Boolean(operatorHeader);
   446:     const operatorMismatch = Boolean(operatorToken) && operatorHeaderPresent && operatorHeader !== operatorToken;
   447:     if (operatorMismatch) return Response.json({ ok: true, reply: "UNAUTHORIZED" });
   448: 
   449:     // ----------------------------
   450:     // Commands (global allowlist)
   451:     // ----------------------------
   452:     const allowedCommands = [
   453:       "PING",
   454:       "SHOW_BUILD",
   455:       "SHOW_CLAIM_GATE",
   456:       "SHOW_ALLOWED_COMMANDS",
   457:       "RUN_SELF_TEST_EVIDENCE",
   458:       "VERIFIED_FETCH_URL",
   459:       "CLEAR_VERIFIED_FETCH",
   460:       "EVIDENCE_PRESENT",
   461:       "SNAPSHOT_STATE",
   462:       "HOST_CAPS_GET",
   463:       "HOST_CAPS_SET",
   464:       "DEPLOYER_CAPS",
   465:       "DEPLOYER_CALL",
   466:       "PAUSE",
   467:       "INTENT_ADD",
   468:       "INTENT_GET",
   469:       "INTENT_CLEAR",
   470:       "SHOW_MEMORY_SCHEMA",
   471:       "REGISTRY_PUT",
   472:       "REGISTRY_GET",
   473:       "REGISTRY_LIST",
   474:       "REGISTRY_FILTER",
   475:       "REGISTRY_IMPORT_ASSETS",
   476:       "REGISTRY_IMPORT_DOMAINS",
   477:       "PORTFOLIO_STATUS",
   478:       "AUDIT_GET",
   479:       "AUDIT_CLEAR",
   480:       "HERD_STATUS",
   481:       "HERD_SELF_TEST",
   482:       "HERD_SWEEP",
   483:   "AUTONOMY_STATUS",
   484:   "AUTONOMY_LAST_TICK",
   485:         "AUTONOMY_LAST_TICK_SET",
   486:   "AUTONOMY_LAST_TICK_SET",
   487:   "AUTONOMY_CAPABILITIES",
   488:   "INTENT_SIMULATE",
   489:   "REGISTRY_AUDIT_TRAIL",
   490:   "AUTONOMY_BUDGET_GET",
   491:   "AUTONOMY_BUDGET_SET",
   492:   "FAILURE_MEMORY_GET",
   493:   "FAILURE_MEMORY_PUT",
   494:   "AUTONOMY_CHARTER_GET",
   495:   "AUTONOMY_CHARTER_SET",
   496: ];
   497: 
   498:     // ----------------------------
   499:     // Helpers
   500:     // ----------------------------
   501:     const normalizeHost = (u) => {
   502:       try {
   503:         return new URL(u).host.toLowerCase();
   504:       } catch {
   505:         return null;
   506:       }
   507:     };
   508: 
   509:     // Accept either a full URL or a bare domain token.
   510:     const normalizeHostLoose = (s) => {
   511:       if (!s) return null;
   512:       const h = normalizeHost(s);
   513:       if (h) return h;
   514:       const t = String(s).trim().toLowerCase();
   515:       if (!t) return null;
   516:       // Basic sanity: must contain a dot and only valid hostname chars.
   517:       if (!t.includes(".")) return null;
   518:       if (!/^[a-z0-9.-]+$/.test(t)) return null;
   519:       return t;
   520:     };
   521: 
   522:     const extractLastUrl = (txt) => {
   523:       const matches = [...txt.matchAll(/https?:\/\/[^\s]+/g)];
   524:       return matches.length ? matches[matches.length - 1][0] : null;
   525:     };
   526: 
   527:     // Extract a bare domain mention like example.com (no scheme).
   528:     // Returns the last plausible domain token found in the message.
   529:     const extractLastBareDomain = (txt) => {
   530:       // labels + TLD; excludes trailing punctuation due to \b
   531:       const re =
   532:         /\b([a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)+)\b/gi;
   533:       const matches = [];
   534:       let m;
   535:       while ((m = re.exec(txt)) !== null) {
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;

===== HIT @ line 476 (showing 436..556) =====
   436:     // Build / policy markers
   437:     // ----------------------------
   438:     // ----------------------------
   439:     // Operator auth (explicit only)
   440:     // ----------------------------
   441:     // operatorToken/operatorHeader/isOperator are computed above (early)
   442: 
   443:     // If a token is configured and a caller presents a token header that does not match,
   444:     // fail closed (prevents accidental success with a wrong token).
   445:     const operatorHeaderPresent = Boolean(operatorHeader);
   446:     const operatorMismatch = Boolean(operatorToken) && operatorHeaderPresent && operatorHeader !== operatorToken;
   447:     if (operatorMismatch) return Response.json({ ok: true, reply: "UNAUTHORIZED" });
   448: 
   449:     // ----------------------------
   450:     // Commands (global allowlist)
   451:     // ----------------------------
   452:     const allowedCommands = [
   453:       "PING",
   454:       "SHOW_BUILD",
   455:       "SHOW_CLAIM_GATE",
   456:       "SHOW_ALLOWED_COMMANDS",
   457:       "RUN_SELF_TEST_EVIDENCE",
   458:       "VERIFIED_FETCH_URL",
   459:       "CLEAR_VERIFIED_FETCH",
   460:       "EVIDENCE_PRESENT",
   461:       "SNAPSHOT_STATE",
   462:       "HOST_CAPS_GET",
   463:       "HOST_CAPS_SET",
   464:       "DEPLOYER_CAPS",
   465:       "DEPLOYER_CALL",
   466:       "PAUSE",
   467:       "INTENT_ADD",
   468:       "INTENT_GET",
   469:       "INTENT_CLEAR",
   470:       "SHOW_MEMORY_SCHEMA",
   471:       "REGISTRY_PUT",
   472:       "REGISTRY_GET",
   473:       "REGISTRY_LIST",
   474:       "REGISTRY_FILTER",
   475:       "REGISTRY_IMPORT_ASSETS",
   476:       "REGISTRY_IMPORT_DOMAINS",
   477:       "PORTFOLIO_STATUS",
   478:       "AUDIT_GET",
   479:       "AUDIT_CLEAR",
   480:       "HERD_STATUS",
   481:       "HERD_SELF_TEST",
   482:       "HERD_SWEEP",
   483:   "AUTONOMY_STATUS",
   484:   "AUTONOMY_LAST_TICK",
   485:         "AUTONOMY_LAST_TICK_SET",
   486:   "AUTONOMY_LAST_TICK_SET",
   487:   "AUTONOMY_CAPABILITIES",
   488:   "INTENT_SIMULATE",
   489:   "REGISTRY_AUDIT_TRAIL",
   490:   "AUTONOMY_BUDGET_GET",
   491:   "AUTONOMY_BUDGET_SET",
   492:   "FAILURE_MEMORY_GET",
   493:   "FAILURE_MEMORY_PUT",
   494:   "AUTONOMY_CHARTER_GET",
   495:   "AUTONOMY_CHARTER_SET",
   496: ];
   497: 
   498:     // ----------------------------
   499:     // Helpers
   500:     // ----------------------------
   501:     const normalizeHost = (u) => {
   502:       try {
   503:         return new URL(u).host.toLowerCase();
   504:       } catch {
   505:         return null;
   506:       }
   507:     };
   508: 
   509:     // Accept either a full URL or a bare domain token.
   510:     const normalizeHostLoose = (s) => {
   511:       if (!s) return null;
   512:       const h = normalizeHost(s);
   513:       if (h) return h;
   514:       const t = String(s).trim().toLowerCase();
   515:       if (!t) return null;
   516:       // Basic sanity: must contain a dot and only valid hostname chars.
   517:       if (!t.includes(".")) return null;
   518:       if (!/^[a-z0-9.-]+$/.test(t)) return null;
   519:       return t;
   520:     };
   521: 
   522:     const extractLastUrl = (txt) => {
   523:       const matches = [...txt.matchAll(/https?:\/\/[^\s]+/g)];
   524:       return matches.length ? matches[matches.length - 1][0] : null;
   525:     };
   526: 
   527:     // Extract a bare domain mention like example.com (no scheme).
   528:     // Returns the last plausible domain token found in the message.
   529:     const extractLastBareDomain = (txt) => {
   530:       // labels + TLD; excludes trailing punctuation due to \b
   531:       const re =
   532:         /\b([a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)+)\b/gi;
   533:       const matches = [];
   534:       let m;
   535:       while ((m = re.exec(txt)) !== null) {
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;
   556: 

===== HIT @ line 563 (showing 523..643) =====
   523:       const matches = [...txt.matchAll(/https?:\/\/[^\s]+/g)];
   524:       return matches.length ? matches[matches.length - 1][0] : null;
   525:     };
   526: 
   527:     // Extract a bare domain mention like example.com (no scheme).
   528:     // Returns the last plausible domain token found in the message.
   529:     const extractLastBareDomain = (txt) => {
   530:       // labels + TLD; excludes trailing punctuation due to \b
   531:       const re =
   532:         /\b([a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)+)\b/gi;
   533:       const matches = [];
   534:       let m;
   535:       while ((m = re.exec(txt)) !== null) {
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;
   556: 
   557: const auditSeqKey = `audit:${REGISTRY_VERSION}:seq`;
   558: const auditEventKey = (seq) => `audit:${REGISTRY_VERSION}:event:${seq}`;
   559: const auditClearedAtKey = `audit:${REGISTRY_VERSION}:cleared_at`;
   560: 
   561: const nowIso = () => new Date().toISOString();
   562: 
   563: const safeJsonParse = (s) => {
   564:   try {
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };

===== HIT @ line 565 (showing 525..645) =====
   525:     };
   526: 
   527:     // Extract a bare domain mention like example.com (no scheme).
   528:     // Returns the last plausible domain token found in the message.
   529:     const extractLastBareDomain = (txt) => {
   530:       // labels + TLD; excludes trailing punctuation due to \b
   531:       const re =
   532:         /\b([a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)+)\b/gi;
   533:       const matches = [];
   534:       let m;
   535:       while ((m = re.exec(txt)) !== null) {
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;
   556: 
   557: const auditSeqKey = `audit:${REGISTRY_VERSION}:seq`;
   558: const auditEventKey = (seq) => `audit:${REGISTRY_VERSION}:event:${seq}`;
   559: const auditClearedAtKey = `audit:${REGISTRY_VERSION}:cleared_at`;
   560: 
   561: const nowIso = () => new Date().toISOString();
   562: 
   563: const safeJsonParse = (s) => {
   564:   try {
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };

===== HIT @ line 572 (showing 532..652) =====
   532:         /\b([a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)+)\b/gi;
   533:       const matches = [];
   534:       let m;
   535:       while ((m = re.exec(txt)) !== null) {
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;
   556: 
   557: const auditSeqKey = `audit:${REGISTRY_VERSION}:seq`;
   558: const auditEventKey = (seq) => `audit:${REGISTRY_VERSION}:event:${seq}`;
   559: const auditClearedAtKey = `audit:${REGISTRY_VERSION}:cleared_at`;
   560: 
   561: const nowIso = () => new Date().toISOString();
   562: 
   563: const safeJsonParse = (s) => {
   564:   try {
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();

===== HIT @ line 574 (showing 534..654) =====
   534:       let m;
   535:       while ((m = re.exec(txt)) !== null) {
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;
   556: 
   557: const auditSeqKey = `audit:${REGISTRY_VERSION}:seq`;
   558: const auditEventKey = (seq) => `audit:${REGISTRY_VERSION}:event:${seq}`;
   559: const auditClearedAtKey = `audit:${REGISTRY_VERSION}:cleared_at`;
   560: 
   561: const nowIso = () => new Date().toISOString();
   562: 
   563: const safeJsonParse = (s) => {
   564:   try {
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };

===== HIT @ line 575 (showing 535..655) =====
   535:       while ((m = re.exec(txt)) !== null) {
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;
   556: 
   557: const auditSeqKey = `audit:${REGISTRY_VERSION}:seq`;
   558: const auditEventKey = (seq) => `audit:${REGISTRY_VERSION}:event:${seq}`;
   559: const auditClearedAtKey = `audit:${REGISTRY_VERSION}:cleared_at`;
   560: 
   561: const nowIso = () => new Date().toISOString();
   562: 
   563: const safeJsonParse = (s) => {
   564:   try {
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }

===== HIT @ line 576 (showing 536..656) =====
   536:         const d = (m[1] || "").toLowerCase();
   537:         if (!d) continue;
   538:         if (d === "localhost") continue;
   539:         matches.push(d);
   540:       }
   541:       return matches.length ? matches[matches.length - 1] : null;
   542:     };
   543: 
   544:     const statusReachable = (st) => Number(st) >= 200 && Number(st) < 400;
   545:     const evidenceKey = (host) => `verified_fetch:${host}`;
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;
   556: 
   557: const auditSeqKey = `audit:${REGISTRY_VERSION}:seq`;
   558: const auditEventKey = (seq) => `audit:${REGISTRY_VERSION}:event:${seq}`;
   559: const auditClearedAtKey = `audit:${REGISTRY_VERSION}:cleared_at`;
   560: 
   561: const nowIso = () => new Date().toISOString();
   562: 
   563: const safeJsonParse = (s) => {
   564:   try {
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 

===== HIT @ line 586 (showing 546..666) =====
   546:     const capsKey = (host) => `host_caps:${host}`;
   547:     const intentKey = (host, tag) => `intent:${host}:${tag}`;
   548: // ----------------------------
   549: // Memory Substrate v1 (storage-backed; no model memory)
   550: // ----------------------------
   551: const REGISTRY_VERSION = "v1";
   552: 
   553: const registryKey = (type, id) => `reg:${REGISTRY_VERSION}:${type}:${id}`;
   554: const registryIndexKey = (type) => `reg:${REGISTRY_VERSION}:index:${type}`;
   555: const registryMetaKey = (type) => `reg:${REGISTRY_VERSION}:meta:${type}`;
   556: 
   557: const auditSeqKey = `audit:${REGISTRY_VERSION}:seq`;
   558: const auditEventKey = (seq) => `audit:${REGISTRY_VERSION}:event:${seq}`;
   559: const auditClearedAtKey = `audit:${REGISTRY_VERSION}:cleared_at`;
   560: 
   561: const nowIso = () => new Date().toISOString();
   562: 
   563: const safeJsonParse = (s) => {
   564:   try {
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 

===== HIT @ line 603 (showing 563..683) =====
   563: const safeJsonParse = (s) => {
   564:   try {
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];

===== HIT @ line 605 (showing 565..685) =====
   565:     return JSON.parse(s);
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {

===== HIT @ line 606 (showing 566..686) =====
   566:   } catch {
   567:     return null;
   568:   }
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));

===== HIT @ line 609 (showing 569..689) =====
   569: };
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);

===== HIT @ line 610 (showing 570..690) =====
   570: 
   571: /**
   572:  * Parse JSON arguments for commands in batch payloads.
   573:  * Supports:
   574:  *  - TOKEN <json>
   575:  *  - TOKEN <type> <json>               (legacy, e.g. REGISTRY_PUT domains {...})
   576:  *  - TOKEN                              then JSON on subsequent non-command lines
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }

===== HIT @ line 617 (showing 577..697) =====
   577:  */
   578: function __isCommandLine(line, allowedCommands) {
   579:   if (!line) return false;
   580:   const tok = String(line).trim().split(/\s+/)[0] || "";
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;

===== HIT @ line 621 (showing 581..701) =====
   581:   if (!tok) return false;
   582:   if (tok === "HOST") return true;
   583:   return allowedCommands && Array.isArray(allowedCommands) && allowedCommands.includes(tok);
   584: }
   585: 
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {

===== HIT @ line 626 (showing 586..706) =====
   586: function __collectJsonText(token, line, lines, idx, allowedCommands) {
   587:   const tail = String(line || "").slice(token.length).trim();
   588:   if (tail) return { text: tail, nextIndex: idx };
   589: 
   590:   // Collect subsequent lines until the next command token (or HOST) appears.
   591:   const buf = [];
   592:   let j = idx + 1;
   593:   for (; j < (lines || []).length; j++) {
   594:     const ln = String(lines[j] || "").trim();
   595:     if (!ln) continue;
   596:     if (__isCommandLine(ln, allowedCommands)) break;
   597:     buf.push(ln);
   598:   }
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })

===== HIT @ line 639 (showing 599..719) =====
   599:   const joined = buf.join("\n").trim();
   600:   return { text: joined, nextIndex: j - 1 };
   601: }
   602: 
   603: function __parseRegistryPutArgs(line, lines, idx, allowedCommands) {
   604:   // Returns { type, item, nextIndex } or null
   605:   const token = "REGISTRY_PUT";
   606:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   607:   if (!text) return null;
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,

===== HIT @ line 648 (showing 608..728) =====
   608: 
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {

===== HIT @ line 649 (showing 609..729) =====
   609:   // 1) JSON envelope: {"type":"domains","item":{...}}
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);

===== HIT @ line 650 (showing 610..730) =====
   610:   const direct = safeJsonParse(text);
   611:   if (direct && typeof direct === "object") {
   612:     if (direct.type && direct.item) {
   613:       return { type: String(direct.type).toLowerCase(), item: direct.item, nextIndex };
   614:     }
   615:   }
   616: 
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);

===== HIT @ line 657 (showing 617..737) =====
   617:   // 2) Legacy: "<type> <json>"
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 

===== HIT @ line 658 (showing 618..738) =====
   618:   const m = text.match(/^(\S+)\s+([\s\S]+)$/);
   619:   if (!m) return null;
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });

===== HIT @ line 660 (showing 620..740) =====
   620:   const type = String(m[1] || "").toLowerCase().trim();
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };

===== HIT @ line 661 (showing 621..741) =====
   621:   const item = safeJsonParse(String(m[2] || "").trim());
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 

===== HIT @ line 662 (showing 622..742) =====
   622:   if (!type || !item || typeof item !== "object") return null;
   623:   return { type, item, nextIndex };
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {

===== HIT @ line 664 (showing 624..744) =====
   624: }
   625: 
   626: function __parseRegistryGetArgs(line, lines, idx, allowedCommands) {
   627:   // Supports:
   628:   //  - REGISTRY_GET <type> <id>
   629:   //  - REGISTRY_GET <type> {"key":"id"}  (legacy shape)
   630:   //  - REGISTRY_GET <type>               then {"key":"id"} on next lines
   631:   const parts = String(line || "").trim().split(/\s+/).filter(Boolean);
   632:   const type = String(parts[1] || "").toLowerCase().trim();
   633:   if (!type) return null;
   634: 
   635:   if (parts.length >= 3) {
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);

===== HIT @ line 676 (showing 636..756) =====
   636:     const rest = String(parts.slice(2).join(" ")).trim();
   637:     if (!rest) return null;
   638:     if (rest.startsWith("{") || rest.startsWith("[")) {
   639:       const obj = safeJsonParse(rest);
   640:       const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   641:       const id = String(key || "").trim();
   642:       if (!id) return null;
   643:       return { type, id, nextIndex: idx };
   644:     }
   645:     return { type, id: String(rest).trim(), nextIndex: idx };
   646:   }
   647: 
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }

===== HIT @ line 688 (showing 648..768) =====
   648:   // No id on the same line  collect JSON below
   649:   const { text, nextIndex } = __collectJsonText("REGISTRY_GET", line, lines, idx, allowedCommands);
   650:   const obj = safeJsonParse(text);
   651:   const key = obj && typeof obj === "object" ? (obj.key || obj.id || obj.domain) : null;
   652:   const id = String(key || "").trim();
   653:   if (!id) return null;
   654:   return { type, id, nextIndex };
   655: }
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];

===== HIT @ line 696 (showing 656..776) =====
   656: 
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };

===== HIT @ line 697 (showing 657..777) =====
   657: function __parseRegistryImportArgs(token, line, lines, idx, allowedCommands) {
   658:   const { text, nextIndex } = __collectJsonText(token, line, lines, idx, allowedCommands);
   659:   if (!text) return null;
   660:   const parsed = safeJsonParse(text);
   661:   if (!parsed) return null;
   662:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };

===== HIT @ line 703 (showing 663..783) =====
   663:   if (!items) return null;
   664:   return { parsed, items, nextIndex };
   665: }
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);

===== HIT @ line 706 (showing 666..786) =====
   666: 
   667: 
   668: const auditWrite = async (env, event) => {
   669:   const ts = nowIso();
   670:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   671:   const seq = Number(seqRaw || 0) + 1;
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);
   784:   for (const id of ids) {
   785:     const e = await registryGet(env, type, id);
   786:     if (!e || typeof e !== "object") continue;

===== HIT @ line 712 (showing 672..792) =====
   672:   await env.AURA_KV.put(auditSeqKey, String(seq));
   673: 
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);
   784:   for (const id of ids) {
   785:     const e = await registryGet(env, type, id);
   786:     if (!e || typeof e !== "object") continue;
   787: 
   788:     let ok = true;
   789:     for (const k of keys) {
   790:       const expected = where[k];
   791:       const actual = e[k];
   792: 

===== HIT @ line 714 (showing 674..794) =====
   674:   const payload = { seq, ts, ...event };
   675: 
   676:   await env.AURA_KV.put(auditEventKey(seq), JSON.stringify(payload));
   677:   return payload;
   678: };
   679: 
   680: const auditList = async (env, limit = 50) => {
   681:   const seqRaw = await env.AURA_KV.get(auditSeqKey);
   682:   const seq = Number(seqRaw || 0);
   683:   const out = [];
   684:   const start = Math.max(1, seq - limit + 1);
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);
   784:   for (const id of ids) {
   785:     const e = await registryGet(env, type, id);
   786:     if (!e || typeof e !== "object") continue;
   787: 
   788:     let ok = true;
   789:     for (const k of keys) {
   790:       const expected = where[k];
   791:       const actual = e[k];
   792: 
   793:       if (expected == null) continue;
   794: 

===== HIT @ line 725 (showing 685..805) =====
   685:   for (let i = start; i <= seq; i++) {
   686:     const s = await env.AURA_KV.get(auditEventKey(i));
   687:     if (!s) continue;
   688:     const p = safeJsonParse(s) || s;
   689:     out.push(p);
   690:   }
   691:   return { seq, events: out };
   692: };
   693: 
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);
   784:   for (const id of ids) {
   785:     const e = await registryGet(env, type, id);
   786:     if (!e || typeof e !== "object") continue;
   787: 
   788:     let ok = true;
   789:     for (const k of keys) {
   790:       const expected = where[k];
   791:       const actual = e[k];
   792: 
   793:       if (expected == null) continue;
   794: 
   795:       // expected can be string/number/bool OR array of allowed values
   796:       const allowed = Array.isArray(expected) ? expected : [expected];
   797: 
   798:       const match =
   799:         (typeof actual === "string" &&
   800:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   801:         (typeof actual === "number" &&
   802:           allowed.map((x) => Number(x)).includes(Number(actual))) ||
   803:         (typeof actual === "boolean" &&
   804:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   805:         (Array.isArray(actual) &&

===== HIT @ line 734 (showing 694..814) =====
   694: const registryGetIndex = async (env, type) => {
   695:   const raw = await env.AURA_KV.get(registryIndexKey(type));
   696:   const parsed = raw ? safeJsonParse(raw) : null;
   697:   if (Array.isArray(parsed)) return parsed;
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);
   784:   for (const id of ids) {
   785:     const e = await registryGet(env, type, id);
   786:     if (!e || typeof e !== "object") continue;
   787: 
   788:     let ok = true;
   789:     for (const k of keys) {
   790:       const expected = where[k];
   791:       const actual = e[k];
   792: 
   793:       if (expected == null) continue;
   794: 
   795:       // expected can be string/number/bool OR array of allowed values
   796:       const allowed = Array.isArray(expected) ? expected : [expected];
   797: 
   798:       const match =
   799:         (typeof actual === "string" &&
   800:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   801:         (typeof actual === "number" &&
   802:           allowed.map((x) => Number(x)).includes(Number(actual))) ||
   803:         (typeof actual === "boolean" &&
   804:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   805:         (Array.isArray(actual) &&
   806:           actual.map((x) => String(x).toLowerCase()).some((v) =>
   807:             allowed.map((a) => String(a).toLowerCase()).includes(v)
   808:           ));
   809: 
   810:       if (!match) { ok = false; break; }
   811:     }
   812: 
   813:     if (ok) out.push(e);
   814:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;

===== HIT @ line 738 (showing 698..818) =====
   698:   return [];
   699: };
   700: 
   701: const registryPutIndex = async (env, type, ids) => {
   702:   const clean = [...new Set((ids || []).filter((x) => typeof x === "string" && x.trim()))];
   703:   await env.AURA_KV.put(registryIndexKey(type), JSON.stringify(clean));
   704:   await env.AURA_KV.put(
   705:     registryMetaKey(type),
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);
   784:   for (const id of ids) {
   785:     const e = await registryGet(env, type, id);
   786:     if (!e || typeof e !== "object") continue;
   787: 
   788:     let ok = true;
   789:     for (const k of keys) {
   790:       const expected = where[k];
   791:       const actual = e[k];
   792: 
   793:       if (expected == null) continue;
   794: 
   795:       // expected can be string/number/bool OR array of allowed values
   796:       const allowed = Array.isArray(expected) ? expected : [expected];
   797: 
   798:       const match =
   799:         (typeof actual === "string" &&
   800:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   801:         (typeof actual === "number" &&
   802:           allowed.map((x) => Number(x)).includes(Number(actual))) ||
   803:         (typeof actual === "boolean" &&
   804:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   805:         (Array.isArray(actual) &&
   806:           actual.map((x) => String(x).toLowerCase()).some((v) =>
   807:             allowed.map((a) => String(a).toLowerCase()).includes(v)
   808:           ));
   809: 
   810:       if (!match) { ok = false; break; }
   811:     }
   812: 
   813:     if (ok) out.push(e);
   814:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   815:   }
   816:   return { type, where, returned: out.length, items: out };
   817: };
   818: 

===== HIT @ line 746 (showing 706..826) =====
   706:     JSON.stringify({ type, count: clean.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   707:   );
   708:   return clean.length;
   709: };
   710: 
   711: const registryPut = async (env, type, obj) => {
   712:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST" };
   713:   const id = String(obj.id || "").trim();
   714:   if (!id) return { ok: false, error: "BAD_REQUEST" };
   715: 
   716:   const key = registryKey(type, id);
   717:   const stored = {
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);
   784:   for (const id of ids) {
   785:     const e = await registryGet(env, type, id);
   786:     if (!e || typeof e !== "object") continue;
   787: 
   788:     let ok = true;
   789:     for (const k of keys) {
   790:       const expected = where[k];
   791:       const actual = e[k];
   792: 
   793:       if (expected == null) continue;
   794: 
   795:       // expected can be string/number/bool OR array of allowed values
   796:       const allowed = Array.isArray(expected) ? expected : [expected];
   797: 
   798:       const match =
   799:         (typeof actual === "string" &&
   800:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   801:         (typeof actual === "number" &&
   802:           allowed.map((x) => Number(x)).includes(Number(actual))) ||
   803:         (typeof actual === "boolean" &&
   804:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   805:         (Array.isArray(actual) &&
   806:           actual.map((x) => String(x).toLowerCase()).some((v) =>
   807:             allowed.map((a) => String(a).toLowerCase()).includes(v)
   808:           ));
   809: 
   810:       if (!match) { ok = false; break; }
   811:     }
   812: 
   813:     if (ok) out.push(e);
   814:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   815:   }
   816:   return { type, where, returned: out.length, items: out };
   817: };
   818: 
   819: const memorySchemaV1 = {
   820:   version: REGISTRY_VERSION,
   821:   registries: {
   822:     assets: {
   823:       id: "string (recommended: stable slug or numeric string)",
   824:       name: "string",
   825:       pillar: "string",
   826:       notes: "string (optional)",

===== HIT @ line 758 (showing 718..838) =====
   718:     ...obj,
   719:     id,
   720:     type,
   721:     updated_at: nowIso(),
   722:     version: REGISTRY_VERSION
   723:   };
   724: 
   725:   await env.AURA_KV.put(key, JSON.stringify(stored));
   726: 
   727:   const ids = await registryGetIndex(env, type);
   728:   if (!ids.includes(id)) {
   729:     ids.push(id);
   730:     await registryPutIndex(env, type, ids);
   731:   } else {
   732:     await env.AURA_KV.put(
   733:       registryMetaKey(type),
   734:       JSON.stringify({ type, count: ids.length, updated_at: nowIso(), version: REGISTRY_VERSION })
   735:     );
   736:   }
   737: 
   738:   await auditWrite(env, { action: "REGISTRY_PUT", type, id });
   739:   return { ok: true, entry: stored };
   740: };
   741: 
   742: const registryGet = async (env, type, id) => {
   743:   const key = registryKey(type, id);
   744:   const raw = await env.AURA_KV.get(key);
   745:   if (!raw) return null;
   746:   return safeJsonParse(raw) || raw;
   747: };
   748: 
   749: const registryList = async (env, type, limit = 50) => {
   750:   const ids = await registryGetIndex(env, type);
   751:   const slice = ids.slice(0, Math.max(0, Math.min(limit, 500)));
   752:   const items = [];
   753:   for (const id of slice) {
   754:     const e = await registryGet(env, type, id);
   755:     if (e) items.push(e);
   756:   }
   757:   const metaRaw = await env.AURA_KV.get(registryMetaKey(type));
   758:   const meta = metaRaw ? (safeJsonParse(metaRaw) || metaRaw) : null;
   759:   return { type, meta, ids_count: ids.length, returned: items.length, items };
   760: };
   761: 
   762: const registryFilter = async (env, type, field, value, limit = 50) => {
   763:   const ids = await registryGetIndex(env, type);
   764:   const out = [];
   765:   for (const id of ids) {
   766:     const e = await registryGet(env, type, id);
   767:     if (!e || typeof e !== "object") continue;
   768:     const v = e[field];
   769:     const match =
   770:       (typeof v === "string" && String(v).toLowerCase() === String(value).toLowerCase()) ||
   771:       (Array.isArray(v) &&
   772:         v.map((x) => String(x).toLowerCase()).includes(String(value).toLowerCase()));
   773:     if (match) out.push(e);
   774:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   775:   }
   776:   return { type, field, value, returned: out.length, items: out };
   777: };
   778: 
   779: 
   780: const registryFilterWhere = async (env, type, where = {}, limit = 50) => {
   781:   const ids = await registryGetIndex(env, type);
   782:   const out = [];
   783:   const keys = Object.keys(where || {}).filter(Boolean);
   784:   for (const id of ids) {
   785:     const e = await registryGet(env, type, id);
   786:     if (!e || typeof e !== "object") continue;
   787: 
   788:     let ok = true;
   789:     for (const k of keys) {
   790:       const expected = where[k];
   791:       const actual = e[k];
   792: 
   793:       if (expected == null) continue;
   794: 
   795:       // expected can be string/number/bool OR array of allowed values
   796:       const allowed = Array.isArray(expected) ? expected : [expected];
   797: 
   798:       const match =
   799:         (typeof actual === "string" &&
   800:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   801:         (typeof actual === "number" &&
   802:           allowed.map((x) => Number(x)).includes(Number(actual))) ||
   803:         (typeof actual === "boolean" &&
   804:           allowed.map((x) => String(x).toLowerCase()).includes(String(actual).toLowerCase())) ||
   805:         (Array.isArray(actual) &&
   806:           actual.map((x) => String(x).toLowerCase()).some((v) =>
   807:             allowed.map((a) => String(a).toLowerCase()).includes(v)
   808:           ));
   809: 
   810:       if (!match) { ok = false; break; }
   811:     }
   812: 
   813:     if (ok) out.push(e);
   814:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   815:   }
   816:   return { type, where, returned: out.length, items: out };
   817: };
   818: 
   819: const memorySchemaV1 = {
   820:   version: REGISTRY_VERSION,
   821:   registries: {
   822:     assets: {
   823:       id: "string (recommended: stable slug or numeric string)",
   824:       name: "string",
   825:       pillar: "string",
   826:       notes: "string (optional)",
   827:       tags: "string[] (optional)",
   828:       sellability: "NEVER_SELL | SELLABLE | HOLD | UNKNOWN (optional)",
   829:       patent_cluster: "string (optional)",
   830:       created_at: "iso string (optional)",
   831:       updated_at: "iso string (system)",
   832:       audit: "KV audit events (system)"
   833:     },
   834:     domains: {
   835:       id: "string (domain itself, lowercased)",
   836:       domain: "string",
   837:       pillar: "string",
   838:       purpose: "string (optional)",

===== HIT @ line 853 (showing 813..933) =====
   813:     if (ok) out.push(e);
   814:     if (out.length >= Math.max(1, Math.min(limit, 200))) break;
   815:   }
   816:   return { type, where, returned: out.length, items: out };
   817: };
   818: 
   819: const memorySchemaV1 = {
   820:   version: REGISTRY_VERSION,
   821:   registries: {
   822:     assets: {
   823:       id: "string (recommended: stable slug or numeric string)",
   824:       name: "string",
   825:       pillar: "string",
   826:       notes: "string (optional)",
   827:       tags: "string[] (optional)",
   828:       sellability: "NEVER_SELL | SELLABLE | HOLD | UNKNOWN (optional)",
   829:       patent_cluster: "string (optional)",
   830:       created_at: "iso string (optional)",
   831:       updated_at: "iso string (system)",
   832:       audit: "KV audit events (system)"
   833:     },
   834:     domains: {
   835:       id: "string (domain itself, lowercased)",
   836:       domain: "string",
   837:       pillar: "string",
   838:       purpose: "string (optional)",
   839:       priority: "PHASE1 | PHASE2 | HOLD | UNKNOWN (optional)",
   840:       status: "UNKNOWN | ACTIVE | PARKED | REDIRECT | BROKEN (optional)",
   841:       updated_at: "iso string (system)",
   842:       audit: "KV audit events (system)"
   843:     },
   844:     users: {
   845:       id: "string",
   846:       prefs: "object",
   847:       intents: "object[]",
   848:       updated_at: "iso string"
   849:     }
   850:   }
   851: };
   852: 
   853:     const jsonReply = (reply) => Response.json({ ok: true, reply });
   854: 
   855: // ----------------------------
   856: // Deployer Autonomy Surface (operator-gated; host-capped)
   857: // - Exposes ONLY a minimal proxy surface to service bindings.
   858: // - Does NOT claim success for external effects; callers must verify via VERIFIED_FETCH_URL.
   859: // Commands:
   860: //   DEPLOYER_CAPS
   861: //   DEPLOYER_CALL <json>
   862: // JSON shape for DEPLOYER_CALL:
   863: //   {"service":"AURA_DEPLOYER"|"AURA_CF","path":"/admin|/dns|/deploy|...","method":"POST|GET","content_type":"application/json","body":"...raw..."} 
   864: // ----------------------------
   865: const __hasService = (env, name) => {
   866:   try { return Boolean(env && env[name] && typeof env[name].fetch === "function"); } catch { return false; }
   867: };
   868: 
   869: 
   870: const __withOperatorHeaders = (headers, isOperator, operatorHeader, deployKey) => {
   871:   const out = { ...(headers || {}) };
   872:   if (isOperator && operatorHeader) {
   873:     out["x-operator-token"] = operatorHeader;
   874:     out["authorization"] = `Bearer ${operatorHeader}`;
   875:   }
   876:   if (deployKey) {
   877:     out["X-Deploy-Key"] = deployKey;
   878:   }
   879:   return out;
   880: };
   881: 
   882: const __serviceFetch = async (svc, req) => {
   883:   const url = new URL(req.path, "https://internal");
   884: 
   885:   const method = String(req.method || "GET").toUpperCase();
   886:   const headers = {
   887:     ...(req.headers || {}),
   888:     ...(req.content_type ? { "content-type": req.content_type } : {})
   889:   };
   890: 
   891:   const init = { method, headers };
   892:   // IMPORTANT: Fetch forbids bodies on GET/HEAD. Ignore any provided body for those methods.
   893:   if (method !== "GET" && method !== "HEAD") {
   894:     if (req.body != null && req.body !== "") init.body = req.body;
   895:   }
   896: 
   897:   const r = await svc.fetch(new Request(url.toString(), init));
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {

===== HIT @ line 861 (showing 821..941) =====
   821:   registries: {
   822:     assets: {
   823:       id: "string (recommended: stable slug or numeric string)",
   824:       name: "string",
   825:       pillar: "string",
   826:       notes: "string (optional)",
   827:       tags: "string[] (optional)",
   828:       sellability: "NEVER_SELL | SELLABLE | HOLD | UNKNOWN (optional)",
   829:       patent_cluster: "string (optional)",
   830:       created_at: "iso string (optional)",
   831:       updated_at: "iso string (system)",
   832:       audit: "KV audit events (system)"
   833:     },
   834:     domains: {
   835:       id: "string (domain itself, lowercased)",
   836:       domain: "string",
   837:       pillar: "string",
   838:       purpose: "string (optional)",
   839:       priority: "PHASE1 | PHASE2 | HOLD | UNKNOWN (optional)",
   840:       status: "UNKNOWN | ACTIVE | PARKED | REDIRECT | BROKEN (optional)",
   841:       updated_at: "iso string (system)",
   842:       audit: "KV audit events (system)"
   843:     },
   844:     users: {
   845:       id: "string",
   846:       prefs: "object",
   847:       intents: "object[]",
   848:       updated_at: "iso string"
   849:     }
   850:   }
   851: };
   852: 
   853:     const jsonReply = (reply) => Response.json({ ok: true, reply });
   854: 
   855: // ----------------------------
   856: // Deployer Autonomy Surface (operator-gated; host-capped)
   857: // - Exposes ONLY a minimal proxy surface to service bindings.
   858: // - Does NOT claim success for external effects; callers must verify via VERIFIED_FETCH_URL.
   859: // Commands:
   860: //   DEPLOYER_CAPS
   861: //   DEPLOYER_CALL <json>
   862: // JSON shape for DEPLOYER_CALL:
   863: //   {"service":"AURA_DEPLOYER"|"AURA_CF","path":"/admin|/dns|/deploy|...","method":"POST|GET","content_type":"application/json","body":"...raw..."} 
   864: // ----------------------------
   865: const __hasService = (env, name) => {
   866:   try { return Boolean(env && env[name] && typeof env[name].fetch === "function"); } catch { return false; }
   867: };
   868: 
   869: 
   870: const __withOperatorHeaders = (headers, isOperator, operatorHeader, deployKey) => {
   871:   const out = { ...(headers || {}) };
   872:   if (isOperator && operatorHeader) {
   873:     out["x-operator-token"] = operatorHeader;
   874:     out["authorization"] = `Bearer ${operatorHeader}`;
   875:   }
   876:   if (deployKey) {
   877:     out["X-Deploy-Key"] = deployKey;
   878:   }
   879:   return out;
   880: };
   881: 
   882: const __serviceFetch = async (svc, req) => {
   883:   const url = new URL(req.path, "https://internal");
   884: 
   885:   const method = String(req.method || "GET").toUpperCase();
   886:   const headers = {
   887:     ...(req.headers || {}),
   888:     ...(req.content_type ? { "content-type": req.content_type } : {})
   889:   };
   890: 
   891:   const init = { method, headers };
   892:   // IMPORTANT: Fetch forbids bodies on GET/HEAD. Ignore any provided body for those methods.
   893:   if (method !== "GET" && method !== "HEAD") {
   894:     if (req.body != null && req.body !== "") init.body = req.body;
   895:   }
   896: 
   897:   const r = await svc.fetch(new Request(url.toString(), init));
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }

===== HIT @ line 862 (showing 822..942) =====
   822:     assets: {
   823:       id: "string (recommended: stable slug or numeric string)",
   824:       name: "string",
   825:       pillar: "string",
   826:       notes: "string (optional)",
   827:       tags: "string[] (optional)",
   828:       sellability: "NEVER_SELL | SELLABLE | HOLD | UNKNOWN (optional)",
   829:       patent_cluster: "string (optional)",
   830:       created_at: "iso string (optional)",
   831:       updated_at: "iso string (system)",
   832:       audit: "KV audit events (system)"
   833:     },
   834:     domains: {
   835:       id: "string (domain itself, lowercased)",
   836:       domain: "string",
   837:       pillar: "string",
   838:       purpose: "string (optional)",
   839:       priority: "PHASE1 | PHASE2 | HOLD | UNKNOWN (optional)",
   840:       status: "UNKNOWN | ACTIVE | PARKED | REDIRECT | BROKEN (optional)",
   841:       updated_at: "iso string (system)",
   842:       audit: "KV audit events (system)"
   843:     },
   844:     users: {
   845:       id: "string",
   846:       prefs: "object",
   847:       intents: "object[]",
   848:       updated_at: "iso string"
   849:     }
   850:   }
   851: };
   852: 
   853:     const jsonReply = (reply) => Response.json({ ok: true, reply });
   854: 
   855: // ----------------------------
   856: // Deployer Autonomy Surface (operator-gated; host-capped)
   857: // - Exposes ONLY a minimal proxy surface to service bindings.
   858: // - Does NOT claim success for external effects; callers must verify via VERIFIED_FETCH_URL.
   859: // Commands:
   860: //   DEPLOYER_CAPS
   861: //   DEPLOYER_CALL <json>
   862: // JSON shape for DEPLOYER_CALL:
   863: //   {"service":"AURA_DEPLOYER"|"AURA_CF","path":"/admin|/dns|/deploy|...","method":"POST|GET","content_type":"application/json","body":"...raw..."} 
   864: // ----------------------------
   865: const __hasService = (env, name) => {
   866:   try { return Boolean(env && env[name] && typeof env[name].fetch === "function"); } catch { return false; }
   867: };
   868: 
   869: 
   870: const __withOperatorHeaders = (headers, isOperator, operatorHeader, deployKey) => {
   871:   const out = { ...(headers || {}) };
   872:   if (isOperator && operatorHeader) {
   873:     out["x-operator-token"] = operatorHeader;
   874:     out["authorization"] = `Bearer ${operatorHeader}`;
   875:   }
   876:   if (deployKey) {
   877:     out["X-Deploy-Key"] = deployKey;
   878:   }
   879:   return out;
   880: };
   881: 
   882: const __serviceFetch = async (svc, req) => {
   883:   const url = new URL(req.path, "https://internal");
   884: 
   885:   const method = String(req.method || "GET").toUpperCase();
   886:   const headers = {
   887:     ...(req.headers || {}),
   888:     ...(req.content_type ? { "content-type": req.content_type } : {})
   889:   };
   890: 
   891:   const init = { method, headers };
   892:   // IMPORTANT: Fetch forbids bodies on GET/HEAD. Ignore any provided body for those methods.
   893:   if (method !== "GET" && method !== "HEAD") {
   894:     if (req.body != null && req.body !== "") init.body = req.body;
   895:   }
   896: 
   897:   const r = await svc.fetch(new Request(url.toString(), init));
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 

===== HIT @ line 863 (showing 823..943) =====
   823:       id: "string (recommended: stable slug or numeric string)",
   824:       name: "string",
   825:       pillar: "string",
   826:       notes: "string (optional)",
   827:       tags: "string[] (optional)",
   828:       sellability: "NEVER_SELL | SELLABLE | HOLD | UNKNOWN (optional)",
   829:       patent_cluster: "string (optional)",
   830:       created_at: "iso string (optional)",
   831:       updated_at: "iso string (system)",
   832:       audit: "KV audit events (system)"
   833:     },
   834:     domains: {
   835:       id: "string (domain itself, lowercased)",
   836:       domain: "string",
   837:       pillar: "string",
   838:       purpose: "string (optional)",
   839:       priority: "PHASE1 | PHASE2 | HOLD | UNKNOWN (optional)",
   840:       status: "UNKNOWN | ACTIVE | PARKED | REDIRECT | BROKEN (optional)",
   841:       updated_at: "iso string (system)",
   842:       audit: "KV audit events (system)"
   843:     },
   844:     users: {
   845:       id: "string",
   846:       prefs: "object",
   847:       intents: "object[]",
   848:       updated_at: "iso string"
   849:     }
   850:   }
   851: };
   852: 
   853:     const jsonReply = (reply) => Response.json({ ok: true, reply });
   854: 
   855: // ----------------------------
   856: // Deployer Autonomy Surface (operator-gated; host-capped)
   857: // - Exposes ONLY a minimal proxy surface to service bindings.
   858: // - Does NOT claim success for external effects; callers must verify via VERIFIED_FETCH_URL.
   859: // Commands:
   860: //   DEPLOYER_CAPS
   861: //   DEPLOYER_CALL <json>
   862: // JSON shape for DEPLOYER_CALL:
   863: //   {"service":"AURA_DEPLOYER"|"AURA_CF","path":"/admin|/dns|/deploy|...","method":"POST|GET","content_type":"application/json","body":"...raw..."} 
   864: // ----------------------------
   865: const __hasService = (env, name) => {
   866:   try { return Boolean(env && env[name] && typeof env[name].fetch === "function"); } catch { return false; }
   867: };
   868: 
   869: 
   870: const __withOperatorHeaders = (headers, isOperator, operatorHeader, deployKey) => {
   871:   const out = { ...(headers || {}) };
   872:   if (isOperator && operatorHeader) {
   873:     out["x-operator-token"] = operatorHeader;
   874:     out["authorization"] = `Bearer ${operatorHeader}`;
   875:   }
   876:   if (deployKey) {
   877:     out["X-Deploy-Key"] = deployKey;
   878:   }
   879:   return out;
   880: };
   881: 
   882: const __serviceFetch = async (svc, req) => {
   883:   const url = new URL(req.path, "https://internal");
   884: 
   885:   const method = String(req.method || "GET").toUpperCase();
   886:   const headers = {
   887:     ...(req.headers || {}),
   888:     ...(req.content_type ? { "content-type": req.content_type } : {})
   889:   };
   890: 
   891:   const init = { method, headers };
   892:   // IMPORTANT: Fetch forbids bodies on GET/HEAD. Ignore any provided body for those methods.
   893:   if (method !== "GET" && method !== "HEAD") {
   894:     if (req.body != null && req.body !== "") init.body = req.body;
   895:   }
   896: 
   897:   const r = await svc.fetch(new Request(url.toString(), init));
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {

===== HIT @ line 900 (showing 860..980) =====
   860: //   DEPLOYER_CAPS
   861: //   DEPLOYER_CALL <json>
   862: // JSON shape for DEPLOYER_CALL:
   863: //   {"service":"AURA_DEPLOYER"|"AURA_CF","path":"/admin|/dns|/deploy|...","method":"POST|GET","content_type":"application/json","body":"...raw..."} 
   864: // ----------------------------
   865: const __hasService = (env, name) => {
   866:   try { return Boolean(env && env[name] && typeof env[name].fetch === "function"); } catch { return false; }
   867: };
   868: 
   869: 
   870: const __withOperatorHeaders = (headers, isOperator, operatorHeader, deployKey) => {
   871:   const out = { ...(headers || {}) };
   872:   if (isOperator && operatorHeader) {
   873:     out["x-operator-token"] = operatorHeader;
   874:     out["authorization"] = `Bearer ${operatorHeader}`;
   875:   }
   876:   if (deployKey) {
   877:     out["X-Deploy-Key"] = deployKey;
   878:   }
   879:   return out;
   880: };
   881: 
   882: const __serviceFetch = async (svc, req) => {
   883:   const url = new URL(req.path, "https://internal");
   884: 
   885:   const method = String(req.method || "GET").toUpperCase();
   886:   const headers = {
   887:     ...(req.headers || {}),
   888:     ...(req.content_type ? { "content-type": req.content_type } : {})
   889:   };
   890: 
   891:   const init = { method, headers };
   892:   // IMPORTANT: Fetch forbids bodies on GET/HEAD. Ignore any provided body for those methods.
   893:   if (method !== "GET" && method !== "HEAD") {
   894:     if (req.body != null && req.body !== "") init.body = req.body;
   895:   }
   896: 
   897:   const r = await svc.fetch(new Request(url.toString(), init));
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));

===== HIT @ line 925 (showing 885..1005) =====
   885:   const method = String(req.method || "GET").toUpperCase();
   886:   const headers = {
   887:     ...(req.headers || {}),
   888:     ...(req.content_type ? { "content-type": req.content_type } : {})
   889:   };
   890: 
   891:   const init = { method, headers };
   892:   // IMPORTANT: Fetch forbids bodies on GET/HEAD. Ignore any provided body for those methods.
   893:   if (method !== "GET" && method !== "HEAD") {
   894:     if (req.body != null && req.body !== "") init.body = req.body;
   895:   }
   896: 
   897:   const r = await svc.fetch(new Request(url.toString(), init));
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }

===== HIT @ line 931 (showing 891..1011) =====
   891:   const init = { method, headers };
   892:   // IMPORTANT: Fetch forbids bodies on GET/HEAD. Ignore any provided body for those methods.
   893:   if (method !== "GET" && method !== "HEAD") {
   894:     if (req.body != null && req.body !== "") init.body = req.body;
   895:   }
   896: 
   897:   const r = await svc.fetch(new Request(url.toString(), init));
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 

===== HIT @ line 934 (showing 894..1014) =====
   894:     if (req.body != null && req.body !== "") init.body = req.body;
   895:   }
   896: 
   897:   const r = await svc.fetch(new Request(url.toString(), init));
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));

===== HIT @ line 938 (showing 898..1018) =====
   898:   const ct = (r.headers.get("content-type") || "").toLowerCase();
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");

===== HIT @ line 939 (showing 899..1019) =====
   899:   let out;
   900:   if (ct.includes("application/json")) out = await r.json();
   901:   else out = await r.text();
   902:   return { http_status: r.status, content_type: ct || null, out };
   903: };
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }

===== HIT @ line 944 (showing 904..1024) =====
   904: 
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body

===== HIT @ line 945 (showing 905..1025) =====
   905: const __deployerCaps = (env) => {
   906:   const hasDeployer = __hasService(env, "AURA_DEPLOYER");
   907:   const hasCf = __hasService(env, "AURA_CF");
   908:   return {
   909:     ok: hasDeployer || hasCf,
   910:     bindings: { AURA_DEPLOYER: hasDeployer, AURA_CF: hasCf },
   911:     surface: [
   912:       "DEPLOYER_CALL service=AURA_DEPLOYER path/method/body (operator-only)",
   913:       "DEPLOYER_CALL service=AURA_CF path/method/body (operator-only)"
   914:     ],
   915:     requirement: "Caller must verify externally via VERIFIED_FETCH_URL; no implicit 'success' claims."
   916:   };
   917: };
   918: 
   919: 
   920: 
   921:     // ----------------------------
   922:     // Strict allowlist: unknown single-token command => UNKNOWN_COMMAND
   923:     // ----------------------------
   924:     if (/^[A-Z0-9_]+$/.test(bodyTrim) && !allowedCommands.includes(bodyTrim)) {
   925:       return jsonReply("UNKNOWN_COMMAND");
   926:     }
   927: 
   928:     // ----------------------------
   929:     // Simple commands
   930:     // ----------------------------
   931:     if (bodyTrim === "PING") return jsonReply("PONG");
   932: 
   933:     if (bodyTrim === "SHOW_ALLOWED_COMMANDS") {
   934:       return jsonReply(allowedCommands);
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")

===== HIT @ line 975 (showing 935..1055) =====
   935:     }
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;

===== HIT @ line 976 (showing 936..1056) =====
   936: 
   937:     if (bodyTrim === "SHOW_BUILD") {
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {

===== HIT @ line 978 (showing 938..1058) =====
   938:       return jsonReply(
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;

===== HIT @ line 979 (showing 939..1059) =====
   939:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;

===== HIT @ line 980 (showing 940..1060) =====
   940:       );
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {

===== HIT @ line 981 (showing 941..1061) =====
   941:     }
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;

===== HIT @ line 982 (showing 942..1062) =====
   942: 
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }

===== HIT @ line 983 (showing 943..1063) =====
   943:     if (bodyTrim === "SHOW_CLAIM_GATE") {
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };

===== HIT @ line 984 (showing 944..1064) =====
   944:       return jsonReply(
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 

===== HIT @ line 985 (showing 945..1065) =====
   945:         JSON.stringify(
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);

===== HIT @ line 986 (showing 946..1066) =====
   946:           {
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 

===== HIT @ line 987 (showing 947..1067) =====
   947:             trigger_words: [
   948:               "live",
   949:               "deployed",
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {

===== HIT @ line 990 (showing 950..1070) =====
   950:               "launched",
   951:               "resolving",
   952:               "propagating",
   953:               "successful",
   954:               "verified",
   955:               "up",
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };

===== HIT @ line 996 (showing 956..1076) =====
   956:               "online",
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>

===== HIT @ line 997 (showing 957..1077) =====
   957:               "working",
   958:               "reachable",
   959:               "available",
   960:               "accessible"
   961:             ],
   962:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
   963:             requires_verified_fetch_format: true
   964:           },
   965:           null,
   966:           2
   967:         )
   968:       );
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)

===== HIT @ line 1009 (showing 969..1089) =====
   969:     }
   970: 
   971: 
   972:     // ----------------------------
   973:     // AUTONOMY PRIMITIVES (single command; read-only stubs)
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 

===== HIT @ line 1014 (showing 974..1094) =====
   974:     // ----------------------------
   975:     if (bodyTrim === "AUTONOMY_STATUS") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   976:     if (bodyTrim === "AUTONOMY_LAST_TICK") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   977:     
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.

===== HIT @ line 1018 (showing 978..1098) =====
   978:     if (bodyTrim === "AUTONOMY_LAST_TICK_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   979: if (bodyTrim === "AUTONOMY_CAPABILITIES") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   980:     if (bodyTrim === "INTENT_SIMULATE") return jsonReply(JSON.stringify({ ok: true, note: "preview-only" }, null, 2));
   981:     if (bodyTrim === "REGISTRY_AUDIT_TRAIL") return jsonReply(JSON.stringify({ ok: true, note: "placeholder" }, null, 2));
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];

===== HIT @ line 1022 (showing 982..1102) =====
   982:     if (bodyTrim === "AUTONOMY_BUDGET_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   983:     if (bodyTrim === "AUTONOMY_BUDGET_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   984:     if (bodyTrim === "FAILURE_MEMORY_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   985:     if (bodyTrim === "FAILURE_MEMORY_PUT") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   986:     if (bodyTrim === "AUTONOMY_CHARTER_GET") return jsonReply(JSON.stringify({ ok: true }, null, 2));
   987:     if (bodyTrim === "AUTONOMY_CHARTER_SET") return jsonReply(JSON.stringify({ ok: true, note: "requires envelope" }, null, 2));
   988: 
   989: if (bodyTrim === "SHOW_MEMORY_SCHEMA") {
   990:   return jsonReply(JSON.stringify(memorySchemaV1, null, 2));
   991: }
   992: 
   993: if (bodyTrim === "PORTFOLIO_STATUS") {
   994:   const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
   995:   const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
   996:   const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
   997:   const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
   998: 
   999:   const status = {
  1000:     build: BUILD,
  1001:     stamp: nowIso(),
  1002:     registry_version: REGISTRY_VERSION,
  1003:     registries: {
  1004:       assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1005:       domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1006:     }
  1007:   };
  1008: 
  1009:   return jsonReply(JSON.stringify(status, null, 2));
  1010: }
  1011: 
  1012: if (bodyTrim === "AUDIT_GET") {
  1013:   const payload = await auditList(env, 50);
  1014:   return jsonReply(JSON.stringify(payload, null, 2));
  1015: }
  1016: 
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();

===== HIT @ line 1057 (showing 1017..1137) =====
  1017:     if (bodyTrim === "PAUSE") {
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }

===== HIT @ line 1058 (showing 1018..1138) =====
  1018:       return jsonReply("PAUSED");
  1019:     }
  1020: 
  1021:     // ----------------------------
  1022:     // Parse message lines (multi-line command batches)
  1023:     // ----------------------------
  1024:     const lines = body
  1025:       .split("\n")
  1026:       .map((l) => l.replace(/\r/g, "").replace(/^\s*>>\s?/, "").replace(/^\s*>\s?/, "").trim())
  1027:       .filter(Boolean);
  1028: 
  1029:     let didRegistryWrite = false;
  1030: 
  1031:     // ----------------------------
  1032:     // Host context for domain-scoped capability routing
  1033:     // ----------------------------
  1034:     let explicitHost = null;
  1035:     for (const line of lines) {
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 

===== HIT @ line 1076 (showing 1036..1156) =====
  1036:       if (line.startsWith("HOST ")) {
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 

===== HIT @ line 1077 (showing 1037..1157) =====
  1037:         const parts = line.split(" ").filter(Boolean);
  1038:         if (parts[1]) explicitHost = parts[1].toLowerCase();
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------

===== HIT @ line 1079 (showing 1039..1159) =====
  1039:       }
  1040:     }
  1041: 
  1042:     const askedUrl = extractLastUrl(body);
  1043:     const askedHostFromUrl = askedUrl ? normalizeHost(askedUrl) : null;
  1044: 
  1045:     // If no URL was provided, try to extract a bare domain mention from the message.
  1046:     const askedHostFromBare = askedHostFromUrl ? null : extractLastBareDomain(body);
  1047: 
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.

===== HIT @ line 1088 (showing 1048..1168) =====
  1048:     // Prefer explicit HOST context for "active host", but for questions we will prefer the asked host.
  1049:     const askedHost = askedHostFromUrl || askedHostFromBare || null;
  1050:     const activeHost = explicitHost || askedHost || null;
  1051: 
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);

===== HIT @ line 1092 (showing 1052..1172) =====
  1052:     const getHostCaps = async (host) => {
  1053:       if (!host) return null;
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);

===== HIT @ line 1094 (showing 1054..1174) =====
  1054:       const stored = await env.AURA_KV.get(capsKey(host));
  1055:       if (!stored) return null;
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };

===== HIT @ line 1096 (showing 1056..1176) =====
  1056:       try {
  1057:         const parsed = JSON.parse(stored);
  1058:         if (parsed && Array.isArray(parsed.allowed)) return parsed;
  1059:         return null;
  1060:       } catch {
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 

===== HIT @ line 1101 (showing 1061..1181) =====
  1061:         return null;
  1062:       }
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {

===== HIT @ line 1103 (showing 1063..1183) =====
  1063:     };
  1064: 
  1065:     const hostCaps = await getHostCaps(activeHost);
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,

===== HIT @ line 1106 (showing 1066..1186) =====
  1066: 
  1067:     const isAllowedForHost = (cmd) => {
  1068:       if (!hostCaps) return true;
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,

===== HIT @ line 1109 (showing 1069..1189) =====
  1069:       return hostCaps.allowed.includes(cmd);
  1070:     };
  1071: 
  1072:     // ----------------------------
  1073:     // Operator-only: HOST_CAPS_SET (supports multiple lines)
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,

===== HIT @ line 1114 (showing 1074..1194) =====
  1074:     //
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;

===== HIT @ line 1115 (showing 1075..1195) =====
  1075:     // Supported syntaxes:
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }

===== HIT @ line 1116 (showing 1076..1196) =====
  1076:     // 1) HOST_CAPS_SET <host> <json>
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 

===== HIT @ line 1117 (showing 1077..1197) =====
  1077:     // 2) HOST_CAPS_SET <json>                (host defaults to current HOST)
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {

===== HIT @ line 1118 (showing 1078..1198) =====
  1078:     //
  1079:     // <json> may be:
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);

===== HIT @ line 1120 (showing 1080..1200) =====
  1080:     // - an array of command strings: ["PING","SHOW_BUILD",...]
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {

===== HIT @ line 1121 (showing 1081..1201) =====
  1081:     // - an object with allow/allowed: {"allow":[...]} or {"allowed":[...]} (optionally {"host":"..."} )
  1082:     // ----------------------------
  1083:     let hostCapsSetCount = 0;
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);

===== HIT @ line 1124 (showing 1084..1204) =====
  1084: 
  1085:     for (const line of lines) {
  1086:       if (!line.startsWith("HOST_CAPS_SET")) continue;
  1087: 
  1088:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1089: 
  1090:       // Split once on whitespace after the command token.
  1091:       const rest = line.slice("HOST_CAPS_SET".length).trim();
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();

===== HIT @ line 1132 (showing 1092..1212) =====
  1092:       if (!rest) return jsonReply("BAD_REQUEST");
  1093: 
  1094:       // Decide whether the first token is a host or JSON.
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",

===== HIT @ line 1135 (showing 1095..1215) =====
  1095:       let host = (activeHost || "").toLowerCase();
  1096:       let jsonText = rest;
  1097: 
  1098:       const firstChar = rest[0];
  1099:       if (!(firstChar === "{" || firstChar === "[")) {
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,

===== HIT @ line 1140 (showing 1100..1220) =====
  1100:         const m = rest.match(/^(\S+)\s+([\s\S]+)$/);
  1101:         if (!m) return jsonReply("BAD_REQUEST");
  1102:         host = m[1].toLowerCase();
  1103:         jsonText = m[2].trim();
  1104:       }
  1105: 
  1106:       if (!host) return jsonReply("BAD_REQUEST");
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }

===== HIT @ line 1147 (showing 1107..1227) =====
  1107: 
  1108:       try {
  1109:         const parsed = JSON.parse(jsonText);
  1110: 
  1111:         // Normalize to an array of command strings.
  1112:         let requested = null;
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }
  1221:     }
  1222: 
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,

===== HIT @ line 1153 (showing 1113..1233) =====
  1113: 
  1114:         if (Array.isArray(parsed)) {
  1115:           requested = parsed;
  1116:         } else if (parsed && typeof parsed === "object") {
  1117:           if (typeof parsed.host === "string" && parsed.host.trim()) {
  1118:             host = parsed.host.trim().toLowerCase();
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }
  1221:     }
  1222: 
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,
  1228:       first_line_html: text1.split("\n")[0] || "",
  1229:       body_length: text1.length,
  1230:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1231:     };
  1232:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1233:     return evidence;

===== HIT @ line 1159 (showing 1119..1239) =====
  1119:           }
  1120:           if (Array.isArray(parsed.allow)) requested = parsed.allow;
  1121:           else if (Array.isArray(parsed.allowed)) requested = parsed.allowed;
  1122:         }
  1123: 
  1124:         if (!Array.isArray(requested)) return jsonReply("BAD_REQUEST");
  1125: 
  1126:         // Sanitize: keep only known commands.
  1127:         const clean = requested
  1128:           .map((s) => String(s).trim())
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }
  1221:     }
  1222: 
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,
  1228:       first_line_html: text1.split("\n")[0] || "",
  1229:       body_length: text1.length,
  1230:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1231:     };
  1232:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1233:     return evidence;
  1234:   } catch (err) {
  1235:     const evidence = {
  1236:       ok: false,
  1237:       host,
  1238:       url: target,
  1239:       http_status: 0,

===== HIT @ line 1169 (showing 1129..1249) =====
  1129:           .filter(Boolean)
  1130:           .filter((c) => allowedCommands.includes(c));
  1131: 
  1132:         await env.AURA_KV.put(capsKey(host), JSON.stringify({ allowed: clean, updated_at: nowIso() }), { expirationTtl: 60 * 60 * 24 * 30 });
  1133:         hostCapsSetCount++;
  1134:       } catch (_e) {
  1135:         return jsonReply("BAD_REQUEST");
  1136:       }
  1137:     }
  1138: 
  1139:     if (hostCapsSetCount > 0) {
  1140:       return jsonReply(hostCapsSetCount === 1 ? "OK" : `OK (${hostCapsSetCount})`);
  1141:     }
  1142:   // HOST_CAPS_GET [host] (single-command fast path only)
  1143:   if (lines.length === 1 && lines[0].startsWith("HOST_CAPS_GET")) {
  1144:     const parts = lines[0].split(" ").filter(Boolean);
  1145:     const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1146:     const caps = await getHostCaps(host);
  1147:     return jsonReply(JSON.stringify(caps || { host, allowed: null }, null, 2));
  1148:   }
  1149:     // If host caps exist and a line starts with a command that isn't allowed for this host, block deterministically.
  1150:     for (const line of lines) {
  1151:       const token = line.split(" ")[0];
  1152:       if (allowedCommands.includes(token) && !isAllowedForHost(token)) {
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }
  1221:     }
  1222: 
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,
  1228:       first_line_html: text1.split("\n")[0] || "",
  1229:       body_length: text1.length,
  1230:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1231:     };
  1232:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1233:     return evidence;
  1234:   } catch (err) {
  1235:     const evidence = {
  1236:       ok: false,
  1237:       host,
  1238:       url: target,
  1239:       http_status: 0,
  1240:       error: String(err?.message || err),
  1241:       error_name: err?.name || "UNKNOWN",
  1242:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1243:     };
  1244:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1245:     return evidence;
  1246:   }
  1247: };
  1248: 
  1249: if (isBatch) {

===== HIT @ line 1193 (showing 1153..1273) =====
  1153:         return jsonReply("NOT_ALLOWED");
  1154:       }
  1155:     }
  1156: 
  1157: // ----------------------------
  1158: // BATCH EXECUTION (ordered, multi-command)
  1159: // Purpose: allow VERIFIED_FETCH + REGISTRY_PUT/GET + AUDIT_GET + PORTFOLIO_STATUS in ONE request.
  1160: // Avoid early-returns from hasLine() helpers.
  1161: // ----------------------------
  1162: const isBatch = lines.length > 1 && lines.some((l) => {
  1163:   const tok = l.split(" ")[0];
  1164:   return allowedCommands.includes(tok);
  1165: });
  1166: 
  1167: const doVerifiedFetch = async (target) => {
  1168:   const host = normalizeHost(target);
  1169:   if (!host) return { ok: false, error: "BAD_REQUEST", url: target, http_status: 0 };
  1170: 
  1171:   const runFetch = async (probeUrl) => {
  1172:     const res = await fetch(probeUrl);
  1173:     const text = await res.text();
  1174:     return { res, text };
  1175:   };
  1176: 
  1177:   const nowTs = new Date().toISOString();
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }
  1221:     }
  1222: 
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,
  1228:       first_line_html: text1.split("\n")[0] || "",
  1229:       body_length: text1.length,
  1230:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1231:     };
  1232:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1233:     return evidence;
  1234:   } catch (err) {
  1235:     const evidence = {
  1236:       ok: false,
  1237:       host,
  1238:       url: target,
  1239:       http_status: 0,
  1240:       error: String(err?.message || err),
  1241:       error_name: err?.name || "UNKNOWN",
  1242:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1243:     };
  1244:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1245:     return evidence;
  1246:   }
  1247: };
  1248: 
  1249: if (isBatch) {
  1250:   const out = [];
  1251:   const push = (cmd, payload) => out.push({ cmd, payload });
  1252:       
  1253:   // Track which hosts were VERIFIED_FETCH_URL seeded in THIS request only.
  1254:   const __seededThisRequest = new Set();
  1255: // Claim-gate (batch mode): registry writes for a domain require VERIFIED_FETCH evidence for that domain's host.
  1256:       const __evidenceCache = new Map(); // host -> evidence payload
  1257: 
  1258:       const __getHostEvidence = async (host) => {
  1259:         const h = String(host || "").trim().toLowerCase();
  1260:         if (!h) return null;
  1261:         if (__evidenceCache.has(h)) return __evidenceCache.get(h);
  1262:         try {
  1263:           const ev = await env.AURA_KV.get(evidenceKey(h), { type: "json" });
  1264:           if (ev) __evidenceCache.set(h, ev);
  1265:           return ev || null;
  1266:         } catch (_) {
  1267:           return null;
  1268:         }
  1269:       };
  1270: 
  1271:       const __noteHostEvidence = (host, evidence) => {
  1272:         const h = String(host || "").trim().toLowerCase();
  1273:         if (!h) return;

===== HIT @ line 1218 (showing 1178..1298) =====
  1178:   const selfHost = new URL(request.url).host.toLowerCase();
  1179: 
  1180:   if (host === selfHost) {
  1181:     const evidence = {
  1182:       ok: true,
  1183:       host,
  1184:       url: target,
  1185:       probe_url: null,
  1186:       http_status: 200,
  1187:       first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  1188:       body_length: 0,
  1189:       synthetic: true,
  1190:       reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  1191:       diagnostics: { cf: request.cf || null, self_host: selfHost, ts: nowTs }
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }
  1221:     }
  1222: 
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,
  1228:       first_line_html: text1.split("\n")[0] || "",
  1229:       body_length: text1.length,
  1230:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1231:     };
  1232:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1233:     return evidence;
  1234:   } catch (err) {
  1235:     const evidence = {
  1236:       ok: false,
  1237:       host,
  1238:       url: target,
  1239:       http_status: 0,
  1240:       error: String(err?.message || err),
  1241:       error_name: err?.name || "UNKNOWN",
  1242:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1243:     };
  1244:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1245:     return evidence;
  1246:   }
  1247: };
  1248: 
  1249: if (isBatch) {
  1250:   const out = [];
  1251:   const push = (cmd, payload) => out.push({ cmd, payload });
  1252:       
  1253:   // Track which hosts were VERIFIED_FETCH_URL seeded in THIS request only.
  1254:   const __seededThisRequest = new Set();
  1255: // Claim-gate (batch mode): registry writes for a domain require VERIFIED_FETCH evidence for that domain's host.
  1256:       const __evidenceCache = new Map(); // host -> evidence payload
  1257: 
  1258:       const __getHostEvidence = async (host) => {
  1259:         const h = String(host || "").trim().toLowerCase();
  1260:         if (!h) return null;
  1261:         if (__evidenceCache.has(h)) return __evidenceCache.get(h);
  1262:         try {
  1263:           const ev = await env.AURA_KV.get(evidenceKey(h), { type: "json" });
  1264:           if (ev) __evidenceCache.set(h, ev);
  1265:           return ev || null;
  1266:         } catch (_) {
  1267:           return null;
  1268:         }
  1269:       };
  1270: 
  1271:       const __noteHostEvidence = (host, evidence) => {
  1272:         const h = String(host || "").trim().toLowerCase();
  1273:         if (!h) return;
  1274:         __evidenceCache.set(h, evidence || { ok: true, host: h });
  1275:       };
  1276: 
  1277:       const __domainHostFromRegistryEntry = (type, item) => {
  1278:         try {
  1279:           if (!item || typeof item !== "object") return null;
  1280:           if (type === "domains") return (item.domain || item.id || "").toString();
  1281:           if (type === "assets") {
  1282:             return (item.domain_id || (Array.isArray(item.domains) && item.domains[0]) || "").toString();
  1283:           }
  1284:           return null;
  1285:         } catch (_) {
  1286:           return null;
  1287:         }
  1288:       };
  1289: 
  1290: 
  1291:   // Execute in the order provided.
  1292:   for (let i = 0; i < lines.length; i++) {
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.

===== HIT @ line 1232 (showing 1192..1312) =====
  1192:     };
  1193:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1194:     return evidence;
  1195:   }
  1196: 
  1197:   try {
  1198:     const { res: res1, text: text1 } = await runFetch(target);
  1199: 
  1200:     if (res1.status === 525) {
  1201:       const u = new URL(target);
  1202:       if (u.protocol === "https:") {
  1203:         u.protocol = "http:";
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }
  1221:     }
  1222: 
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,
  1228:       first_line_html: text1.split("\n")[0] || "",
  1229:       body_length: text1.length,
  1230:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1231:     };
  1232:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1233:     return evidence;
  1234:   } catch (err) {
  1235:     const evidence = {
  1236:       ok: false,
  1237:       host,
  1238:       url: target,
  1239:       http_status: 0,
  1240:       error: String(err?.message || err),
  1241:       error_name: err?.name || "UNKNOWN",
  1242:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1243:     };
  1244:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1245:     return evidence;
  1246:   }
  1247: };
  1248: 
  1249: if (isBatch) {
  1250:   const out = [];
  1251:   const push = (cmd, payload) => out.push({ cmd, payload });
  1252:       
  1253:   // Track which hosts were VERIFIED_FETCH_URL seeded in THIS request only.
  1254:   const __seededThisRequest = new Set();
  1255: // Claim-gate (batch mode): registry writes for a domain require VERIFIED_FETCH evidence for that domain's host.
  1256:       const __evidenceCache = new Map(); // host -> evidence payload
  1257: 
  1258:       const __getHostEvidence = async (host) => {
  1259:         const h = String(host || "").trim().toLowerCase();
  1260:         if (!h) return null;
  1261:         if (__evidenceCache.has(h)) return __evidenceCache.get(h);
  1262:         try {
  1263:           const ev = await env.AURA_KV.get(evidenceKey(h), { type: "json" });
  1264:           if (ev) __evidenceCache.set(h, ev);
  1265:           return ev || null;
  1266:         } catch (_) {
  1267:           return null;
  1268:         }
  1269:       };
  1270: 
  1271:       const __noteHostEvidence = (host, evidence) => {
  1272:         const h = String(host || "").trim().toLowerCase();
  1273:         if (!h) return;
  1274:         __evidenceCache.set(h, evidence || { ok: true, host: h });
  1275:       };
  1276: 
  1277:       const __domainHostFromRegistryEntry = (type, item) => {
  1278:         try {
  1279:           if (!item || typeof item !== "object") return null;
  1280:           if (type === "domains") return (item.domain || item.id || "").toString();
  1281:           if (type === "assets") {
  1282:             return (item.domain_id || (Array.isArray(item.domains) && item.domains[0]) || "").toString();
  1283:           }
  1284:           return null;
  1285:         } catch (_) {
  1286:           return null;
  1287:         }
  1288:       };
  1289: 
  1290: 
  1291:   // Execute in the order provided.
  1292:   for (let i = 0; i < lines.length; i++) {
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.
  1299:     const opOnly =
  1300:       line === "AUDIT_GET" ||
  1301:       line === "AUDIT_CLEAR" ||
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }

===== HIT @ line 1244 (showing 1204..1324) =====
  1204:         const httpUrl = u.toString();
  1205:         const { res: res2, text: text2 } = await runFetch(httpUrl);
  1206: 
  1207:         const evidence = {
  1208:           ok: true,
  1209:           host,
  1210:           public_url: target,
  1211:           probe_url: httpUrl,
  1212:           fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  1213:           http_status: res2.status,
  1214:           first_line_html: text2.split("\n")[0] || "",
  1215:           body_length: text2.length,
  1216:           diagnostics: { cf: request.cf || null, https_status: 525, ts: nowTs }
  1217:         };
  1218:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1219:         return evidence;
  1220:       }
  1221:     }
  1222: 
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,
  1228:       first_line_html: text1.split("\n")[0] || "",
  1229:       body_length: text1.length,
  1230:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1231:     };
  1232:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1233:     return evidence;
  1234:   } catch (err) {
  1235:     const evidence = {
  1236:       ok: false,
  1237:       host,
  1238:       url: target,
  1239:       http_status: 0,
  1240:       error: String(err?.message || err),
  1241:       error_name: err?.name || "UNKNOWN",
  1242:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1243:     };
  1244:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1245:     return evidence;
  1246:   }
  1247: };
  1248: 
  1249: if (isBatch) {
  1250:   const out = [];
  1251:   const push = (cmd, payload) => out.push({ cmd, payload });
  1252:       
  1253:   // Track which hosts were VERIFIED_FETCH_URL seeded in THIS request only.
  1254:   const __seededThisRequest = new Set();
  1255: // Claim-gate (batch mode): registry writes for a domain require VERIFIED_FETCH evidence for that domain's host.
  1256:       const __evidenceCache = new Map(); // host -> evidence payload
  1257: 
  1258:       const __getHostEvidence = async (host) => {
  1259:         const h = String(host || "").trim().toLowerCase();
  1260:         if (!h) return null;
  1261:         if (__evidenceCache.has(h)) return __evidenceCache.get(h);
  1262:         try {
  1263:           const ev = await env.AURA_KV.get(evidenceKey(h), { type: "json" });
  1264:           if (ev) __evidenceCache.set(h, ev);
  1265:           return ev || null;
  1266:         } catch (_) {
  1267:           return null;
  1268:         }
  1269:       };
  1270: 
  1271:       const __noteHostEvidence = (host, evidence) => {
  1272:         const h = String(host || "").trim().toLowerCase();
  1273:         if (!h) return;
  1274:         __evidenceCache.set(h, evidence || { ok: true, host: h });
  1275:       };
  1276: 
  1277:       const __domainHostFromRegistryEntry = (type, item) => {
  1278:         try {
  1279:           if (!item || typeof item !== "object") return null;
  1280:           if (type === "domains") return (item.domain || item.id || "").toString();
  1281:           if (type === "assets") {
  1282:             return (item.domain_id || (Array.isArray(item.domains) && item.domains[0]) || "").toString();
  1283:           }
  1284:           return null;
  1285:         } catch (_) {
  1286:           return null;
  1287:         }
  1288:       };
  1289: 
  1290: 
  1291:   // Execute in the order provided.
  1292:   for (let i = 0; i < lines.length; i++) {
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.
  1299:     const opOnly =
  1300:       line === "AUDIT_GET" ||
  1301:       line === "AUDIT_CLEAR" ||
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 

===== HIT @ line 1263 (showing 1223..1343) =====
  1223:     const evidence = {
  1224:       ok: true,
  1225:       host,
  1226:       url: target,
  1227:       http_status: res1.status,
  1228:       first_line_html: text1.split("\n")[0] || "",
  1229:       body_length: text1.length,
  1230:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1231:     };
  1232:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1233:     return evidence;
  1234:   } catch (err) {
  1235:     const evidence = {
  1236:       ok: false,
  1237:       host,
  1238:       url: target,
  1239:       http_status: 0,
  1240:       error: String(err?.message || err),
  1241:       error_name: err?.name || "UNKNOWN",
  1242:       diagnostics: { cf: request.cf || null, ts: nowTs }
  1243:     };
  1244:     await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  1245:     return evidence;
  1246:   }
  1247: };
  1248: 
  1249: if (isBatch) {
  1250:   const out = [];
  1251:   const push = (cmd, payload) => out.push({ cmd, payload });
  1252:       
  1253:   // Track which hosts were VERIFIED_FETCH_URL seeded in THIS request only.
  1254:   const __seededThisRequest = new Set();
  1255: // Claim-gate (batch mode): registry writes for a domain require VERIFIED_FETCH evidence for that domain's host.
  1256:       const __evidenceCache = new Map(); // host -> evidence payload
  1257: 
  1258:       const __getHostEvidence = async (host) => {
  1259:         const h = String(host || "").trim().toLowerCase();
  1260:         if (!h) return null;
  1261:         if (__evidenceCache.has(h)) return __evidenceCache.get(h);
  1262:         try {
  1263:           const ev = await env.AURA_KV.get(evidenceKey(h), { type: "json" });
  1264:           if (ev) __evidenceCache.set(h, ev);
  1265:           return ev || null;
  1266:         } catch (_) {
  1267:           return null;
  1268:         }
  1269:       };
  1270: 
  1271:       const __noteHostEvidence = (host, evidence) => {
  1272:         const h = String(host || "").trim().toLowerCase();
  1273:         if (!h) return;
  1274:         __evidenceCache.set(h, evidence || { ok: true, host: h });
  1275:       };
  1276: 
  1277:       const __domainHostFromRegistryEntry = (type, item) => {
  1278:         try {
  1279:           if (!item || typeof item !== "object") return null;
  1280:           if (type === "domains") return (item.domain || item.id || "").toString();
  1281:           if (type === "assets") {
  1282:             return (item.domain_id || (Array.isArray(item.domains) && item.domains[0]) || "").toString();
  1283:           }
  1284:           return null;
  1285:         } catch (_) {
  1286:           return null;
  1287:         }
  1288:       };
  1289: 
  1290: 
  1291:   // Execute in the order provided.
  1292:   for (let i = 0; i < lines.length; i++) {
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.
  1299:     const opOnly =
  1300:       line === "AUDIT_GET" ||
  1301:       line === "AUDIT_CLEAR" ||
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));

===== HIT @ line 1304 (showing 1264..1384) =====
  1264:           if (ev) __evidenceCache.set(h, ev);
  1265:           return ev || null;
  1266:         } catch (_) {
  1267:           return null;
  1268:         }
  1269:       };
  1270: 
  1271:       const __noteHostEvidence = (host, evidence) => {
  1272:         const h = String(host || "").trim().toLowerCase();
  1273:         if (!h) return;
  1274:         __evidenceCache.set(h, evidence || { ok: true, host: h });
  1275:       };
  1276: 
  1277:       const __domainHostFromRegistryEntry = (type, item) => {
  1278:         try {
  1279:           if (!item || typeof item !== "object") return null;
  1280:           if (type === "domains") return (item.domain || item.id || "").toString();
  1281:           if (type === "assets") {
  1282:             return (item.domain_id || (Array.isArray(item.domains) && item.domains[0]) || "").toString();
  1283:           }
  1284:           return null;
  1285:         } catch (_) {
  1286:           return null;
  1287:         }
  1288:       };
  1289: 
  1290: 
  1291:   // Execute in the order provided.
  1292:   for (let i = 0; i < lines.length; i++) {
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.
  1299:     const opOnly =
  1300:       line === "AUDIT_GET" ||
  1301:       line === "AUDIT_CLEAR" ||
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 

===== HIT @ line 1310 (showing 1270..1390) =====
  1270: 
  1271:       const __noteHostEvidence = (host, evidence) => {
  1272:         const h = String(host || "").trim().toLowerCase();
  1273:         if (!h) return;
  1274:         __evidenceCache.set(h, evidence || { ok: true, host: h });
  1275:       };
  1276: 
  1277:       const __domainHostFromRegistryEntry = (type, item) => {
  1278:         try {
  1279:           if (!item || typeof item !== "object") return null;
  1280:           if (type === "domains") return (item.domain || item.id || "").toString();
  1281:           if (type === "assets") {
  1282:             return (item.domain_id || (Array.isArray(item.domains) && item.domains[0]) || "").toString();
  1283:           }
  1284:           return null;
  1285:         } catch (_) {
  1286:           return null;
  1287:         }
  1288:       };
  1289: 
  1290: 
  1291:   // Execute in the order provided.
  1292:   for (let i = 0; i < lines.length; i++) {
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.
  1299:     const opOnly =
  1300:       line === "AUDIT_GET" ||
  1301:       line === "AUDIT_CLEAR" ||
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {

===== HIT @ line 1311 (showing 1271..1391) =====
  1271:       const __noteHostEvidence = (host, evidence) => {
  1272:         const h = String(host || "").trim().toLowerCase();
  1273:         if (!h) return;
  1274:         __evidenceCache.set(h, evidence || { ok: true, host: h });
  1275:       };
  1276: 
  1277:       const __domainHostFromRegistryEntry = (type, item) => {
  1278:         try {
  1279:           if (!item || typeof item !== "object") return null;
  1280:           if (type === "domains") return (item.domain || item.id || "").toString();
  1281:           if (type === "assets") {
  1282:             return (item.domain_id || (Array.isArray(item.domains) && item.domains[0]) || "").toString();
  1283:           }
  1284:           return null;
  1285:         } catch (_) {
  1286:           return null;
  1287:         }
  1288:       };
  1289: 
  1290: 
  1291:   // Execute in the order provided.
  1292:   for (let i = 0; i < lines.length; i++) {
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.
  1299:     const opOnly =
  1300:       line === "AUDIT_GET" ||
  1301:       line === "AUDIT_CLEAR" ||
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });

===== HIT @ line 1320 (showing 1280..1400) =====
  1280:           if (type === "domains") return (item.domain || item.id || "").toString();
  1281:           if (type === "assets") {
  1282:             return (item.domain_id || (Array.isArray(item.domains) && item.domains[0]) || "").toString();
  1283:           }
  1284:           return null;
  1285:         } catch (_) {
  1286:           return null;
  1287:         }
  1288:       };
  1289: 
  1290: 
  1291:   // Execute in the order provided.
  1292:   for (let i = 0; i < lines.length; i++) {
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.
  1299:     const opOnly =
  1300:       line === "AUDIT_GET" ||
  1301:       line === "AUDIT_CLEAR" ||
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",

===== HIT @ line 1333 (showing 1293..1413) =====
  1293:     const line = lines[i];
  1294:     if (line.startsWith("HOST ")) continue;
  1295: 
  1296:     // Operator-only command gate (fail closed)
  1297:     // NOTE: "inspection" commands should be available without operator auth.
  1298:     // Only privileged mutations and deploy actions require operator auth.
  1299:     const opOnly =
  1300:       line === "AUDIT_GET" ||
  1301:       line === "AUDIT_CLEAR" ||
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------

===== HIT @ line 1342 (showing 1302..1422) =====
  1302:       line.startsWith("CLEAR_VERIFIED_FETCH") ||
  1303:       line === "HOST_CAPS_SET" ||
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };

===== HIT @ line 1344 (showing 1304..1424) =====
  1304:       line.startsWith("REGISTRY_PUT") ||
  1305:       line.startsWith("REGISTRY_IMPORT_") ||
  1306:       line.startsWith("DEPLOYER_CALL") ||
  1307:       line.startsWith("INTENT_ADD") ||
  1308:       line.startsWith("INTENT_CLEAR");
  1309:     if (opOnly) {
  1310:       if (!operatorToken) return jsonReply("OPERATOR_TOKEN_NOT_CONFIGURED");
  1311:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {

===== HIT @ line 1352 (showing 1312..1432) =====
  1312:     }
  1313: 
  1314: 
  1315:     // ----------------------------
  1316:     // Intent (batch mode)  emit cmd entries (no early return)
  1317:     // ----------------------------
  1318:     if (line.startsWith("INTENT_ADD")) {
  1319:       const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  1320:       if (!m) { push("INTENT_ADD", "BAD_REQUEST"); continue; }
  1321:       const host = m[1].toLowerCase();
  1322:       const tag = m[2].toLowerCase();
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {
  1425:         const s = await env.AURA_KV.get(key);
  1426:         if (!s) return null;
  1427:         const j = safeJsonParse(s);
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",

===== HIT @ line 1363 (showing 1323..1443) =====
  1323:       const text = m[3];
  1324: 
  1325:       const payload = {
  1326:         host,
  1327:         tag,
  1328:         text,
  1329:         created_at: nowIso(),
  1330:         consent: "EXPLICIT_COMMAND"
  1331:       };
  1332: 
  1333:       await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  1334:       push("INTENT_ADD", { ok: true, host, tag });
  1335:       continue;
  1336:     }
  1337: 
  1338:     if (line.startsWith("INTENT_GET")) {
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {
  1425:         const s = await env.AURA_KV.get(key);
  1426:         if (!s) return null;
  1427:         const j = safeJsonParse(s);
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",
  1433:         "AUTONOMY_LAST_TICK",
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",

===== HIT @ line 1379 (showing 1339..1459) =====
  1339:       const parts = line.split(" ").filter(Boolean);
  1340:       const host = (parts[1] || "").toLowerCase();
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {
  1425:         const s = await env.AURA_KV.get(key);
  1426:         if (!s) return null;
  1427:         const j = safeJsonParse(s);
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",
  1433:         "AUTONOMY_LAST_TICK",
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",
  1444:         "INTENT_SIMULATE"
  1445:       ];
  1446: 
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }

===== HIT @ line 1381 (showing 1341..1461) =====
  1341:       const tag = (parts[2] || "").toLowerCase();
  1342:       if (!host || !tag) { push("INTENT_GET", "BAD_REQUEST"); continue; }
  1343:       const stored = await env.AURA_KV.get(intentKey(host, tag));
  1344:       push("INTENT_GET", stored ? (safeJsonParse(stored) || stored) : "INTENT_MISSING");
  1345:       continue;
  1346:     }
  1347: 
  1348:     if (line.startsWith("INTENT_CLEAR")) {
  1349:       const parts = line.split(" ").filter(Boolean);
  1350:       const host = (parts[1] || "").toLowerCase();
  1351:       const tag = (parts[2] || "").toLowerCase();
  1352:       if (!host || !tag) { push("INTENT_CLEAR", "BAD_REQUEST"); continue; }
  1353:       await env.AURA_KV.delete(intentKey(host, tag));
  1354:       push("INTENT_CLEAR", "CLEARED");
  1355:       continue;
  1356:     }
  1357: 
  1358: 
  1359:     if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  1360:       const parts = line.split(" ").filter(Boolean);
  1361:       const host = normalizeHost(parts[1]);
  1362:       if (host) await env.AURA_KV.delete(evidenceKey(host));
  1363:       push("CLEAR_VERIFIED_FETCH", host ? "CLEARED" : "BAD_REQUEST");
  1364:       continue;
  1365:     }
  1366: 
  1367:     if (line.startsWith("VERIFIED_FETCH_URL")) {
  1368:       const parts = line.split(" ").filter(Boolean);
  1369:       const target = parts[1];
  1370:       const ev = await doVerifiedFetch(target);
  1371:       push("VERIFIED_FETCH_URL", ev);
  1372:       if (ev && ev.ok && ev.host) { __seededThisRequest.add(String(ev.host).toLowerCase()); }
  1373:       continue;
  1374:     }
  1375: 
  1376:     if (line.startsWith("EVIDENCE_PRESENT")) {
  1377:       const parts = line.split(" ").filter(Boolean);
  1378:       const host = normalizeHostLoose(parts[1]) || activeHost;
  1379:       if (!host) { push("EVIDENCE_PRESENT", "BAD_REQUEST"); continue; }
  1380:       const stored = await env.AURA_KV.get(evidenceKey(host));
  1381:       push("EVIDENCE_PRESENT", stored ? (safeJsonParse(stored) || stored) : "NO_EVIDENCE");
  1382:       continue;
  1383:     }
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {
  1425:         const s = await env.AURA_KV.get(key);
  1426:         if (!s) return null;
  1427:         const j = safeJsonParse(s);
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",
  1433:         "AUTONOMY_LAST_TICK",
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",
  1444:         "INTENT_SIMULATE"
  1445:       ];
  1446: 
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {

===== HIT @ line 1424 (showing 1384..1504) =====
  1384: 
  1385:     if (line === "SHOW_MEMORY_SCHEMA") {
  1386:       push("SHOW_MEMORY_SCHEMA", memorySchemaV1);
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {
  1425:         const s = await env.AURA_KV.get(key);
  1426:         if (!s) return null;
  1427:         const j = safeJsonParse(s);
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",
  1433:         "AUTONOMY_LAST_TICK",
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",
  1444:         "INTENT_SIMULATE"
  1445:       ];
  1446: 
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.

===== HIT @ line 1427 (showing 1387..1507) =====
  1387:       continue;
  1388:     }
  1389: 
  1390: if (line === "SHOW_BUILD") {
  1391:   push("SHOW_BUILD", { build: BUILD, stamp: new Date().toISOString() });
  1392:   continue;
  1393: }
  1394: 
  1395: if (line === "SHOW_CLAIM_GATE") {
  1396:   push("SHOW_CLAIM_GATE", {
  1397:     trigger_words: [
  1398:       "live","deployed","launched","resolving","propagating","successful","verified","up","online","working","reachable","available","accessible"
  1399:     ],
  1400:     forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  1401:     requires_verified_fetch_format: true
  1402:   });
  1403:   continue;
  1404: }
  1405: 
  1406: if (line === "SHOW_ALLOWED_COMMANDS") {
  1407:   push("SHOW_ALLOWED_COMMANDS", allowedCommands);
  1408:   continue;
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {
  1425:         const s = await env.AURA_KV.get(key);
  1426:         if (!s) return null;
  1427:         const j = safeJsonParse(s);
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",
  1433:         "AUTONOMY_LAST_TICK",
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",
  1444:         "INTENT_SIMULATE"
  1445:       ];
  1446: 
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.

===== HIT @ line 1449 (showing 1409..1529) =====
  1409: }
  1410: 
  1411:         // ----------------------------
  1412:     // AUTONOMY PRIMITIVES (batch mode; deterministic state)
  1413:     // ----------------------------
  1414:     {
  1415:       const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1416:       const __budgetKey  = `AUTONOMY_BUDGET__${__host}`;
  1417:       const __charterKey = `AUTONOMY_CHARTER__${__host}`;
  1418:       const __tickKey    = `AUTONOMY_LAST_TICK__${__host}`;
  1419:       const __failKey    = `FAILURE_MEMORY__${__host}`;
  1420: 
  1421:       const __defaultBudget = { limit: 100, spent: 0, window: "day", updated_at: null };
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {
  1425:         const s = await env.AURA_KV.get(key);
  1426:         if (!s) return null;
  1427:         const j = safeJsonParse(s);
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",
  1433:         "AUTONOMY_LAST_TICK",
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",
  1444:         "INTENT_SIMULATE"
  1445:       ];
  1446: 
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 

===== HIT @ line 1462 (showing 1422..1542) =====
  1422:       const __defaultCharter = { version: 1, text: "", updated_at: null };
  1423: 
  1424:       const __readJsonKV = async (key) => {
  1425:         const s = await env.AURA_KV.get(key);
  1426:         if (!s) return null;
  1427:         const j = safeJsonParse(s);
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",
  1433:         "AUTONOMY_LAST_TICK",
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",
  1444:         "INTENT_SIMULATE"
  1445:       ];
  1446: 
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).

===== HIT @ line 1468 (showing 1428..1548) =====
  1428:         return j || null;
  1429:       };
  1430: 
  1431:       const __capabilities = [
  1432:         "AUTONOMY_STATUS",
  1433:         "AUTONOMY_LAST_TICK",
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",
  1444:         "INTENT_SIMULATE"
  1445:       ];
  1446: 
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;

===== HIT @ line 1474 (showing 1434..1554) =====
  1434:         "AUTONOMY_LAST_TICK_SET",
  1435:   "AUTONOMY_LAST_TICK_SET",
  1436:         "AUTONOMY_CAPABILITIES",
  1437:         "AUTONOMY_BUDGET_GET",
  1438:         "AUTONOMY_BUDGET_SET",
  1439:         "AUTONOMY_CHARTER_GET",
  1440:         "AUTONOMY_CHARTER_SET",
  1441:         "FAILURE_MEMORY_GET",
  1442:         "FAILURE_MEMORY_PUT",
  1443:         "REGISTRY_AUDIT_TRAIL",
  1444:         "INTENT_SIMULATE"
  1445:       ];
  1446: 
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };

===== HIT @ line 1487 (showing 1447..1567) =====
  1447:       if (line === "AUTONOMY_LAST_TICK") {
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();

===== HIT @ line 1488 (showing 1448..1568) =====
  1448:         const last = await env.AURA_KV.get(__tickKey);
  1449: const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null);
  1450: const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null;
  1451: const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last));
  1452: push("AUTONOMY_LAST_TICK", { ok: true, host: __host, last_tick: (chosen || null) });
  1453:         continue;
  1454:       }
  1455: 
  1456:       if (line === "AUTONOMY_CAPABILITIES") {
  1457:         push("AUTONOMY_CAPABILITIES", { ok: true, host: __host, capabilities: __capabilities, count: __capabilities.length });
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;

===== HIT @ line 1498 (showing 1458..1578) =====
  1458:         continue;
  1459:       }
  1460: 
  1461:       if (line === "AUTONOMY_BUDGET_GET") {
  1462:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1463:         push("AUTONOMY_BUDGET_GET", { ok: true, host: __host, budget: b });
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;

===== HIT @ line 1504 (showing 1464..1584) =====
  1464:         continue;
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }

===== HIT @ line 1505 (showing 1465..1585) =====
  1465:       }
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 

===== HIT @ line 1506 (showing 1466..1586) =====
  1466: 
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();

===== HIT @ line 1507 (showing 1467..1587) =====
  1467:       if (line === "AUTONOMY_CHARTER_GET") {
  1468:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1469:         push("AUTONOMY_CHARTER_GET", { ok: true, host: __host, charter: c });
  1470:         continue;
  1471:       }
  1472: 
  1473:       if (line === "FAILURE_MEMORY_GET") {
  1474:         const fm = (await __readJsonKV(__failKey)) || [];
  1475:         push("FAILURE_MEMORY_GET", { ok: true, host: __host, items: fm, count: Array.isArray(fm) ? fm.length : 0 });
  1476:         continue;
  1477:       }
  1478: 
  1479:       if (line === "REGISTRY_AUDIT_TRAIL") {
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;

===== HIT @ line 1520 (showing 1480..1600) =====
  1480:         // Reuse the existing audit substrate as the authoritative trail output for now.
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });

===== HIT @ line 1521 (showing 1481..1601) =====
  1481:         // Deterministic: returns latest 50 events (or fewer) using existing auditList().
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;

===== HIT @ line 1522 (showing 1482..1602) =====
  1482:         push("REGISTRY_AUDIT_TRAIL", { ok: true, host: __host, trail: await auditList(env, 50) });
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;

===== HIT @ line 1523 (showing 1483..1603) =====
  1483:         continue;
  1484:       }
  1485: 
  1486:       if (line === "AUTONOMY_STATUS") {
  1487:         const b = (await __readJsonKV(__budgetKey)) || __defaultBudget;
  1488:         const c = (await __readJsonKV(__charterKey)) || __defaultCharter;
  1489:         const last = await env.AURA_KV.get(__tickKey);
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }

===== HIT @ line 1530 (showing 1490..1610) =====
  1490:         push("AUTONOMY_STATUS", {
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }

===== HIT @ line 1531 (showing 1491..1611) =====
  1491:           ok: true,
  1492:           host: __host,
  1493:           build: BUILD,
  1494:           stamp: nowIso(),
  1495:           evidence_present_for_active_host: activeHost ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase()))) : false,
  1496:           budget: b,
  1497:           charter: c,
  1498:           last_tick: (await (async()=>{ const cron = await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null); const cronTs = (cron && (cron.ts || cron.stamp)) ? String(cron.ts || cron.stamp) : null; const chosen = (!last ? cronTs : (cronTs && String(cronTs) > String(last) ? cronTs : last)); return chosen || null; })()),
  1499:           capabilities_count: __capabilities.length
  1500:         });
  1501:         continue;
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));

===== HIT @ line 1542 (showing 1502..1622) =====
  1502:       }
  1503: 
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.

===== HIT @ line 1544 (showing 1504..1624) =====
  1504:       // SET/PUT are envelope-gated (files/packets): JSON must be provided on subsequent non-command lines.
  1505: // Deterministic: parse envelope, write KV, return readback payload.
  1506: const __readEnvelopeJson = () => {
  1507:   // Consume subsequent non-command lines as JSON text.
  1508:   // Stops when the next allowed command token begins.
  1509:   let j = i + 1;
  1510:   const buf = [];
  1511:   while (j < lines.length) {
  1512:     const l = lines[j];
  1513:     if (!l) { j++; continue; }
  1514:     if (l.startsWith("HOST ")) { j++; continue; }
  1515:     const tok = l.split(" ")[0];
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {

===== HIT @ line 1556 (showing 1516..1636) =====
  1516:     if (allowedCommands.includes(tok)) break;
  1517:     buf.push(l);
  1518:     j++;
  1519:   }
  1520:   if (!buf.length) return { ok: false, error: "BAD_REQUEST", note: "requires envelope (file/packet)  no inline JSON", consumed: 0 };
  1521:   const jsonText = buf.join("\n");
  1522:   const obj = safeJsonParse(jsonText);
  1523:   if (!obj || typeof obj !== "object") return { ok: false, error: "BAD_REQUEST", note: "envelope JSON parse failed", consumed: (j - (i + 1)) };
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));

===== HIT @ line 1564 (showing 1524..1644) =====
  1524:   return { ok: true, obj, consumed: (j - (i + 1)) };
  1525: };
  1526: 
  1527: if (line === "AUTONOMY_LAST_TICK_SET") {
  1528:   if (!isOperator) { push("AUTONOMY_LAST_TICK_SET", "NOT_ALLOWED"); continue; }
  1529: 
  1530:   const r = __readEnvelopeJson();
  1531:   if (!r || !r.ok) { push("AUTONOMY_LAST_TICK_SET", "BAD_REQUEST"); continue; }
  1532: 
  1533:   const __host = String(activeHost || "frontdesk.network").toLowerCase();
  1534:   const __tickKey = `AUTONOMY_LAST_TICK__${__host}`;
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {

===== HIT @ line 1575 (showing 1535..1655) =====
  1535:   const ts = nowIso();
  1536: 
  1537:   await env.AURA_KV.put(__tickKey, ts, { expirationTtl: 60 * 60 * 24 * 30 });
  1538:   push("AUTONOMY_LAST_TICK_SET", { ok: true, host: __host, last_tick: ts, stamp: ts });
  1539:   continue;
  1540: }
  1541: if (line === "AUTONOMY_BUDGET_SET") {
  1542:   // Envelope JSON must be provided on subsequent non-command lines (no inline JSON).
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 

===== HIT @ line 1583 (showing 1543..1663) =====
  1543: 
  1544:   const r = __readEnvelopeJson();
  1545:   if (!r.ok) { push("AUTONOMY_BUDGET_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1546: 
  1547:   const host = String(r.obj.host || __host).toLowerCase();
  1548:   const b0 = (r.obj.budget && typeof r.obj.budget === "object") ? r.obj.budget : r.obj;
  1549:   const budget = {
  1550:     limit: (typeof b0.limit === "number" ? b0.limit : __defaultBudget.limit),
  1551:     spent: (typeof b0.spent === "number" ? b0.spent : __defaultBudget.spent),
  1552:     window: (typeof b0.window === "string" ? b0.window : __defaultBudget.window),
  1553:     updated_at: nowIso()
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {

===== HIT @ line 1594 (showing 1554..1674) =====
  1554:   };
  1555: 
  1556:   await env.AURA_KV.put(`AUTONOMY_BUDGET__${host}`, JSON.stringify(budget));
  1557:   push("AUTONOMY_BUDGET_SET", { ok: true, host, budget });
  1558:   i += r.consumed;
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }

===== HIT @ line 1599 (showing 1559..1679) =====
  1559:   continue;
  1560: }
  1561: 
  1562: if (line === "AUTONOMY_CHARTER_SET") {
  1563: 
  1564:   const r = __readEnvelopeJson();
  1565:   if (!r.ok) { push("AUTONOMY_CHARTER_SET", { ok: false, error: r.error, note: r.note }); continue; }
  1566: 
  1567:   const host = String(r.obj.host || __host).toLowerCase();
  1568:   const c0 = (r.obj.charter && typeof r.obj.charter === "object") ? r.obj.charter : r.obj;
  1569:   const charter = {
  1570:     version: (typeof c0.version === "number" ? c0.version : __defaultCharter.version),
  1571:     text: (typeof c0.text === "string" ? c0.text : __defaultCharter.text),
  1572:     updated_at: nowIso()
  1573:   };
  1574: 
  1575:   await env.AURA_KV.put(`AUTONOMY_CHARTER__${host}`, JSON.stringify(charter));
  1576:   push("AUTONOMY_CHARTER_SET", { ok: true, host, charter });
  1577:   i += r.consumed;
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }

===== HIT @ line 1618 (showing 1578..1698) =====
  1578:   continue;
  1579: }
  1580: 
  1581: if (line === "FAILURE_MEMORY_PUT") {
  1582: 
  1583:   const r = __readEnvelopeJson();
  1584:   if (!r.ok) { push("FAILURE_MEMORY_PUT", { ok: false, error: r.error, note: r.note }); continue; }
  1585: 
  1586:   const host = String(r.obj.host || __host).toLowerCase();
  1587:   const item0 = (r.obj.item && typeof r.obj.item === "object") ? r.obj.item : r.obj;
  1588:   const item = {
  1589:     at: (typeof item0.at === "string" ? item0.at : nowIso()),
  1590:     code: String(item0.code || "X"),
  1591:     detail: String(item0.detail || "")
  1592:   };
  1593: 
  1594:   const existing = (await __readJsonKV(`FAILURE_MEMORY__${host}`)) || [];
  1595:   const arr = Array.isArray(existing) ? existing : [];
  1596:   arr.push(item);
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,

===== HIT @ line 1637 (showing 1597..1717) =====
  1597:   const bounded = arr.slice(-200);
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 

===== HIT @ line 1638 (showing 1598..1718) =====
  1598: 
  1599:   await env.AURA_KV.put(`FAILURE_MEMORY__${host}`, JSON.stringify(bounded));
  1600:   push("FAILURE_MEMORY_PUT", { ok: true, host, item, count: bounded.length });
  1601:   i += r.consumed;
  1602:   continue;
  1603: }
  1604: 
  1605: if (line === "INTENT_SIMULATE") {
  1606:         push("INTENT_SIMULATE", { ok: true, host: __host, note: "preview-only" });
  1607:         continue;
  1608:       }
  1609:     }    if (line === "AUDIT_GET") {
  1610:       if (!isOperator) { out.push({ cmd: "AUDIT_GET", payload: "UNAUTHORIZED" }); continue; }
  1611:       push("AUDIT_GET", await auditList(env, 50));
  1612:       continue;
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {

===== HIT @ line 1653 (showing 1613..1733) =====
  1613:     }
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {

===== HIT @ line 1654 (showing 1614..1734) =====
  1614: 
  1615:     if (line === "AUDIT_CLEAR") {
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,

===== HIT @ line 1656 (showing 1616..1736) =====
  1616:       if (!isOperator) { out.push({ cmd: "AUDIT_CLEAR", payload: "UNAUTHORIZED" }); continue; }
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",

===== HIT @ line 1657 (showing 1617..1737) =====
  1617:       // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  1618:       if (!activeHost) { out.push({ cmd: "AUDIT_CLEAR", payload: "BAD_REQUEST" }); continue; }
  1619:       // Require evidence for active host (KV-backed). No "same request" seed requirement.
  1620:       const _ev = await __getHostEvidence(String(activeHost).toLowerCase());
  1621:       if (!_ev) { out.push({ cmd: "AUDIT_CLEAR", payload: "NOT_WIRED: VERIFIED_FETCH REQUIRED" }); continue; }
  1622:       // IMPORTANT: clearing should never crash the Worker.
  1623:       // We clear by resetting the sequence pointer; old event keys become unreachable.
  1624:       try {
  1625:         await env.AURA_KV.put(auditSeqKey, "0");
  1626:         await env.AURA_KV.put(auditClearedAtKey, nowIso());
  1627:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: true, cleared: true } });
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),

===== HIT @ line 1668 (showing 1628..1748) =====
  1628:       } catch (e) {
  1629:         out.push({ cmd: "AUDIT_CLEAR", payload: { ok: false, error: "EXCEPTION", message: String(e && e.message ? e.message : e) } });
  1630:       }
  1631:       continue;
  1632:     }
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);

===== HIT @ line 1673 (showing 1633..1753) =====
  1633: 
  1634:     if (line === "PORTFOLIO_STATUS") {
  1635:       const assetsMetaRaw = await env.AURA_KV.get(registryMetaKey("assets"));
  1636:       const domainsMetaRaw = await env.AURA_KV.get(registryMetaKey("domains"));
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 

===== HIT @ line 1677 (showing 1637..1757) =====
  1637:       const assetsMeta = assetsMetaRaw ? (safeJsonParse(assetsMetaRaw) || assetsMetaRaw) : null;
  1638:       const domainsMeta = domainsMetaRaw ? (safeJsonParse(domainsMetaRaw) || domainsMetaRaw) : null;
  1639: 
  1640:       const status = {
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);

===== HIT @ line 1681 (showing 1641..1761) =====
  1641:         build: BUILD,
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";

===== HIT @ line 1682 (showing 1642..1762) =====
  1642:         stamp: nowIso(),
  1643:         registry_version: REGISTRY_VERSION,
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;

===== HIT @ line 1684 (showing 1644..1764) =====
  1644:         registries: {
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;

===== HIT @ line 1685 (showing 1645..1765) =====
  1645:           assets: assetsMeta || { type: "assets", count: 0, updated_at: null, version: REGISTRY_VERSION },
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.

===== HIT @ line 1686 (showing 1646..1766) =====
  1646:           domains: domainsMeta || { type: "domains", count: 0, updated_at: null, version: REGISTRY_VERSION }
  1647:         }
  1648:       };
  1649:       push("PORTFOLIO_STATUS", status);
  1650:       continue;
  1651:     }
  1652: 
  1653:     if (line.startsWith("REGISTRY_PUT")) {
  1654:       if (!isOperator) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1655: 
  1656:       const args = __parseRegistryPutArgs(line, lines, i, allowedCommands);
  1657:       if (!args || !args.type || !args.item) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1658: 
  1659:       const _t = String(args.type).toLowerCase();
  1660:       const item = args.item;
  1661: 
  1662:       // Legacy convenience: allow domain puts where id omitted but domain provided.
  1663:       if ((!item.id || !String(item.id).trim()) && _t === "domains") {
  1664:         const maybe = String(item.domain || item.key || "").trim().toLowerCase();
  1665:         if (maybe) item.id = maybe;
  1666:       }
  1667: 
  1668:       if (!_t || !item || !item.id) { push("REGISTRY_PUT", "BAD_REQUEST"); continue; }
  1669: 
  1670:       const _hostToGate = __domainHostFromRegistryEntry(_t, item);
  1671:       if (_hostToGate && (_t === "domains" || _t === "assets")) {
  1672:         const _ev = await __getHostEvidence(_hostToGate);
  1673:         if (!_ev) { push("REGISTRY_PUT", "NOT_ALLOWED"); continue; }
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);

===== HIT @ line 1714 (showing 1674..1794) =====
  1674:       }
  1675: 
  1676:       const put = await registryPut(env, _t, item);
  1677:       push("REGISTRY_PUT", put);
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()

===== HIT @ line 1718 (showing 1678..1798) =====
  1678:       continue;
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }

===== HIT @ line 1719 (showing 1679..1799) =====
  1679:     }
  1680: 
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }

===== HIT @ line 1721 (showing 1681..1801) =====
  1681:     if (line.startsWith("REGISTRY_IMPORT_ASSETS")) {
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });

===== HIT @ line 1722 (showing 1682..1802) =====
  1682:       if (!isOperator) { push("REGISTRY_IMPORT_ASSETS", "NOT_ALLOWED"); continue; }
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
  1802:       push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });

===== HIT @ line 1723 (showing 1683..1803) =====
  1683: 
  1684:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_ASSETS", line, lines, i, allowedCommands);
  1685:       if (!parsedArgs) { push("REGISTRY_IMPORT_ASSETS", "BAD_REQUEST"); continue; }
  1686:       const items = parsedArgs.items;
  1687: 
  1688:       const idsBefore = await registryGetIndex(env, "assets");
  1689:       const ids = [...idsBefore];
  1690:       let upserts = 0;
  1691: 
  1692:       for (const it of items) {
  1693:         if (!it || typeof it !== "object") continue;
  1694:         const assetId = String(it.id || "").trim();
  1695:         if (!assetId) continue;
  1696:         const entry = {
  1697:           id: assetId,
  1698:           name: String(it.name || it.title || it.id || "").trim() || assetId,
  1699:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1700:           notes: String(it.notes || "").trim(),
  1701:           tags: Array.isArray(it.tags) ? it.tags : [],
  1702:           sellability: String(it.sellability || "UNKNOWN").trim(),
  1703:           patent_cluster: String(it.patent_cluster || "").trim()
  1704:         };
  1705:         const put = await registryPut(env, "assets", entry);
  1706:         if (put.ok) {
  1707:           upserts += 1;
  1708:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1709:         }
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
  1802:       push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });
  1803:       continue;

===== HIT @ line 1750 (showing 1710..1830) =====
  1710:       }
  1711: 
  1712:       await registryPutIndex(env, "assets", ids);
  1713:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "assets", details: { upserts } });
  1714:       push("REGISTRY_IMPORT_ASSETS", { ok: true, type: "assets", upserts, total_index_count: ids.length, stamp: nowIso() });
  1715:       continue;
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
  1802:       push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });
  1803:       continue;
  1804:     }
  1805: 
  1806:     if (line.startsWith("REGISTRY_GET")) {
  1807:       const args = __parseRegistryGetArgs(line, lines, i, allowedCommands);
  1808:       if (!args || !args.type || !args.id) { push("REGISTRY_GET", "BAD_REQUEST"); continue; }
  1809:       const e = await registryGet(env, args.type, args.id);
  1810:       push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
  1811:       continue;
  1812:     }
  1813: 
  1814:     if (line.startsWith("REGISTRY_LIST")) {
  1815:       const parts = line.split(" ").filter(Boolean);
  1816:       const type = String(parts[1] || "").toLowerCase();
  1817:       const limit = Number(parts[2] || 50);
  1818: 
  1819:       // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
  1820:       if (!type) {
  1821:         const types = ["assets", "domains"];
  1822:         const overview = {};
  1823:         for (const t of types) {
  1824:           try {
  1825:             const ids = await registryGetIndex(env, t);
  1826:             overview[t] = { type: t, count: ids.length };
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }

===== HIT @ line 1756 (showing 1716..1836) =====
  1716:     }
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
  1802:       push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });
  1803:       continue;
  1804:     }
  1805: 
  1806:     if (line.startsWith("REGISTRY_GET")) {
  1807:       const args = __parseRegistryGetArgs(line, lines, i, allowedCommands);
  1808:       if (!args || !args.type || !args.id) { push("REGISTRY_GET", "BAD_REQUEST"); continue; }
  1809:       const e = await registryGet(env, args.type, args.id);
  1810:       push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
  1811:       continue;
  1812:     }
  1813: 
  1814:     if (line.startsWith("REGISTRY_LIST")) {
  1815:       const parts = line.split(" ").filter(Boolean);
  1816:       const type = String(parts[1] || "").toLowerCase();
  1817:       const limit = Number(parts[2] || 50);
  1818: 
  1819:       // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
  1820:       if (!type) {
  1821:         const types = ["assets", "domains"];
  1822:         const overview = {};
  1823:         for (const t of types) {
  1824:           try {
  1825:             const ids = await registryGetIndex(env, t);
  1826:             overview[t] = { type: t, count: ids.length };
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }
  1831:         push("REGISTRY_LIST", { registries: overview });
  1832:         continue;
  1833:       }
  1834: 
  1835:       const payload = await registryList(env, type, limit);
  1836:       push(`REGISTRY_LIST ${type}`, payload);

===== HIT @ line 1757 (showing 1717..1837) =====
  1717: 
  1718:     if (line.startsWith("REGISTRY_IMPORT_DOMAINS")) {
  1719:       if (!isOperator) { push("REGISTRY_IMPORT_DOMAINS", "NOT_ALLOWED"); continue; }
  1720: 
  1721:       const parsedArgs = __parseRegistryImportArgs("REGISTRY_IMPORT_DOMAINS", line, lines, i, allowedCommands);
  1722:       if (!parsedArgs) { push("REGISTRY_IMPORT_DOMAINS", "BAD_REQUEST"); continue; }
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
  1802:       push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });
  1803:       continue;
  1804:     }
  1805: 
  1806:     if (line.startsWith("REGISTRY_GET")) {
  1807:       const args = __parseRegistryGetArgs(line, lines, i, allowedCommands);
  1808:       if (!args || !args.type || !args.id) { push("REGISTRY_GET", "BAD_REQUEST"); continue; }
  1809:       const e = await registryGet(env, args.type, args.id);
  1810:       push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
  1811:       continue;
  1812:     }
  1813: 
  1814:     if (line.startsWith("REGISTRY_LIST")) {
  1815:       const parts = line.split(" ").filter(Boolean);
  1816:       const type = String(parts[1] || "").toLowerCase();
  1817:       const limit = Number(parts[2] || 50);
  1818: 
  1819:       // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
  1820:       if (!type) {
  1821:         const types = ["assets", "domains"];
  1822:         const overview = {};
  1823:         for (const t of types) {
  1824:           try {
  1825:             const ids = await registryGetIndex(env, t);
  1826:             overview[t] = { type: t, count: ids.length };
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }
  1831:         push("REGISTRY_LIST", { registries: overview });
  1832:         continue;
  1833:       }
  1834: 
  1835:       const payload = await registryList(env, type, limit);
  1836:       push(`REGISTRY_LIST ${type}`, payload);
  1837:       continue;

===== HIT @ line 1763 (showing 1723..1843) =====
  1723:       const items = parsedArgs.items;
  1724: 
  1725:       const idsBefore = await registryGetIndex(env, "domains");
  1726:       const ids = [...idsBefore];
  1727:       let upserts = 0;
  1728: 
  1729:       for (const it of items) {
  1730:         if (!it || typeof it !== "object") continue;
  1731:         const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1732:         if (!domainId) continue;
  1733:         const entry = {
  1734:           id: domainId,
  1735:           domain: String(it.domain || it.id || domainId).toLowerCase(),
  1736:           pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1737:           purpose: String(it.purpose || it.notes || "").trim(),
  1738:           priority: String(it.priority || "UNKNOWN").trim(),
  1739:           status: String(it.status || "UNKNOWN").trim()
  1740:         };
  1741:         const put = await registryPut(env, "domains", entry);
  1742:         if (put.ok) {
  1743:           upserts += 1;
  1744:           if (!ids.includes(entry.id)) ids.push(entry.id);
  1745:         }
  1746:       }
  1747: 
  1748:       await registryPutIndex(env, "domains", ids);
  1749:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: "domains", details: { upserts } });
  1750:       push("REGISTRY_IMPORT_DOMAINS", { ok: true, type: "domains", upserts, total_index_count: ids.length, stamp: nowIso() });
  1751:       continue;
  1752:     }
  1753: 
  1754:     if (line.startsWith("REGISTRY_IMPORT ")) {
  1755:       if (!isOperator) { push("REGISTRY_IMPORT", "NOT_ALLOWED"); continue; }
  1756:       const jsonPart = line.slice("REGISTRY_IMPORT ".length).trim();
  1757:       const payload = safeJsonParse(jsonPart);
  1758:       const typeName = String(payload?.type || "").toLowerCase().trim();
  1759:       const normalized =
  1760:         typeName === "asset" || typeName === "assets" ? "assets" :
  1761:         typeName === "domain" || typeName === "domains" ? "domains" : "";
  1762:       const items = Array.isArray(payload?.items) ? payload.items : null;
  1763:       if (!normalized || !items) { push("REGISTRY_IMPORT", "BAD_REQUEST"); continue; }
  1764:       // Reuse the same import core logic by calling the generic function already defined below via registryPut loops would be verbose;
  1765:       // keep simple: write through registryPut in a tight loop.
  1766:       const idsBefore = await registryGetIndex(env, normalized);
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
  1802:       push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });
  1803:       continue;
  1804:     }
  1805: 
  1806:     if (line.startsWith("REGISTRY_GET")) {
  1807:       const args = __parseRegistryGetArgs(line, lines, i, allowedCommands);
  1808:       if (!args || !args.type || !args.id) { push("REGISTRY_GET", "BAD_REQUEST"); continue; }
  1809:       const e = await registryGet(env, args.type, args.id);
  1810:       push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
  1811:       continue;
  1812:     }
  1813: 
  1814:     if (line.startsWith("REGISTRY_LIST")) {
  1815:       const parts = line.split(" ").filter(Boolean);
  1816:       const type = String(parts[1] || "").toLowerCase();
  1817:       const limit = Number(parts[2] || 50);
  1818: 
  1819:       // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
  1820:       if (!type) {
  1821:         const types = ["assets", "domains"];
  1822:         const overview = {};
  1823:         for (const t of types) {
  1824:           try {
  1825:             const ids = await registryGetIndex(env, t);
  1826:             overview[t] = { type: t, count: ids.length };
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }
  1831:         push("REGISTRY_LIST", { registries: overview });
  1832:         continue;
  1833:       }
  1834: 
  1835:       const payload = await registryList(env, type, limit);
  1836:       push(`REGISTRY_LIST ${type}`, payload);
  1837:       continue;
  1838:     }
  1839: 
  1840:     if (line.startsWith("REGISTRY_FILTER")) {
  1841:       const raw = line.slice("REGISTRY_FILTER".length).trim();
  1842:       let type = "";
  1843:       let field = "";

===== HIT @ line 1807 (showing 1767..1887) =====
  1767:       const ids = [...idsBefore];
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
  1802:       push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });
  1803:       continue;
  1804:     }
  1805: 
  1806:     if (line.startsWith("REGISTRY_GET")) {
  1807:       const args = __parseRegistryGetArgs(line, lines, i, allowedCommands);
  1808:       if (!args || !args.type || !args.id) { push("REGISTRY_GET", "BAD_REQUEST"); continue; }
  1809:       const e = await registryGet(env, args.type, args.id);
  1810:       push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
  1811:       continue;
  1812:     }
  1813: 
  1814:     if (line.startsWith("REGISTRY_LIST")) {
  1815:       const parts = line.split(" ").filter(Boolean);
  1816:       const type = String(parts[1] || "").toLowerCase();
  1817:       const limit = Number(parts[2] || 50);
  1818: 
  1819:       // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
  1820:       if (!type) {
  1821:         const types = ["assets", "domains"];
  1822:         const overview = {};
  1823:         for (const t of types) {
  1824:           try {
  1825:             const ids = await registryGetIndex(env, t);
  1826:             overview[t] = { type: t, count: ids.length };
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }
  1831:         push("REGISTRY_LIST", { registries: overview });
  1832:         continue;
  1833:       }
  1834: 
  1835:       const payload = await registryList(env, type, limit);
  1836:       push(`REGISTRY_LIST ${type}`, payload);
  1837:       continue;
  1838:     }
  1839: 
  1840:     if (line.startsWith("REGISTRY_FILTER")) {
  1841:       const raw = line.slice("REGISTRY_FILTER".length).trim();
  1842:       let type = "";
  1843:       let field = "";
  1844:       let value = "";
  1845:       let limit = 50;
  1846:       let where = null;
  1847: 
  1848:       if (raw.startsWith("{")) {
  1849:         const obj = safeJsonParse(raw);
  1850:         if (!obj || typeof obj !== "object") { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1851:         type = String(obj.type || "").toLowerCase();
  1852:         limit = Number(obj.limit || 50);
  1853:         if (obj.where && typeof obj.where === "object") {
  1854:           where = obj.where;
  1855:         } else {
  1856:           field = String(obj.field || "").trim();
  1857:           value = String(obj.value ?? "").trim();
  1858:         }
  1859:       } else {
  1860:         const parts = line.split(" ").filter(Boolean);
  1861:         type = String(parts[1] || "").toLowerCase();
  1862:         field = String(parts[2] || "").trim();
  1863:         value = String(parts[3] || "").trim();
  1864:         limit = Number(parts[4] || 50);
  1865:       }
  1866: 
  1867:       if (!type) { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1868:       const payload = where
  1869:         ? await registryFilterWhere(env, type, where, limit)
  1870:         : await registryFilter(env, type, field, value, limit);
  1871: 
  1872:       // Allow "REGISTRY_FILTER <type>" (no field/value) as a convenience alias for listing that type
  1873:       if (!where && (!field || !value)) {
  1874:         const payload2 = await registryList(env, type, limit);
  1875:         push(`REGISTRY_FILTER ${type}`, payload2);
  1876:         continue;
  1877:       }
  1878: 
  1879:       push(`REGISTRY_FILTER ${type}`, payload);
  1880:       continue;
  1881:     }
  1882: 
  1883:     if (line.startsWith("HOST_CAPS_GET")) {
  1884:       const parts = line.split(" ").filter(Boolean);
  1885:       const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1886:       const caps = await getHostCaps(host);
  1887:       push("HOST_CAPS_GET", caps || { host, allowed: null });

===== HIT @ line 1808 (showing 1768..1888) =====
  1768:       let upserts = 0;
  1769:       for (const it of items) {
  1770:         if (!it || typeof it !== "object") continue;
  1771:         if (normalized === "domains") {
  1772:           const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  1773:           if (!domainId) continue;
  1774:           const entry = {
  1775:             id: domainId,
  1776:             domain: String(it.domain || it.id || domainId).toLowerCase(),
  1777:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1778:             purpose: String(it.purpose || it.notes || "").trim(),
  1779:             priority: String(it.priority || "UNKNOWN").trim(),
  1780:             status: String(it.status || "UNKNOWN").trim()
  1781:           };
  1782:           const put = await registryPut(env, "domains", entry);
  1783:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1784:         } else {
  1785:           const assetId = String(it.id || "").trim();
  1786:           if (!assetId) continue;
  1787:           const entry = {
  1788:             id: assetId,
  1789:             name: String(it.name || it.title || it.id || "").trim() || assetId,
  1790:             pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  1791:             notes: String(it.notes || "").trim(),
  1792:             tags: Array.isArray(it.tags) ? it.tags : [],
  1793:             sellability: String(it.sellability || "UNKNOWN").trim(),
  1794:             patent_cluster: String(it.patent_cluster || "").trim()
  1795:           };
  1796:           const put = await registryPut(env, "assets", entry);
  1797:           if (put.ok) { upserts += 1; if (!ids.includes(entry.id)) ids.push(entry.id); }
  1798:         }
  1799:       }
  1800:       await registryPutIndex(env, normalized, ids);
  1801:       await auditWrite(env, { action: "REGISTRY_IMPORT", type: normalized, details: { upserts } });
  1802:       push("REGISTRY_IMPORT", { ok: true, type: normalized, upserts, total_index_count: ids.length, stamp: nowIso() });
  1803:       continue;
  1804:     }
  1805: 
  1806:     if (line.startsWith("REGISTRY_GET")) {
  1807:       const args = __parseRegistryGetArgs(line, lines, i, allowedCommands);
  1808:       if (!args || !args.type || !args.id) { push("REGISTRY_GET", "BAD_REQUEST"); continue; }
  1809:       const e = await registryGet(env, args.type, args.id);
  1810:       push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
  1811:       continue;
  1812:     }
  1813: 
  1814:     if (line.startsWith("REGISTRY_LIST")) {
  1815:       const parts = line.split(" ").filter(Boolean);
  1816:       const type = String(parts[1] || "").toLowerCase();
  1817:       const limit = Number(parts[2] || 50);
  1818: 
  1819:       // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
  1820:       if (!type) {
  1821:         const types = ["assets", "domains"];
  1822:         const overview = {};
  1823:         for (const t of types) {
  1824:           try {
  1825:             const ids = await registryGetIndex(env, t);
  1826:             overview[t] = { type: t, count: ids.length };
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }
  1831:         push("REGISTRY_LIST", { registries: overview });
  1832:         continue;
  1833:       }
  1834: 
  1835:       const payload = await registryList(env, type, limit);
  1836:       push(`REGISTRY_LIST ${type}`, payload);
  1837:       continue;
  1838:     }
  1839: 
  1840:     if (line.startsWith("REGISTRY_FILTER")) {
  1841:       const raw = line.slice("REGISTRY_FILTER".length).trim();
  1842:       let type = "";
  1843:       let field = "";
  1844:       let value = "";
  1845:       let limit = 50;
  1846:       let where = null;
  1847: 
  1848:       if (raw.startsWith("{")) {
  1849:         const obj = safeJsonParse(raw);
  1850:         if (!obj || typeof obj !== "object") { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1851:         type = String(obj.type || "").toLowerCase();
  1852:         limit = Number(obj.limit || 50);
  1853:         if (obj.where && typeof obj.where === "object") {
  1854:           where = obj.where;
  1855:         } else {
  1856:           field = String(obj.field || "").trim();
  1857:           value = String(obj.value ?? "").trim();
  1858:         }
  1859:       } else {
  1860:         const parts = line.split(" ").filter(Boolean);
  1861:         type = String(parts[1] || "").toLowerCase();
  1862:         field = String(parts[2] || "").trim();
  1863:         value = String(parts[3] || "").trim();
  1864:         limit = Number(parts[4] || 50);
  1865:       }
  1866: 
  1867:       if (!type) { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1868:       const payload = where
  1869:         ? await registryFilterWhere(env, type, where, limit)
  1870:         : await registryFilter(env, type, field, value, limit);
  1871: 
  1872:       // Allow "REGISTRY_FILTER <type>" (no field/value) as a convenience alias for listing that type
  1873:       if (!where && (!field || !value)) {
  1874:         const payload2 = await registryList(env, type, limit);
  1875:         push(`REGISTRY_FILTER ${type}`, payload2);
  1876:         continue;
  1877:       }
  1878: 
  1879:       push(`REGISTRY_FILTER ${type}`, payload);
  1880:       continue;
  1881:     }
  1882: 
  1883:     if (line.startsWith("HOST_CAPS_GET")) {
  1884:       const parts = line.split(" ").filter(Boolean);
  1885:       const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1886:       const caps = await getHostCaps(host);
  1887:       push("HOST_CAPS_GET", caps || { host, allowed: null });
  1888:       continue;

===== HIT @ line 1849 (showing 1809..1929) =====
  1809:       const e = await registryGet(env, args.type, args.id);
  1810:       push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
  1811:       continue;
  1812:     }
  1813: 
  1814:     if (line.startsWith("REGISTRY_LIST")) {
  1815:       const parts = line.split(" ").filter(Boolean);
  1816:       const type = String(parts[1] || "").toLowerCase();
  1817:       const limit = Number(parts[2] || 50);
  1818: 
  1819:       // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
  1820:       if (!type) {
  1821:         const types = ["assets", "domains"];
  1822:         const overview = {};
  1823:         for (const t of types) {
  1824:           try {
  1825:             const ids = await registryGetIndex(env, t);
  1826:             overview[t] = { type: t, count: ids.length };
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }
  1831:         push("REGISTRY_LIST", { registries: overview });
  1832:         continue;
  1833:       }
  1834: 
  1835:       const payload = await registryList(env, type, limit);
  1836:       push(`REGISTRY_LIST ${type}`, payload);
  1837:       continue;
  1838:     }
  1839: 
  1840:     if (line.startsWith("REGISTRY_FILTER")) {
  1841:       const raw = line.slice("REGISTRY_FILTER".length).trim();
  1842:       let type = "";
  1843:       let field = "";
  1844:       let value = "";
  1845:       let limit = 50;
  1846:       let where = null;
  1847: 
  1848:       if (raw.startsWith("{")) {
  1849:         const obj = safeJsonParse(raw);
  1850:         if (!obj || typeof obj !== "object") { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1851:         type = String(obj.type || "").toLowerCase();
  1852:         limit = Number(obj.limit || 50);
  1853:         if (obj.where && typeof obj.where === "object") {
  1854:           where = obj.where;
  1855:         } else {
  1856:           field = String(obj.field || "").trim();
  1857:           value = String(obj.value ?? "").trim();
  1858:         }
  1859:       } else {
  1860:         const parts = line.split(" ").filter(Boolean);
  1861:         type = String(parts[1] || "").toLowerCase();
  1862:         field = String(parts[2] || "").trim();
  1863:         value = String(parts[3] || "").trim();
  1864:         limit = Number(parts[4] || 50);
  1865:       }
  1866: 
  1867:       if (!type) { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1868:       const payload = where
  1869:         ? await registryFilterWhere(env, type, where, limit)
  1870:         : await registryFilter(env, type, field, value, limit);
  1871: 
  1872:       // Allow "REGISTRY_FILTER <type>" (no field/value) as a convenience alias for listing that type
  1873:       if (!where && (!field || !value)) {
  1874:         const payload2 = await registryList(env, type, limit);
  1875:         push(`REGISTRY_FILTER ${type}`, payload2);
  1876:         continue;
  1877:       }
  1878: 
  1879:       push(`REGISTRY_FILTER ${type}`, payload);
  1880:       continue;
  1881:     }
  1882: 
  1883:     if (line.startsWith("HOST_CAPS_GET")) {
  1884:       const parts = line.split(" ").filter(Boolean);
  1885:       const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1886:       const caps = await getHostCaps(host);
  1887:       push("HOST_CAPS_GET", caps || { host, allowed: null });
  1888:       continue;
  1889:     }
  1890: 
  1891:     if (line === "SNAPSHOT_STATE") {
  1892:       const safeHost = activeHost || "none";
  1893:       const caps = await getHostCaps(activeHost);
  1894: 
  1895:       const snapshot = {
  1896:         build: BUILD,
  1897:         stamp: new Date().toISOString(),
  1898:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  1899:         active_host: safeHost,
  1900:         host_caps: caps || null,
  1901:         evidence_present_for_active_host: activeHost
  1902:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  1903:           : false,
  1904:         autonomy_tick: (await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null)) || null
  1905:       };
  1906:       push("SNAPSHOT_STATE", snapshot);
  1907:       continue;
  1908:     }
  1909: 
  1910:     
  1911: 
  1912:     
  1913: if (line === "HERD_STATUS") {
  1914:   let herd = null;
  1915:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1916:   push("HERD_STATUS", { ok: true, host: (activeHost || null), herd_config: herd || null, stamp: new Date().toISOString() });
  1917:   continue;
  1918: }
  1919: if (line === "HERD_SELF_TEST") {
  1920:   push("HERD_SELF_TEST", { ok: true, tests: [{ name: "command_wired", pass: true }], stamp: new Date().toISOString() });
  1921:   continue;
  1922: }
  1923: if (line.startsWith("HERD_SWEEP")) {
  1924:   const raw = line.slice("HERD_SWEEP".length).trim();
  1925:   const args = raw ? safeJsonParse(raw) : null;
  1926: 
  1927:   let herd = null;
  1928:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1929: 

===== HIT @ line 1850 (showing 1810..1930) =====
  1810:       push(`REGISTRY_GET ${args.type} ${args.id}`, e ? e : "MISSING");
  1811:       continue;
  1812:     }
  1813: 
  1814:     if (line.startsWith("REGISTRY_LIST")) {
  1815:       const parts = line.split(" ").filter(Boolean);
  1816:       const type = String(parts[1] || "").toLowerCase();
  1817:       const limit = Number(parts[2] || 50);
  1818: 
  1819:       // Allow bare REGISTRY_LIST to return an overview (useful for autonomy flows)
  1820:       if (!type) {
  1821:         const types = ["assets", "domains"];
  1822:         const overview = {};
  1823:         for (const t of types) {
  1824:           try {
  1825:             const ids = await registryGetIndex(env, t);
  1826:             overview[t] = { type: t, count: ids.length };
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }
  1831:         push("REGISTRY_LIST", { registries: overview });
  1832:         continue;
  1833:       }
  1834: 
  1835:       const payload = await registryList(env, type, limit);
  1836:       push(`REGISTRY_LIST ${type}`, payload);
  1837:       continue;
  1838:     }
  1839: 
  1840:     if (line.startsWith("REGISTRY_FILTER")) {
  1841:       const raw = line.slice("REGISTRY_FILTER".length).trim();
  1842:       let type = "";
  1843:       let field = "";
  1844:       let value = "";
  1845:       let limit = 50;
  1846:       let where = null;
  1847: 
  1848:       if (raw.startsWith("{")) {
  1849:         const obj = safeJsonParse(raw);
  1850:         if (!obj || typeof obj !== "object") { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1851:         type = String(obj.type || "").toLowerCase();
  1852:         limit = Number(obj.limit || 50);
  1853:         if (obj.where && typeof obj.where === "object") {
  1854:           where = obj.where;
  1855:         } else {
  1856:           field = String(obj.field || "").trim();
  1857:           value = String(obj.value ?? "").trim();
  1858:         }
  1859:       } else {
  1860:         const parts = line.split(" ").filter(Boolean);
  1861:         type = String(parts[1] || "").toLowerCase();
  1862:         field = String(parts[2] || "").trim();
  1863:         value = String(parts[3] || "").trim();
  1864:         limit = Number(parts[4] || 50);
  1865:       }
  1866: 
  1867:       if (!type) { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1868:       const payload = where
  1869:         ? await registryFilterWhere(env, type, where, limit)
  1870:         : await registryFilter(env, type, field, value, limit);
  1871: 
  1872:       // Allow "REGISTRY_FILTER <type>" (no field/value) as a convenience alias for listing that type
  1873:       if (!where && (!field || !value)) {
  1874:         const payload2 = await registryList(env, type, limit);
  1875:         push(`REGISTRY_FILTER ${type}`, payload2);
  1876:         continue;
  1877:       }
  1878: 
  1879:       push(`REGISTRY_FILTER ${type}`, payload);
  1880:       continue;
  1881:     }
  1882: 
  1883:     if (line.startsWith("HOST_CAPS_GET")) {
  1884:       const parts = line.split(" ").filter(Boolean);
  1885:       const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1886:       const caps = await getHostCaps(host);
  1887:       push("HOST_CAPS_GET", caps || { host, allowed: null });
  1888:       continue;
  1889:     }
  1890: 
  1891:     if (line === "SNAPSHOT_STATE") {
  1892:       const safeHost = activeHost || "none";
  1893:       const caps = await getHostCaps(activeHost);
  1894: 
  1895:       const snapshot = {
  1896:         build: BUILD,
  1897:         stamp: new Date().toISOString(),
  1898:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  1899:         active_host: safeHost,
  1900:         host_caps: caps || null,
  1901:         evidence_present_for_active_host: activeHost
  1902:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  1903:           : false,
  1904:         autonomy_tick: (await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null)) || null
  1905:       };
  1906:       push("SNAPSHOT_STATE", snapshot);
  1907:       continue;
  1908:     }
  1909: 
  1910:     
  1911: 
  1912:     
  1913: if (line === "HERD_STATUS") {
  1914:   let herd = null;
  1915:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1916:   push("HERD_STATUS", { ok: true, host: (activeHost || null), herd_config: herd || null, stamp: new Date().toISOString() });
  1917:   continue;
  1918: }
  1919: if (line === "HERD_SELF_TEST") {
  1920:   push("HERD_SELF_TEST", { ok: true, tests: [{ name: "command_wired", pass: true }], stamp: new Date().toISOString() });
  1921:   continue;
  1922: }
  1923: if (line.startsWith("HERD_SWEEP")) {
  1924:   const raw = line.slice("HERD_SWEEP".length).trim();
  1925:   const args = raw ? safeJsonParse(raw) : null;
  1926: 
  1927:   let herd = null;
  1928:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1929: 
  1930:   const defaultHosts = (herd && typeof herd === "object" && Array.isArray(herd.hosts)) ? herd.hosts : [];

===== HIT @ line 1867 (showing 1827..1947) =====
  1827:           } catch (e) {
  1828:             overview[t] = { type: t, count: null, error: String(e && e.message ? e.message : e) };
  1829:           }
  1830:         }
  1831:         push("REGISTRY_LIST", { registries: overview });
  1832:         continue;
  1833:       }
  1834: 
  1835:       const payload = await registryList(env, type, limit);
  1836:       push(`REGISTRY_LIST ${type}`, payload);
  1837:       continue;
  1838:     }
  1839: 
  1840:     if (line.startsWith("REGISTRY_FILTER")) {
  1841:       const raw = line.slice("REGISTRY_FILTER".length).trim();
  1842:       let type = "";
  1843:       let field = "";
  1844:       let value = "";
  1845:       let limit = 50;
  1846:       let where = null;
  1847: 
  1848:       if (raw.startsWith("{")) {
  1849:         const obj = safeJsonParse(raw);
  1850:         if (!obj || typeof obj !== "object") { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1851:         type = String(obj.type || "").toLowerCase();
  1852:         limit = Number(obj.limit || 50);
  1853:         if (obj.where && typeof obj.where === "object") {
  1854:           where = obj.where;
  1855:         } else {
  1856:           field = String(obj.field || "").trim();
  1857:           value = String(obj.value ?? "").trim();
  1858:         }
  1859:       } else {
  1860:         const parts = line.split(" ").filter(Boolean);
  1861:         type = String(parts[1] || "").toLowerCase();
  1862:         field = String(parts[2] || "").trim();
  1863:         value = String(parts[3] || "").trim();
  1864:         limit = Number(parts[4] || 50);
  1865:       }
  1866: 
  1867:       if (!type) { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1868:       const payload = where
  1869:         ? await registryFilterWhere(env, type, where, limit)
  1870:         : await registryFilter(env, type, field, value, limit);
  1871: 
  1872:       // Allow "REGISTRY_FILTER <type>" (no field/value) as a convenience alias for listing that type
  1873:       if (!where && (!field || !value)) {
  1874:         const payload2 = await registryList(env, type, limit);
  1875:         push(`REGISTRY_FILTER ${type}`, payload2);
  1876:         continue;
  1877:       }
  1878: 
  1879:       push(`REGISTRY_FILTER ${type}`, payload);
  1880:       continue;
  1881:     }
  1882: 
  1883:     if (line.startsWith("HOST_CAPS_GET")) {
  1884:       const parts = line.split(" ").filter(Boolean);
  1885:       const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1886:       const caps = await getHostCaps(host);
  1887:       push("HOST_CAPS_GET", caps || { host, allowed: null });
  1888:       continue;
  1889:     }
  1890: 
  1891:     if (line === "SNAPSHOT_STATE") {
  1892:       const safeHost = activeHost || "none";
  1893:       const caps = await getHostCaps(activeHost);
  1894: 
  1895:       const snapshot = {
  1896:         build: BUILD,
  1897:         stamp: new Date().toISOString(),
  1898:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  1899:         active_host: safeHost,
  1900:         host_caps: caps || null,
  1901:         evidence_present_for_active_host: activeHost
  1902:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  1903:           : false,
  1904:         autonomy_tick: (await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null)) || null
  1905:       };
  1906:       push("SNAPSHOT_STATE", snapshot);
  1907:       continue;
  1908:     }
  1909: 
  1910:     
  1911: 
  1912:     
  1913: if (line === "HERD_STATUS") {
  1914:   let herd = null;
  1915:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1916:   push("HERD_STATUS", { ok: true, host: (activeHost || null), herd_config: herd || null, stamp: new Date().toISOString() });
  1917:   continue;
  1918: }
  1919: if (line === "HERD_SELF_TEST") {
  1920:   push("HERD_SELF_TEST", { ok: true, tests: [{ name: "command_wired", pass: true }], stamp: new Date().toISOString() });
  1921:   continue;
  1922: }
  1923: if (line.startsWith("HERD_SWEEP")) {
  1924:   const raw = line.slice("HERD_SWEEP".length).trim();
  1925:   const args = raw ? safeJsonParse(raw) : null;
  1926: 
  1927:   let herd = null;
  1928:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1929: 
  1930:   const defaultHosts = (herd && typeof herd === "object" && Array.isArray(herd.hosts)) ? herd.hosts : [];
  1931:   const hosts = (args && typeof args === "object" && Array.isArray(args.hosts)) ? args.hosts : defaultHosts;
  1932:   const limit = (args && typeof args === "object" && typeof args.limit === "number" && args.limit > 0)
  1933:     ? Math.floor(args.limit)
  1934:     : hosts.length;
  1935: 
  1936:   const targets = hosts.slice(0, limit).map((h) => {
  1937:     const hostStr = String(h).trim();
  1938:     return { host: hostStr, url: `https://${hostStr}/` };
  1939:   });
  1940: 
  1941:   const results = [];
  1942:   for (const t of targets) {
  1943:     try {
  1944:       const evidence = await doVerifiedFetch(t.url);
  1945:       results.push({ host: t.host, url: t.url, ok: true, evidence });
  1946: 
  1947:       // Persist latest sweep into registry (no flags; evidence-driven).

===== HIT @ line 1904 (showing 1864..1984) =====
  1864:         limit = Number(parts[4] || 50);
  1865:       }
  1866: 
  1867:       if (!type) { push("REGISTRY_FILTER", "BAD_REQUEST"); continue; }
  1868:       const payload = where
  1869:         ? await registryFilterWhere(env, type, where, limit)
  1870:         : await registryFilter(env, type, field, value, limit);
  1871: 
  1872:       // Allow "REGISTRY_FILTER <type>" (no field/value) as a convenience alias for listing that type
  1873:       if (!where && (!field || !value)) {
  1874:         const payload2 = await registryList(env, type, limit);
  1875:         push(`REGISTRY_FILTER ${type}`, payload2);
  1876:         continue;
  1877:       }
  1878: 
  1879:       push(`REGISTRY_FILTER ${type}`, payload);
  1880:       continue;
  1881:     }
  1882: 
  1883:     if (line.startsWith("HOST_CAPS_GET")) {
  1884:       const parts = line.split(" ").filter(Boolean);
  1885:       const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1886:       const caps = await getHostCaps(host);
  1887:       push("HOST_CAPS_GET", caps || { host, allowed: null });
  1888:       continue;
  1889:     }
  1890: 
  1891:     if (line === "SNAPSHOT_STATE") {
  1892:       const safeHost = activeHost || "none";
  1893:       const caps = await getHostCaps(activeHost);
  1894: 
  1895:       const snapshot = {
  1896:         build: BUILD,
  1897:         stamp: new Date().toISOString(),
  1898:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  1899:         active_host: safeHost,
  1900:         host_caps: caps || null,
  1901:         evidence_present_for_active_host: activeHost
  1902:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  1903:           : false,
  1904:         autonomy_tick: (await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null)) || null
  1905:       };
  1906:       push("SNAPSHOT_STATE", snapshot);
  1907:       continue;
  1908:     }
  1909: 
  1910:     
  1911: 
  1912:     
  1913: if (line === "HERD_STATUS") {
  1914:   let herd = null;
  1915:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1916:   push("HERD_STATUS", { ok: true, host: (activeHost || null), herd_config: herd || null, stamp: new Date().toISOString() });
  1917:   continue;
  1918: }
  1919: if (line === "HERD_SELF_TEST") {
  1920:   push("HERD_SELF_TEST", { ok: true, tests: [{ name: "command_wired", pass: true }], stamp: new Date().toISOString() });
  1921:   continue;
  1922: }
  1923: if (line.startsWith("HERD_SWEEP")) {
  1924:   const raw = line.slice("HERD_SWEEP".length).trim();
  1925:   const args = raw ? safeJsonParse(raw) : null;
  1926: 
  1927:   let herd = null;
  1928:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1929: 
  1930:   const defaultHosts = (herd && typeof herd === "object" && Array.isArray(herd.hosts)) ? herd.hosts : [];
  1931:   const hosts = (args && typeof args === "object" && Array.isArray(args.hosts)) ? args.hosts : defaultHosts;
  1932:   const limit = (args && typeof args === "object" && typeof args.limit === "number" && args.limit > 0)
  1933:     ? Math.floor(args.limit)
  1934:     : hosts.length;
  1935: 
  1936:   const targets = hosts.slice(0, limit).map((h) => {
  1937:     const hostStr = String(h).trim();
  1938:     return { host: hostStr, url: `https://${hostStr}/` };
  1939:   });
  1940: 
  1941:   const results = [];
  1942:   for (const t of targets) {
  1943:     try {
  1944:       const evidence = await doVerifiedFetch(t.url);
  1945:       results.push({ host: t.host, url: t.url, ok: true, evidence });
  1946: 
  1947:       // Persist latest sweep into registry (no flags; evidence-driven).
  1948:       // Writes:
  1949:       // - domain_sweep_latest:<host>  (summary)
  1950:       // - domains:<host>             (notes_sweep_latest pointer)
  1951:       try {
  1952:         if (evidence && evidence.ok) {
  1953:           const h = String(t.host || "").trim().toLowerCase();
  1954:           const diag = (evidence.diagnostics && typeof evidence.diagnostics === "object") ? evidence.diagnostics : {};
  1955:           const cf = (diag.cf && typeof diag.cf === "object") ? diag.cf : null;
  1956: 
  1957:           const sweepLatest = {
  1958:             id: h,
  1959:             host: h,
  1960:             url: evidence.public_url || evidence.url || t.url,
  1961:             probe_url: evidence.probe_url || null,
  1962:             fallback_reason: evidence.fallback_reason || null,
  1963:             http_status: typeof evidence.http_status === "number" ? evidence.http_status : 0,
  1964:             first_line_html: typeof evidence.first_line_html === "string" ? evidence.first_line_html : "",
  1965:             body_length: typeof evidence.body_length === "number" ? evidence.body_length : 0,
  1966:             ts: diag.ts || nowIso(),
  1967:             https_status: (typeof diag.https_status === "number") ? diag.https_status : null,
  1968:             cf: cf ? {
  1969:               colo: cf.colo || null,
  1970:               asn: cf.asn || null,
  1971:               asOrganization: cf.asOrganization || null,
  1972:               country: cf.country || null,
  1973:               regionCode: cf.regionCode || null,
  1974:               city: cf.city || null,
  1975:               timezone: cf.timezone || null
  1976:             } : null
  1977:           };
  1978: 
  1979:           await registryPut(env, "domain_sweep_latest", sweepLatest);
  1980: 
  1981:           const dom = (await registryGet(env, "domains", h)) || { id: h, domain: h };
  1982:           const merged = {
  1983:             ...dom,
  1984:             id: h,

===== HIT @ line 1925 (showing 1885..2005) =====
  1885:       const host = (parts[1] || activeHost || "frontdesk.network").toLowerCase();
  1886:       const caps = await getHostCaps(host);
  1887:       push("HOST_CAPS_GET", caps || { host, allowed: null });
  1888:       continue;
  1889:     }
  1890: 
  1891:     if (line === "SNAPSHOT_STATE") {
  1892:       const safeHost = activeHost || "none";
  1893:       const caps = await getHostCaps(activeHost);
  1894: 
  1895:       const snapshot = {
  1896:         build: BUILD,
  1897:         stamp: new Date().toISOString(),
  1898:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  1899:         active_host: safeHost,
  1900:         host_caps: caps || null,
  1901:         evidence_present_for_active_host: activeHost
  1902:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  1903:           : false,
  1904:         autonomy_tick: (await env.AURA_KV.get(autonomyTickKey, { type: "json" }).catch(()=>null)) || null
  1905:       };
  1906:       push("SNAPSHOT_STATE", snapshot);
  1907:       continue;
  1908:     }
  1909: 
  1910:     
  1911: 
  1912:     
  1913: if (line === "HERD_STATUS") {
  1914:   let herd = null;
  1915:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1916:   push("HERD_STATUS", { ok: true, host: (activeHost || null), herd_config: herd || null, stamp: new Date().toISOString() });
  1917:   continue;
  1918: }
  1919: if (line === "HERD_SELF_TEST") {
  1920:   push("HERD_SELF_TEST", { ok: true, tests: [{ name: "command_wired", pass: true }], stamp: new Date().toISOString() });
  1921:   continue;
  1922: }
  1923: if (line.startsWith("HERD_SWEEP")) {
  1924:   const raw = line.slice("HERD_SWEEP".length).trim();
  1925:   const args = raw ? safeJsonParse(raw) : null;
  1926: 
  1927:   let herd = null;
  1928:   try { herd = await registryGet(env, "config", "herd.hosts"); } catch (_) {}
  1929: 
  1930:   const defaultHosts = (herd && typeof herd === "object" && Array.isArray(herd.hosts)) ? herd.hosts : [];
  1931:   const hosts = (args && typeof args === "object" && Array.isArray(args.hosts)) ? args.hosts : defaultHosts;
  1932:   const limit = (args && typeof args === "object" && typeof args.limit === "number" && args.limit > 0)
  1933:     ? Math.floor(args.limit)
  1934:     : hosts.length;
  1935: 
  1936:   const targets = hosts.slice(0, limit).map((h) => {
  1937:     const hostStr = String(h).trim();
  1938:     return { host: hostStr, url: `https://${hostStr}/` };
  1939:   });
  1940: 
  1941:   const results = [];
  1942:   for (const t of targets) {
  1943:     try {
  1944:       const evidence = await doVerifiedFetch(t.url);
  1945:       results.push({ host: t.host, url: t.url, ok: true, evidence });
  1946: 
  1947:       // Persist latest sweep into registry (no flags; evidence-driven).
  1948:       // Writes:
  1949:       // - domain_sweep_latest:<host>  (summary)
  1950:       // - domains:<host>             (notes_sweep_latest pointer)
  1951:       try {
  1952:         if (evidence && evidence.ok) {
  1953:           const h = String(t.host || "").trim().toLowerCase();
  1954:           const diag = (evidence.diagnostics && typeof evidence.diagnostics === "object") ? evidence.diagnostics : {};
  1955:           const cf = (diag.cf && typeof diag.cf === "object") ? diag.cf : null;
  1956: 
  1957:           const sweepLatest = {
  1958:             id: h,
  1959:             host: h,
  1960:             url: evidence.public_url || evidence.url || t.url,
  1961:             probe_url: evidence.probe_url || null,
  1962:             fallback_reason: evidence.fallback_reason || null,
  1963:             http_status: typeof evidence.http_status === "number" ? evidence.http_status : 0,
  1964:             first_line_html: typeof evidence.first_line_html === "string" ? evidence.first_line_html : "",
  1965:             body_length: typeof evidence.body_length === "number" ? evidence.body_length : 0,
  1966:             ts: diag.ts || nowIso(),
  1967:             https_status: (typeof diag.https_status === "number") ? diag.https_status : null,
  1968:             cf: cf ? {
  1969:               colo: cf.colo || null,
  1970:               asn: cf.asn || null,
  1971:               asOrganization: cf.asOrganization || null,
  1972:               country: cf.country || null,
  1973:               regionCode: cf.regionCode || null,
  1974:               city: cf.city || null,
  1975:               timezone: cf.timezone || null
  1976:             } : null
  1977:           };
  1978: 
  1979:           await registryPut(env, "domain_sweep_latest", sweepLatest);
  1980: 
  1981:           const dom = (await registryGet(env, "domains", h)) || { id: h, domain: h };
  1982:           const merged = {
  1983:             ...dom,
  1984:             id: h,
  1985:             domain: dom.domain || h,
  1986:             notes_sweep_latest: {
  1987:               sweep_latest: {
  1988:                 host: h,
  1989:                 ts: sweepLatest.ts,
  1990:                 http_status: sweepLatest.http_status,
  1991:                 fallback_reason: sweepLatest.fallback_reason,
  1992:                 url: sweepLatest.url
  1993:               }
  1994:             }
  1995:           };
  1996:           await registryPut(env, "domains", merged);
  1997:         }
  1998:       } catch (__) {
  1999:         // Never fail the sweep response because persistence failed.
  2000:       }
  2001:     } catch (e) {
  2002:       results.push({ host: t.host, url: t.url, ok: false, error: String(e) });
  2003:     }
  2004:   }
  2005: 

===== HIT @ line 2022 (showing 1982..2102) =====
  1982:           const merged = {
  1983:             ...dom,
  1984:             id: h,
  1985:             domain: dom.domain || h,
  1986:             notes_sweep_latest: {
  1987:               sweep_latest: {
  1988:                 host: h,
  1989:                 ts: sweepLatest.ts,
  1990:                 http_status: sweepLatest.http_status,
  1991:                 fallback_reason: sweepLatest.fallback_reason,
  1992:                 url: sweepLatest.url
  1993:               }
  1994:             }
  1995:           };
  1996:           await registryPut(env, "domains", merged);
  1997:         }
  1998:       } catch (__) {
  1999:         // Never fail the sweep response because persistence failed.
  2000:       }
  2001:     } catch (e) {
  2002:       results.push({ host: t.host, url: t.url, ok: false, error: String(e) });
  2003:     }
  2004:   }
  2005: 
  2006:   push("HERD_SWEEP", {
  2007:     ok: true,
  2008:     requested: { hosts, limit },
  2009:     swept: results.length,
  2010:     results,
  2011:     stamp: new Date().toISOString()
  2012:   });
  2013:   continue;
  2014: }
  2015: if (line === "DEPLOYER_CAPS") {
  2016:       push("DEPLOYER_CAPS", __deployerCaps(env));
  2017:       continue;
  2018:     }
  2019: 
  2020:     if (line.startsWith("DEPLOYER_CALL ")) {
  2021:       if (!isOperator) { push("DEPLOYER_CALL", "UNAUTHORIZED"); continue; }
  2022:       const jsonPart = line.slice("DEPLOYER_CALL ".length).trim();
  2023:       const reqObj = safeJsonParse(jsonPart);
  2024:       if (!reqObj || typeof reqObj !== "object") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2025: 
  2026:       const serviceName = String(reqObj.service || "").trim();
  2027:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );

===== HIT @ line 2023 (showing 1983..2103) =====
  1983:             ...dom,
  1984:             id: h,
  1985:             domain: dom.domain || h,
  1986:             notes_sweep_latest: {
  1987:               sweep_latest: {
  1988:                 host: h,
  1989:                 ts: sweepLatest.ts,
  1990:                 http_status: sweepLatest.http_status,
  1991:                 fallback_reason: sweepLatest.fallback_reason,
  1992:                 url: sweepLatest.url
  1993:               }
  1994:             }
  1995:           };
  1996:           await registryPut(env, "domains", merged);
  1997:         }
  1998:       } catch (__) {
  1999:         // Never fail the sweep response because persistence failed.
  2000:       }
  2001:     } catch (e) {
  2002:       results.push({ host: t.host, url: t.url, ok: false, error: String(e) });
  2003:     }
  2004:   }
  2005: 
  2006:   push("HERD_SWEEP", {
  2007:     ok: true,
  2008:     requested: { hosts, limit },
  2009:     swept: results.length,
  2010:     results,
  2011:     stamp: new Date().toISOString()
  2012:   });
  2013:   continue;
  2014: }
  2015: if (line === "DEPLOYER_CAPS") {
  2016:       push("DEPLOYER_CAPS", __deployerCaps(env));
  2017:       continue;
  2018:     }
  2019: 
  2020:     if (line.startsWith("DEPLOYER_CALL ")) {
  2021:       if (!isOperator) { push("DEPLOYER_CALL", "UNAUTHORIZED"); continue; }
  2022:       const jsonPart = line.slice("DEPLOYER_CALL ".length).trim();
  2023:       const reqObj = safeJsonParse(jsonPart);
  2024:       if (!reqObj || typeof reqObj !== "object") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2025: 
  2026:       const serviceName = String(reqObj.service || "").trim();
  2027:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }

===== HIT @ line 2024 (showing 1984..2104) =====
  1984:             id: h,
  1985:             domain: dom.domain || h,
  1986:             notes_sweep_latest: {
  1987:               sweep_latest: {
  1988:                 host: h,
  1989:                 ts: sweepLatest.ts,
  1990:                 http_status: sweepLatest.http_status,
  1991:                 fallback_reason: sweepLatest.fallback_reason,
  1992:                 url: sweepLatest.url
  1993:               }
  1994:             }
  1995:           };
  1996:           await registryPut(env, "domains", merged);
  1997:         }
  1998:       } catch (__) {
  1999:         // Never fail the sweep response because persistence failed.
  2000:       }
  2001:     } catch (e) {
  2002:       results.push({ host: t.host, url: t.url, ok: false, error: String(e) });
  2003:     }
  2004:   }
  2005: 
  2006:   push("HERD_SWEEP", {
  2007:     ok: true,
  2008:     requested: { hosts, limit },
  2009:     swept: results.length,
  2010:     results,
  2011:     stamp: new Date().toISOString()
  2012:   });
  2013:   continue;
  2014: }
  2015: if (line === "DEPLOYER_CAPS") {
  2016:       push("DEPLOYER_CAPS", __deployerCaps(env));
  2017:       continue;
  2018:     }
  2019: 
  2020:     if (line.startsWith("DEPLOYER_CALL ")) {
  2021:       if (!isOperator) { push("DEPLOYER_CALL", "UNAUTHORIZED"); continue; }
  2022:       const jsonPart = line.slice("DEPLOYER_CALL ".length).trim();
  2023:       const reqObj = safeJsonParse(jsonPart);
  2024:       if (!reqObj || typeof reqObj !== "object") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2025: 
  2026:       const serviceName = String(reqObj.service || "").trim();
  2027:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 

===== HIT @ line 2027 (showing 1987..2107) =====
  1987:               sweep_latest: {
  1988:                 host: h,
  1989:                 ts: sweepLatest.ts,
  1990:                 http_status: sweepLatest.http_status,
  1991:                 fallback_reason: sweepLatest.fallback_reason,
  1992:                 url: sweepLatest.url
  1993:               }
  1994:             }
  1995:           };
  1996:           await registryPut(env, "domains", merged);
  1997:         }
  1998:       } catch (__) {
  1999:         // Never fail the sweep response because persistence failed.
  2000:       }
  2001:     } catch (e) {
  2002:       results.push({ host: t.host, url: t.url, ok: false, error: String(e) });
  2003:     }
  2004:   }
  2005: 
  2006:   push("HERD_SWEEP", {
  2007:     ok: true,
  2008:     requested: { hosts, limit },
  2009:     swept: results.length,
  2010:     results,
  2011:     stamp: new Date().toISOString()
  2012:   });
  2013:   continue;
  2014: }
  2015: if (line === "DEPLOYER_CAPS") {
  2016:       push("DEPLOYER_CAPS", __deployerCaps(env));
  2017:       continue;
  2018:     }
  2019: 
  2020:     if (line.startsWith("DEPLOYER_CALL ")) {
  2021:       if (!isOperator) { push("DEPLOYER_CALL", "UNAUTHORIZED"); continue; }
  2022:       const jsonPart = line.slice("DEPLOYER_CALL ".length).trim();
  2023:       const reqObj = safeJsonParse(jsonPart);
  2024:       if (!reqObj || typeof reqObj !== "object") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2025: 
  2026:       const serviceName = String(reqObj.service || "").trim();
  2027:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }

===== HIT @ line 2031 (showing 1991..2111) =====
  1991:                 fallback_reason: sweepLatest.fallback_reason,
  1992:                 url: sweepLatest.url
  1993:               }
  1994:             }
  1995:           };
  1996:           await registryPut(env, "domains", merged);
  1997:         }
  1998:       } catch (__) {
  1999:         // Never fail the sweep response because persistence failed.
  2000:       }
  2001:     } catch (e) {
  2002:       results.push({ host: t.host, url: t.url, ok: false, error: String(e) });
  2003:     }
  2004:   }
  2005: 
  2006:   push("HERD_SWEEP", {
  2007:     ok: true,
  2008:     requested: { hosts, limit },
  2009:     swept: results.length,
  2010:     results,
  2011:     stamp: new Date().toISOString()
  2012:   });
  2013:   continue;
  2014: }
  2015: if (line === "DEPLOYER_CAPS") {
  2016:       push("DEPLOYER_CAPS", __deployerCaps(env));
  2017:       continue;
  2018:     }
  2019: 
  2020:     if (line.startsWith("DEPLOYER_CALL ")) {
  2021:       if (!isOperator) { push("DEPLOYER_CALL", "UNAUTHORIZED"); continue; }
  2022:       const jsonPart = line.slice("DEPLOYER_CALL ".length).trim();
  2023:       const reqObj = safeJsonParse(jsonPart);
  2024:       if (!reqObj || typeof reqObj !== "object") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2025: 
  2026:       const serviceName = String(reqObj.service || "").trim();
  2027:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 

===== HIT @ line 2054 (showing 2014..2134) =====
  2014: }
  2015: if (line === "DEPLOYER_CAPS") {
  2016:       push("DEPLOYER_CAPS", __deployerCaps(env));
  2017:       continue;
  2018:     }
  2019: 
  2020:     if (line.startsWith("DEPLOYER_CALL ")) {
  2021:       if (!isOperator) { push("DEPLOYER_CALL", "UNAUTHORIZED"); continue; }
  2022:       const jsonPart = line.slice("DEPLOYER_CALL ".length).trim();
  2023:       const reqObj = safeJsonParse(jsonPart);
  2024:       if (!reqObj || typeof reqObj !== "object") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2025: 
  2026:       const serviceName = String(reqObj.service || "").trim();
  2027:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }

===== HIT @ line 2063 (showing 2023..2143) =====
  2023:       const reqObj = safeJsonParse(jsonPart);
  2024:       if (!reqObj || typeof reqObj !== "object") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2025: 
  2026:       const serviceName = String(reqObj.service || "").trim();
  2027:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 

===== HIT @ line 2065 (showing 2025..2145) =====
  2025: 
  2026:       const serviceName = String(reqObj.service || "").trim();
  2027:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");

===== HIT @ line 2068 (showing 2028..2148) =====
  2028:       if (!__hasService(env, serviceName)) { push("DEPLOYER_CALL", "DEPLOYER_CAPS_MISSING"); continue; }
  2029: 
  2030:       const path = String(reqObj.path || "").trim();
  2031:       if (!path.startsWith("/")) { push("DEPLOYER_CALL", "BAD_REQUEST"); continue; }
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();

===== HIT @ line 2072 (showing 2032..2152) =====
  2032: 
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];

===== HIT @ line 2073 (showing 2033..2153) =====
  2033:       // Enforce host caps: treat this as its own command token (DEPLOYER_CALL already host-capped upstream).
  2034:       // Evidence gating: callers must provide VERIFIED_FETCH_URL separately when making reachability claims.
  2035:       try {
  2036:         const svc = env[serviceName];
  2037:         const resp = await __serviceFetch(svc, {
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {

===== HIT @ line 2078 (showing 2038..2158) =====
  2038:           path,
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined

===== HIT @ line 2079 (showing 2039..2159) =====
  2039:           method: reqObj.method || "POST",
  2040:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2041:           content_type: reqObj.content_type || null,
  2042:           body: reqObj.body != null ? reqObj.body : undefined
  2043:         });
  2044:         push("DEPLOYER_CALL", { service: serviceName, path, ...resp });
  2045:       } catch (e) {
  2046:         push("DEPLOYER_CALL", { service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) });
  2047:       }
  2048:       continue;
  2049:     }
  2050: 
  2051: // Any unknown tokens in a batch are ignored (deterministic).
  2052:   }
  2053: 
  2054:   return jsonReply(JSON.stringify(out, null, 2));
  2055: }
  2056: 
  2057: 
  2058:     // ----------------------------
  2059:     // Multi-line simple commands (e.g., HOST x + PING)
  2060:     // ----------------------------
  2061:     const hasLine = (cmd) => lines.some((l) => l === cmd);
  2062: 
  2063:     if (hasLine("PING")) return jsonReply("PONG");
  2064: 
  2065:     if (hasLine("PAUSE")) return jsonReply("PAUSED");
  2066: 
  2067:     if (hasLine("SHOW_ALLOWED_COMMANDS")) {
  2068:       return jsonReply(allowedCommands);
  2069:     }
  2070: 
  2071:     if (hasLine("SHOW_BUILD")) {
  2072:       return jsonReply(
  2073:         JSON.stringify({ build: BUILD, stamp: new Date().toISOString() }, null, 2)
  2074:       );
  2075:     }
  2076: 
  2077:     if (hasLine("SHOW_CLAIM_GATE")) {
  2078:       return jsonReply(
  2079:         JSON.stringify(
  2080:           {
  2081:             trigger_words: [
  2082:               "live",
  2083:               "deployed",
  2084:               "launched",
  2085:               "resolving",
  2086:               "propagating",
  2087:               "successful",
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });

===== HIT @ line 2128 (showing 2088..2208) =====
  2088:               "verified",
  2089:               "up",
  2090:               "online",
  2091:               "working",
  2092:               "reachable",
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);

===== HIT @ line 2133 (showing 2093..2213) =====
  2093:               "available",
  2094:               "accessible"
  2095:             ],
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,

===== HIT @ line 2136 (showing 2096..2216) =====
  2096:             forced_message: "NOT WIRED: VERIFIED_FETCH REQUIRED",
  2097:             requires_verified_fetch_format: true
  2098:           },
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length

===== HIT @ line 2139 (showing 2099..2219) =====
  2099:           null,
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;

===== HIT @ line 2140 (showing 2100..2220) =====
  2100:           2
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {

===== HIT @ line 2141 (showing 2101..2221) =====
  2101:         )
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };

===== HIT @ line 2142 (showing 2102..2222) =====
  2102:       );
  2103:     }
  2104: 
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));

===== HIT @ line 2145 (showing 2105..2225) =====
  2105:     if (hasLine("RUN_SELF_TEST_EVIDENCE")) {
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };

===== HIT @ line 2146 (showing 2106..2226) =====
  2106:       return await runSelfTestEvidence();
  2107:     }
  2108: 
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 

===== HIT @ line 2149 (showing 2109..2229) =====
  2109: 
  2110: 
  2111: 
  2112: 
  2113:     if (hasLine("SNAPSHOT_STATE")) {
  2114:       const safeHost = activeHost || "none";
  2115:       const caps = await getHostCaps(activeHost);
  2116: 
  2117:       const snapshot = {
  2118:         build: BUILD,
  2119:         stamp: new Date().toISOString(),
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);

===== HIT @ line 2160 (showing 2120..2240) =====
  2120:         operator: (Boolean(env.AURA_OPERATOR_TOKEN) && String(request.headers.get("x-operator-token") || request.headers.get("X-Operator-Token") || "").trim() === String(env.AURA_OPERATOR_TOKEN || "").trim()) ? "YES" : "NO",
  2121:         active_host: safeHost,
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );

===== HIT @ line 2162 (showing 2122..2242) =====
  2122:         host_caps: caps || null,
  2123:         evidence_present_for_active_host: activeHost
  2124:           ? Boolean(await env.AURA_KV.get(evidenceKey(String(activeHost).toLowerCase())))
  2125:           : false
  2126:       };
  2127: 
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");

===== HIT @ line 2168 (showing 2128..2248) =====
  2128:       return jsonReply(snapshot);
  2129: 
  2130:     }
  2131: 
  2132:     if (hasLine("DEPLOYER_CAPS")) {
  2133:       return jsonReply(JSON.stringify(__deployerCaps(env), null, 2));
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));

===== HIT @ line 2174 (showing 2134..2254) =====
  2134:     }
  2135: 
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));
  2249: 
  2250:       await clearHost(hosts.http404);
  2251:       const httpAfterClear = await getEvidence(hosts.http404);
  2252:       const shouldGate = httpAfterClear === null;
  2253:       results.push(
  2254:         mk(

===== HIT @ line 2176 (showing 2136..2256) =====
  2136:     // DEPLOYER_CALL <json> (single-line only; operator-only)
  2137:     for (const line of lines) {
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));
  2249: 
  2250:       await clearHost(hosts.http404);
  2251:       const httpAfterClear = await getEvidence(hosts.http404);
  2252:       const shouldGate = httpAfterClear === null;
  2253:       results.push(
  2254:         mk(
  2255:           "cross_host_gate_http404",
  2256:           shouldGate,

===== HIT @ line 2178 (showing 2138..2258) =====
  2138:       if (!line.startsWith("DEPLOYER_CALL")) continue;
  2139:       if (!isOperator) return jsonReply("UNAUTHORIZED");
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));
  2249: 
  2250:       await clearHost(hosts.http404);
  2251:       const httpAfterClear = await getEvidence(hosts.http404);
  2252:       const shouldGate = httpAfterClear === null;
  2253:       results.push(
  2254:         mk(
  2255:           "cross_host_gate_http404",
  2256:           shouldGate,
  2257:           shouldGate ? "NOT WIRED: VERIFIED_FETCH REQUIRED" : "HAS_EVIDENCE",
  2258:           "NOT WIRED: VERIFIED_FETCH REQUIRED"

===== HIT @ line 2180 (showing 2140..2260) =====
  2140:       const jsonPart = line.slice("DEPLOYER_CALL".length).trim();
  2141:       const reqObj = safeJsonParse(jsonPart);
  2142:       if (!reqObj || typeof reqObj !== "object") return jsonReply("BAD_REQUEST");
  2143: 
  2144:       const serviceName = String(reqObj.service || "").trim();
  2145:       if (serviceName !== "AURA_DEPLOYER" && serviceName !== "AURA_CF") return jsonReply("BAD_REQUEST");
  2146:       if (!__hasService(env, serviceName)) return jsonReply("DEPLOYER_CAPS_MISSING");
  2147: 
  2148:       const path = String(reqObj.path || "").trim();
  2149:       if (!path.startsWith("/")) return jsonReply("BAD_REQUEST");
  2150: 
  2151:       try {
  2152:         const svc = env[serviceName];
  2153:         const resp = await __serviceFetch(svc, {
  2154:           path,
  2155:           method: reqObj.method || "POST",
  2156:           headers: __withOperatorHeaders(((reqObj.headers && typeof reqObj.headers === "object") ? reqObj.headers : {}), isOperator, operatorHeader, request.headers.get("X-Deploy-Key") || request.headers.get("X-Deploy-Secret")),
  2157:           content_type: reqObj.content_type || null,
  2158:           body: reqObj.body != null ? reqObj.body : undefined
  2159:         });
  2160:         return jsonReply(JSON.stringify({ service: serviceName, path, ...resp }, null, 2));
  2161:       } catch (e) {
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));
  2249: 
  2250:       await clearHost(hosts.http404);
  2251:       const httpAfterClear = await getEvidence(hosts.http404);
  2252:       const shouldGate = httpAfterClear === null;
  2253:       results.push(
  2254:         mk(
  2255:           "cross_host_gate_http404",
  2256:           shouldGate,
  2257:           shouldGate ? "NOT WIRED: VERIFIED_FETCH REQUIRED" : "HAS_EVIDENCE",
  2258:           "NOT WIRED: VERIFIED_FETCH REQUIRED"
  2259:         )
  2260:       );

===== HIT @ line 2202 (showing 2162..2282) =====
  2162:         return jsonReply(JSON.stringify({ service: serviceName, path, http_status: 0, error: "EXCEPTION", message: String(e?.message || e) }, null, 2));
  2163:       }
  2164:     }
  2165: 
  2166: 
  2167:     // ----------------------------
  2168:     // EVIDENCE_PRESENT (return stored evidence JSON for a host)
  2169:     // ----------------------------
  2170:     for (const line of lines) {
  2171:       if (line.startsWith("EVIDENCE_PRESENT")) {
  2172:         const parts = line.split(" ").filter(Boolean);
  2173:         const host = normalizeHostLoose(parts[1]) || activeHost;
  2174:         if (!host) return jsonReply("BAD_REQUEST");
  2175:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2176:         if (!stored) return jsonReply("NO_EVIDENCE");
  2177:         try {
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));
  2249: 
  2250:       await clearHost(hosts.http404);
  2251:       const httpAfterClear = await getEvidence(hosts.http404);
  2252:       const shouldGate = httpAfterClear === null;
  2253:       results.push(
  2254:         mk(
  2255:           "cross_host_gate_http404",
  2256:           shouldGate,
  2257:           shouldGate ? "NOT WIRED: VERIFIED_FETCH REQUIRED" : "HAS_EVIDENCE",
  2258:           "NOT WIRED: VERIFIED_FETCH REQUIRED"
  2259:         )
  2260:       );
  2261: 
  2262:       await clearHost(hosts.example);
  2263:       await clearHost(hosts.http404);
  2264: 
  2265:       const ok = results.every((r) => r.pass);
  2266:       return jsonReply(JSON.stringify({ ok, tests: results }, null, 2));
  2267:         }
  2268: 
  2269:     if (bodyTrim === "RUN_SELF_TEST_EVIDENCE") {
  2270:       return await runSelfTestEvidence();
  2271:     }
  2272: 
  2273: 
  2274:     // ----------------------------
  2275:     // Evidence engine (CLEAR runs first, then VERIFIED_FETCH_URL, then compute)
  2276:     // ----------------------------
  2277:     const hasReachabilityQuestion = /\breachable\b/i.test(body);
  2278: 
  2279:     // Response-shape controls
  2280:     const wantYesNo = /return\s+only\s*:\s*yes\s+or\s+no\b/i.test(body);
  2281:     const wantReachableUnreachable =
  2282:       /return\s+only\s*:\s*reachable\s+or\s+unreachable\b/i.test(body);

===== HIT @ line 2218 (showing 2178..2298) =====
  2178:           return jsonReply(JSON.stringify(JSON.parse(stored), null, 2));
  2179:         } catch {
  2180:           return jsonReply(stored);
  2181:         }
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));
  2249: 
  2250:       await clearHost(hosts.http404);
  2251:       const httpAfterClear = await getEvidence(hosts.http404);
  2252:       const shouldGate = httpAfterClear === null;
  2253:       results.push(
  2254:         mk(
  2255:           "cross_host_gate_http404",
  2256:           shouldGate,
  2257:           shouldGate ? "NOT WIRED: VERIFIED_FETCH REQUIRED" : "HAS_EVIDENCE",
  2258:           "NOT WIRED: VERIFIED_FETCH REQUIRED"
  2259:         )
  2260:       );
  2261: 
  2262:       await clearHost(hosts.example);
  2263:       await clearHost(hosts.http404);
  2264: 
  2265:       const ok = results.every((r) => r.pass);
  2266:       return jsonReply(JSON.stringify({ ok, tests: results }, null, 2));
  2267:         }
  2268: 
  2269:     if (bodyTrim === "RUN_SELF_TEST_EVIDENCE") {
  2270:       return await runSelfTestEvidence();
  2271:     }
  2272: 
  2273: 
  2274:     // ----------------------------
  2275:     // Evidence engine (CLEAR runs first, then VERIFIED_FETCH_URL, then compute)
  2276:     // ----------------------------
  2277:     const hasReachabilityQuestion = /\breachable\b/i.test(body);
  2278: 
  2279:     // Response-shape controls
  2280:     const wantYesNo = /return\s+only\s*:\s*yes\s+or\s+no\b/i.test(body);
  2281:     const wantReachableUnreachable =
  2282:       /return\s+only\s*:\s*reachable\s+or\s+unreachable\b/i.test(body);
  2283:     const want200or000 = /return\s+only\s*:\s*200\s+or\s+000\b/i.test(body);
  2284:     const wantHttpStatus = /return\s+only\s+the\s+http_status\b/i.test(body);
  2285:     const isShapeRequest =
  2286:       wantYesNo || wantReachableUnreachable || want200or000 || wantHttpStatus;
  2287: 
  2288: 
  2289:     // ----------------------------
  2290:     // CLAIM GATE (wired): if user asks "live/deployed/online/etc" in the prompt,
  2291:     // require at least one VERIFIED_FETCH_URL line in the SAME request.
  2292:     // This prevents stale KV evidence from being used to claim reachability.
  2293:     // ----------------------------
  2294:     const claimGateTriggerWords = [
  2295:       "live",
  2296:       "deployed",
  2297:       "launched",
  2298:       "resolving",

===== HIT @ line 2222 (showing 2182..2302) =====
  2182:       }
  2183:     }
  2184: 
  2185:     // ----------------------------
  2186:     // Self-test harness (unchanged)
  2187:     // ----------------------------
  2188:         async function runSelfTestEvidence() {
  2189:       const mk = (name, pass, observed, expected) => ({ name, pass, observed, expected });
  2190: 
  2191:       const hosts = {
  2192:         example: "example.com",
  2193:         http404: "httpstat.us"
  2194:       };
  2195: 
  2196:       const clearHost = async (host) => {
  2197:         await env.AURA_KV.delete(evidenceKey(host));
  2198:       };
  2199: 
  2200:       const getEvidence = async (host) => {
  2201:         const stored = await env.AURA_KV.get(evidenceKey(host));
  2202:         return stored ? JSON.parse(stored) : null;
  2203:       };
  2204: 
  2205:       const putEvidence = async (targetUrl) => {
  2206:         const host = new URL(targetUrl).host.toLowerCase();
  2207:         try {
  2208:           const res = await fetch(targetUrl);
  2209:           const text = await res.text();
  2210:           const evidence = {
  2211:             ok: true,
  2212:             url: targetUrl,
  2213:             host,
  2214:             http_status: res.status,
  2215:             first_line_html: text.split("\n")[0] || "",
  2216:             body_length: text.length
  2217:           };
  2218:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2219:           return evidence;
  2220:         } catch {
  2221:           const evidence = { ok: false, url: targetUrl, host, http_status: 0 };
  2222:           await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2223:           return evidence;
  2224:         }
  2225:       };
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));
  2249: 
  2250:       await clearHost(hosts.http404);
  2251:       const httpAfterClear = await getEvidence(hosts.http404);
  2252:       const shouldGate = httpAfterClear === null;
  2253:       results.push(
  2254:         mk(
  2255:           "cross_host_gate_http404",
  2256:           shouldGate,
  2257:           shouldGate ? "NOT WIRED: VERIFIED_FETCH REQUIRED" : "HAS_EVIDENCE",
  2258:           "NOT WIRED: VERIFIED_FETCH REQUIRED"
  2259:         )
  2260:       );
  2261: 
  2262:       await clearHost(hosts.example);
  2263:       await clearHost(hosts.http404);
  2264: 
  2265:       const ok = results.every((r) => r.pass);
  2266:       return jsonReply(JSON.stringify({ ok, tests: results }, null, 2));
  2267:         }
  2268: 
  2269:     if (bodyTrim === "RUN_SELF_TEST_EVIDENCE") {
  2270:       return await runSelfTestEvidence();
  2271:     }
  2272: 
  2273: 
  2274:     // ----------------------------
  2275:     // Evidence engine (CLEAR runs first, then VERIFIED_FETCH_URL, then compute)
  2276:     // ----------------------------
  2277:     const hasReachabilityQuestion = /\breachable\b/i.test(body);
  2278: 
  2279:     // Response-shape controls
  2280:     const wantYesNo = /return\s+only\s*:\s*yes\s+or\s+no\b/i.test(body);
  2281:     const wantReachableUnreachable =
  2282:       /return\s+only\s*:\s*reachable\s+or\s+unreachable\b/i.test(body);
  2283:     const want200or000 = /return\s+only\s*:\s*200\s+or\s+000\b/i.test(body);
  2284:     const wantHttpStatus = /return\s+only\s+the\s+http_status\b/i.test(body);
  2285:     const isShapeRequest =
  2286:       wantYesNo || wantReachableUnreachable || want200or000 || wantHttpStatus;
  2287: 
  2288: 
  2289:     // ----------------------------
  2290:     // CLAIM GATE (wired): if user asks "live/deployed/online/etc" in the prompt,
  2291:     // require at least one VERIFIED_FETCH_URL line in the SAME request.
  2292:     // This prevents stale KV evidence from being used to claim reachability.
  2293:     // ----------------------------
  2294:     const claimGateTriggerWords = [
  2295:       "live",
  2296:       "deployed",
  2297:       "launched",
  2298:       "resolving",
  2299:       "propagating",
  2300:       "successful",
  2301:       "verified",
  2302:       "up",

===== HIT @ line 2266 (showing 2226..2346) =====
  2226: 
  2227:       const results = [];
  2228: 
  2229:       await clearHost(hosts.example);
  2230:       await clearHost(hosts.http404);
  2231: 
  2232:       const ev0 = await getEvidence(hosts.example);
  2233:       results.push(
  2234:         mk(
  2235:           "evidence_missing_example",
  2236:           ev0 === null,
  2237:           ev0 ? "EVIDENCE_PRESENT" : "EVIDENCE_MISSING",
  2238:           "EVIDENCE_MISSING"
  2239:         )
  2240:       );
  2241: 
  2242:       const ev1 = await putEvidence("https://example.com");
  2243:       const yes1 = ev1.ok && statusReachable(ev1.http_status) ? "YES" : "NO";
  2244:       results.push(mk("fetch_example_yes", yes1 === "YES", yes1, "YES"));
  2245: 
  2246:       const ev2 = await putEvidence("https://httpstat.us/404");
  2247:       const yes2 = ev2.ok && statusReachable(ev2.http_status) ? "YES" : "NO";
  2248:       results.push(mk("fetch_404_no", yes2 === "NO", yes2, "NO"));
  2249: 
  2250:       await clearHost(hosts.http404);
  2251:       const httpAfterClear = await getEvidence(hosts.http404);
  2252:       const shouldGate = httpAfterClear === null;
  2253:       results.push(
  2254:         mk(
  2255:           "cross_host_gate_http404",
  2256:           shouldGate,
  2257:           shouldGate ? "NOT WIRED: VERIFIED_FETCH REQUIRED" : "HAS_EVIDENCE",
  2258:           "NOT WIRED: VERIFIED_FETCH REQUIRED"
  2259:         )
  2260:       );
  2261: 
  2262:       await clearHost(hosts.example);
  2263:       await clearHost(hosts.http404);
  2264: 
  2265:       const ok = results.every((r) => r.pass);
  2266:       return jsonReply(JSON.stringify({ ok, tests: results }, null, 2));
  2267:         }
  2268: 
  2269:     if (bodyTrim === "RUN_SELF_TEST_EVIDENCE") {
  2270:       return await runSelfTestEvidence();
  2271:     }
  2272: 
  2273: 
  2274:     // ----------------------------
  2275:     // Evidence engine (CLEAR runs first, then VERIFIED_FETCH_URL, then compute)
  2276:     // ----------------------------
  2277:     const hasReachabilityQuestion = /\breachable\b/i.test(body);
  2278: 
  2279:     // Response-shape controls
  2280:     const wantYesNo = /return\s+only\s*:\s*yes\s+or\s+no\b/i.test(body);
  2281:     const wantReachableUnreachable =
  2282:       /return\s+only\s*:\s*reachable\s+or\s+unreachable\b/i.test(body);
  2283:     const want200or000 = /return\s+only\s*:\s*200\s+or\s+000\b/i.test(body);
  2284:     const wantHttpStatus = /return\s+only\s+the\s+http_status\b/i.test(body);
  2285:     const isShapeRequest =
  2286:       wantYesNo || wantReachableUnreachable || want200or000 || wantHttpStatus;
  2287: 
  2288: 
  2289:     // ----------------------------
  2290:     // CLAIM GATE (wired): if user asks "live/deployed/online/etc" in the prompt,
  2291:     // require at least one VERIFIED_FETCH_URL line in the SAME request.
  2292:     // This prevents stale KV evidence from being used to claim reachability.
  2293:     // ----------------------------
  2294:     const claimGateTriggerWords = [
  2295:       "live",
  2296:       "deployed",
  2297:       "launched",
  2298:       "resolving",
  2299:       "propagating",
  2300:       "successful",
  2301:       "verified",
  2302:       "up",
  2303:       "online",
  2304:       "working",
  2305:       "reachable",
  2306:       "available",
  2307:       "accessible"
  2308:     ];
  2309:     const claimGateForcedMessage = "NOT WIRED: VERIFIED_FETCH REQUIRED";
  2310:     const claimGateTriggered =
  2311:       new RegExp(`\\b(${claimGateTriggerWords.join("|")})\\b`, "i").test(body);
  2312:     const hasVerifiedFetchInThisRequest = lines.some((l) => l.startsWith("VERIFIED_FETCH_URL"));
  2313: 
  2314:     // Registry commands are explicitly bypassed (they are structured, not "claims").
  2315:     const hasRegistryBypass =
  2316:       lines.some((l) => __registryBypass(l.split(" ")[0]));
  2317: 
  2318:     if (claimGateTriggered && !hasVerifiedFetchInThisRequest && !hasRegistryBypass) {
  2319:       return jsonReply(claimGateForcedMessage);
  2320:     }
  2321: 
  2322:     const clearHosts = [];
  2323:     for (const line of lines) {
  2324:       if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  2325:         const parts = line.split(" ").filter(Boolean);
  2326:         const target = parts[1];
  2327:         const host = normalizeHost(target);
  2328:         if (host) clearHosts.push(host);
  2329:       }
  2330:     }
  2331: 
  2332:     if (clearHosts.length > 0) {
  2333:       for (const host of clearHosts) {
  2334:         await env.AURA_KV.delete(evidenceKey(host));
  2335:       }
  2336: 
  2337:       // If the message only clears evidence (plus optional HOST line), return deterministically.
  2338:       const hasOtherAction =
  2339:         lines.some((l) => {
  2340:           const t = l.split(" ")[0];
  2341:           return (
  2342:             t !== "HOST" &&
  2343:             t !== "CLEAR_VERIFIED_FETCH" &&
  2344:             allowedCommands.includes(t)
  2345:           );
  2346:         }) || hasReachabilityQuestion || isShapeRequest;

===== HIT @ line 2319 (showing 2279..2399) =====
  2279:     // Response-shape controls
  2280:     const wantYesNo = /return\s+only\s*:\s*yes\s+or\s+no\b/i.test(body);
  2281:     const wantReachableUnreachable =
  2282:       /return\s+only\s*:\s*reachable\s+or\s+unreachable\b/i.test(body);
  2283:     const want200or000 = /return\s+only\s*:\s*200\s+or\s+000\b/i.test(body);
  2284:     const wantHttpStatus = /return\s+only\s+the\s+http_status\b/i.test(body);
  2285:     const isShapeRequest =
  2286:       wantYesNo || wantReachableUnreachable || want200or000 || wantHttpStatus;
  2287: 
  2288: 
  2289:     // ----------------------------
  2290:     // CLAIM GATE (wired): if user asks "live/deployed/online/etc" in the prompt,
  2291:     // require at least one VERIFIED_FETCH_URL line in the SAME request.
  2292:     // This prevents stale KV evidence from being used to claim reachability.
  2293:     // ----------------------------
  2294:     const claimGateTriggerWords = [
  2295:       "live",
  2296:       "deployed",
  2297:       "launched",
  2298:       "resolving",
  2299:       "propagating",
  2300:       "successful",
  2301:       "verified",
  2302:       "up",
  2303:       "online",
  2304:       "working",
  2305:       "reachable",
  2306:       "available",
  2307:       "accessible"
  2308:     ];
  2309:     const claimGateForcedMessage = "NOT WIRED: VERIFIED_FETCH REQUIRED";
  2310:     const claimGateTriggered =
  2311:       new RegExp(`\\b(${claimGateTriggerWords.join("|")})\\b`, "i").test(body);
  2312:     const hasVerifiedFetchInThisRequest = lines.some((l) => l.startsWith("VERIFIED_FETCH_URL"));
  2313: 
  2314:     // Registry commands are explicitly bypassed (they are structured, not "claims").
  2315:     const hasRegistryBypass =
  2316:       lines.some((l) => __registryBypass(l.split(" ")[0]));
  2317: 
  2318:     if (claimGateTriggered && !hasVerifiedFetchInThisRequest && !hasRegistryBypass) {
  2319:       return jsonReply(claimGateForcedMessage);
  2320:     }
  2321: 
  2322:     const clearHosts = [];
  2323:     for (const line of lines) {
  2324:       if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  2325:         const parts = line.split(" ").filter(Boolean);
  2326:         const target = parts[1];
  2327:         const host = normalizeHost(target);
  2328:         if (host) clearHosts.push(host);
  2329:       }
  2330:     }
  2331: 
  2332:     if (clearHosts.length > 0) {
  2333:       for (const host of clearHosts) {
  2334:         await env.AURA_KV.delete(evidenceKey(host));
  2335:       }
  2336: 
  2337:       // If the message only clears evidence (plus optional HOST line), return deterministically.
  2338:       const hasOtherAction =
  2339:         lines.some((l) => {
  2340:           const t = l.split(" ")[0];
  2341:           return (
  2342:             t !== "HOST" &&
  2343:             t !== "CLEAR_VERIFIED_FETCH" &&
  2344:             allowedCommands.includes(t)
  2345:           );
  2346:         }) || hasReachabilityQuestion || isShapeRequest;
  2347: 
  2348:       if (!hasOtherAction) {
  2349:         return jsonReply(clearHosts.length === 1 ? "CLEARED" : `CLEARED (${clearHosts.length})`);
  2350:       }
  2351:     }
  2352: 
  2353:     let lastEvidence = null;
  2354:     const fetchEvidences = [];
  2355: 
  2356:     for (const line of lines) {
  2357:       if (!line.startsWith("VERIFIED_FETCH_URL")) continue;
  2358: 
  2359:       const parts = line.split(" ").filter(Boolean);
  2360:       const target = parts[1];
  2361:       const host = normalizeHost(target);
  2362:       if (!host) continue;
  2363: 
  2364:       const runFetch = async (probeUrl) => {
  2365:         const res = await fetch(probeUrl);
  2366:         const text = await res.text();
  2367:         return { res, text };
  2368:       };
  2369: 
  2370:       const nowTs = new Date().toISOString();
  2371: 
  2372:       // Prevent self-fetch recursion (auras.guide/* routes to this Worker).
  2373:       // Instead, record a synthetic "reachable" evidence based on the fact this request is being served.
  2374:       const selfHost = new URL(request.url).host.toLowerCase();
  2375:       if (host === selfHost) {
  2376:         const evidence = {
  2377:           ok: true,
  2378:           host,
  2379:           url: target,
  2380:           probe_url: null,
  2381:           http_status: 200,
  2382:           first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  2383:           body_length: 0,
  2384:           synthetic: true,
  2385:           reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  2386:           diagnostics: {
  2387:             cf: request.cf || null,
  2388:             self_host: selfHost,
  2389:             ts: nowTs
  2390:           }
  2391:         };
  2392: 
  2393:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2394:         lastEvidence = evidence;
  2395:         fetchEvidences.push(evidence);
  2396:         continue;
  2397:       }
  2398: 
  2399:       try {

===== HIT @ line 2349 (showing 2309..2429) =====
  2309:     const claimGateForcedMessage = "NOT WIRED: VERIFIED_FETCH REQUIRED";
  2310:     const claimGateTriggered =
  2311:       new RegExp(`\\b(${claimGateTriggerWords.join("|")})\\b`, "i").test(body);
  2312:     const hasVerifiedFetchInThisRequest = lines.some((l) => l.startsWith("VERIFIED_FETCH_URL"));
  2313: 
  2314:     // Registry commands are explicitly bypassed (they are structured, not "claims").
  2315:     const hasRegistryBypass =
  2316:       lines.some((l) => __registryBypass(l.split(" ")[0]));
  2317: 
  2318:     if (claimGateTriggered && !hasVerifiedFetchInThisRequest && !hasRegistryBypass) {
  2319:       return jsonReply(claimGateForcedMessage);
  2320:     }
  2321: 
  2322:     const clearHosts = [];
  2323:     for (const line of lines) {
  2324:       if (line.startsWith("CLEAR_VERIFIED_FETCH")) {
  2325:         const parts = line.split(" ").filter(Boolean);
  2326:         const target = parts[1];
  2327:         const host = normalizeHost(target);
  2328:         if (host) clearHosts.push(host);
  2329:       }
  2330:     }
  2331: 
  2332:     if (clearHosts.length > 0) {
  2333:       for (const host of clearHosts) {
  2334:         await env.AURA_KV.delete(evidenceKey(host));
  2335:       }
  2336: 
  2337:       // If the message only clears evidence (plus optional HOST line), return deterministically.
  2338:       const hasOtherAction =
  2339:         lines.some((l) => {
  2340:           const t = l.split(" ")[0];
  2341:           return (
  2342:             t !== "HOST" &&
  2343:             t !== "CLEAR_VERIFIED_FETCH" &&
  2344:             allowedCommands.includes(t)
  2345:           );
  2346:         }) || hasReachabilityQuestion || isShapeRequest;
  2347: 
  2348:       if (!hasOtherAction) {
  2349:         return jsonReply(clearHosts.length === 1 ? "CLEARED" : `CLEARED (${clearHosts.length})`);
  2350:       }
  2351:     }
  2352: 
  2353:     let lastEvidence = null;
  2354:     const fetchEvidences = [];
  2355: 
  2356:     for (const line of lines) {
  2357:       if (!line.startsWith("VERIFIED_FETCH_URL")) continue;
  2358: 
  2359:       const parts = line.split(" ").filter(Boolean);
  2360:       const target = parts[1];
  2361:       const host = normalizeHost(target);
  2362:       if (!host) continue;
  2363: 
  2364:       const runFetch = async (probeUrl) => {
  2365:         const res = await fetch(probeUrl);
  2366:         const text = await res.text();
  2367:         return { res, text };
  2368:       };
  2369: 
  2370:       const nowTs = new Date().toISOString();
  2371: 
  2372:       // Prevent self-fetch recursion (auras.guide/* routes to this Worker).
  2373:       // Instead, record a synthetic "reachable" evidence based on the fact this request is being served.
  2374:       const selfHost = new URL(request.url).host.toLowerCase();
  2375:       if (host === selfHost) {
  2376:         const evidence = {
  2377:           ok: true,
  2378:           host,
  2379:           url: target,
  2380:           probe_url: null,
  2381:           http_status: 200,
  2382:           first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  2383:           body_length: 0,
  2384:           synthetic: true,
  2385:           reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  2386:           diagnostics: {
  2387:             cf: request.cf || null,
  2388:             self_host: selfHost,
  2389:             ts: nowTs
  2390:           }
  2391:         };
  2392: 
  2393:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2394:         lastEvidence = evidence;
  2395:         fetchEvidences.push(evidence);
  2396:         continue;
  2397:       }
  2398: 
  2399:       try {
  2400:         // 1) Try HTTPS (or whatever the user provided)
  2401:         const { res: res1, text: text1 } = await runFetch(target);
  2402: 
  2403:         // 2) If HTTPS returns 525, retry HTTP for same host/path/query
  2404:         if (res1.status === 525) {
  2405:           const u = new URL(target);
  2406:           if (u.protocol === "https:") {
  2407:             u.protocol = "http:";
  2408:             const httpUrl = u.toString();
  2409: 
  2410:             const { res: res2, text: text2 } = await runFetch(httpUrl);
  2411: 
  2412:             const evidence = {
  2413:               ok: true,
  2414:               host,
  2415:               public_url: target,
  2416:               probe_url: httpUrl,
  2417:               fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  2418:               http_status: res2.status,
  2419:               first_line_html: text2.split("\n")[0] || "",
  2420:               body_length: text2.length,
  2421:               diagnostics: {
  2422:                 cf: request.cf || null,
  2423:                 https_status: 525,
  2424:                 ts: nowTs
  2425:               }
  2426:             };
  2427: 
  2428:             await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2429:             lastEvidence = evidence;

===== HIT @ line 2393 (showing 2353..2473) =====
  2353:     let lastEvidence = null;
  2354:     const fetchEvidences = [];
  2355: 
  2356:     for (const line of lines) {
  2357:       if (!line.startsWith("VERIFIED_FETCH_URL")) continue;
  2358: 
  2359:       const parts = line.split(" ").filter(Boolean);
  2360:       const target = parts[1];
  2361:       const host = normalizeHost(target);
  2362:       if (!host) continue;
  2363: 
  2364:       const runFetch = async (probeUrl) => {
  2365:         const res = await fetch(probeUrl);
  2366:         const text = await res.text();
  2367:         return { res, text };
  2368:       };
  2369: 
  2370:       const nowTs = new Date().toISOString();
  2371: 
  2372:       // Prevent self-fetch recursion (auras.guide/* routes to this Worker).
  2373:       // Instead, record a synthetic "reachable" evidence based on the fact this request is being served.
  2374:       const selfHost = new URL(request.url).host.toLowerCase();
  2375:       if (host === selfHost) {
  2376:         const evidence = {
  2377:           ok: true,
  2378:           host,
  2379:           url: target,
  2380:           probe_url: null,
  2381:           http_status: 200,
  2382:           first_line_html: "SELF_HOST_SYNTHETIC_EVIDENCE",
  2383:           body_length: 0,
  2384:           synthetic: true,
  2385:           reason: "WORKER_SELF_ROUTE_ASSUME_REACHABLE",
  2386:           diagnostics: {
  2387:             cf: request.cf || null,
  2388:             self_host: selfHost,
  2389:             ts: nowTs
  2390:           }
  2391:         };
  2392: 
  2393:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2394:         lastEvidence = evidence;
  2395:         fetchEvidences.push(evidence);
  2396:         continue;
  2397:       }
  2398: 
  2399:       try {
  2400:         // 1) Try HTTPS (or whatever the user provided)
  2401:         const { res: res1, text: text1 } = await runFetch(target);
  2402: 
  2403:         // 2) If HTTPS returns 525, retry HTTP for same host/path/query
  2404:         if (res1.status === 525) {
  2405:           const u = new URL(target);
  2406:           if (u.protocol === "https:") {
  2407:             u.protocol = "http:";
  2408:             const httpUrl = u.toString();
  2409: 
  2410:             const { res: res2, text: text2 } = await runFetch(httpUrl);
  2411: 
  2412:             const evidence = {
  2413:               ok: true,
  2414:               host,
  2415:               public_url: target,
  2416:               probe_url: httpUrl,
  2417:               fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  2418:               http_status: res2.status,
  2419:               first_line_html: text2.split("\n")[0] || "",
  2420:               body_length: text2.length,
  2421:               diagnostics: {
  2422:                 cf: request.cf || null,
  2423:                 https_status: 525,
  2424:                 ts: nowTs
  2425:               }
  2426:             };
  2427: 
  2428:             await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2429:             lastEvidence = evidence;
  2430:             fetchEvidences.push(evidence);
  2431:             continue;
  2432:           }
  2433:         }
  2434: 
  2435:         // Normal path: store what we got
  2436:         const evidence = {
  2437:           ok: true,
  2438:           host,
  2439:           url: target,
  2440:           http_status: res1.status,
  2441:           first_line_html: text1.split("\n")[0] || "",
  2442:           body_length: text1.length,
  2443:           diagnostics: {
  2444:             cf: request.cf || null,
  2445:             ts: nowTs
  2446:           }
  2447:         };
  2448: 
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:

===== HIT @ line 2428 (showing 2388..2508) =====
  2388:             self_host: selfHost,
  2389:             ts: nowTs
  2390:           }
  2391:         };
  2392: 
  2393:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2394:         lastEvidence = evidence;
  2395:         fetchEvidences.push(evidence);
  2396:         continue;
  2397:       }
  2398: 
  2399:       try {
  2400:         // 1) Try HTTPS (or whatever the user provided)
  2401:         const { res: res1, text: text1 } = await runFetch(target);
  2402: 
  2403:         // 2) If HTTPS returns 525, retry HTTP for same host/path/query
  2404:         if (res1.status === 525) {
  2405:           const u = new URL(target);
  2406:           if (u.protocol === "https:") {
  2407:             u.protocol = "http:";
  2408:             const httpUrl = u.toString();
  2409: 
  2410:             const { res: res2, text: text2 } = await runFetch(httpUrl);
  2411: 
  2412:             const evidence = {
  2413:               ok: true,
  2414:               host,
  2415:               public_url: target,
  2416:               probe_url: httpUrl,
  2417:               fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  2418:               http_status: res2.status,
  2419:               first_line_html: text2.split("\n")[0] || "",
  2420:               body_length: text2.length,
  2421:               diagnostics: {
  2422:                 cf: request.cf || null,
  2423:                 https_status: 525,
  2424:                 ts: nowTs
  2425:               }
  2426:             };
  2427: 
  2428:             await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2429:             lastEvidence = evidence;
  2430:             fetchEvidences.push(evidence);
  2431:             continue;
  2432:           }
  2433:         }
  2434: 
  2435:         // Normal path: store what we got
  2436:         const evidence = {
  2437:           ok: true,
  2438:           host,
  2439:           url: target,
  2440:           http_status: res1.status,
  2441:           first_line_html: text1.split("\n")[0] || "",
  2442:           body_length: text1.length,
  2443:           diagnostics: {
  2444:             cf: request.cf || null,
  2445:             ts: nowTs
  2446:           }
  2447:         };
  2448: 
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);

===== HIT @ line 2449 (showing 2409..2529) =====
  2409: 
  2410:             const { res: res2, text: text2 } = await runFetch(httpUrl);
  2411: 
  2412:             const evidence = {
  2413:               ok: true,
  2414:               host,
  2415:               public_url: target,
  2416:               probe_url: httpUrl,
  2417:               fallback_reason: "CF_HTTPS_525_HTTP_PROBE",
  2418:               http_status: res2.status,
  2419:               first_line_html: text2.split("\n")[0] || "",
  2420:               body_length: text2.length,
  2421:               diagnostics: {
  2422:                 cf: request.cf || null,
  2423:                 https_status: 525,
  2424:                 ts: nowTs
  2425:               }
  2426:             };
  2427: 
  2428:             await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2429:             lastEvidence = evidence;
  2430:             fetchEvidences.push(evidence);
  2431:             continue;
  2432:           }
  2433:         }
  2434: 
  2435:         // Normal path: store what we got
  2436:         const evidence = {
  2437:           ok: true,
  2438:           host,
  2439:           url: target,
  2440:           http_status: res1.status,
  2441:           first_line_html: text1.split("\n")[0] || "",
  2442:           body_length: text1.length,
  2443:           diagnostics: {
  2444:             cf: request.cf || null,
  2445:             ts: nowTs
  2446:           }
  2447:         };
  2448: 
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 

===== HIT @ line 2466 (showing 2426..2546) =====
  2426:             };
  2427: 
  2428:             await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2429:             lastEvidence = evidence;
  2430:             fetchEvidences.push(evidence);
  2431:             continue;
  2432:           }
  2433:         }
  2434: 
  2435:         // Normal path: store what we got
  2436:         const evidence = {
  2437:           ok: true,
  2438:           host,
  2439:           url: target,
  2440:           http_status: res1.status,
  2441:           first_line_html: text1.split("\n")[0] || "",
  2442:           body_length: text1.length,
  2443:           diagnostics: {
  2444:             cf: request.cf || null,
  2445:             ts: nowTs
  2446:           }
  2447:         };
  2448: 
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {

===== HIT @ line 2483 (showing 2443..2563) =====
  2443:           diagnostics: {
  2444:             cf: request.cf || null,
  2445:             ts: nowTs
  2446:           }
  2447:         };
  2448: 
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {

===== HIT @ line 2484 (showing 2444..2564) =====
  2444:             cf: request.cf || null,
  2445:             ts: nowTs
  2446:           }
  2447:         };
  2448: 
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;

===== HIT @ line 2485 (showing 2445..2565) =====
  2445:             ts: nowTs
  2446:           }
  2447:         };
  2448: 
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);

===== HIT @ line 2486 (showing 2446..2566) =====
  2446:           }
  2447:         };
  2448: 
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }

===== HIT @ line 2489 (showing 2449..2569) =====
  2449:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2450:         lastEvidence = evidence;
  2451:         fetchEvidences.push(evidence);
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 

===== HIT @ line 2492 (showing 2452..2572) =====
  2452:       } catch (err) {
  2453:         const evidence = {
  2454:           ok: false,
  2455:           host,
  2456:           url: target,
  2457:           http_status: 0,
  2458:           error: String(err?.message || err),
  2459:           error_name: err?.name || "UNKNOWN",
  2460:           diagnostics: {
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;

===== HIT @ line 2501 (showing 2461..2581) =====
  2461:             cf: request.cf || null,
  2462:             ts: nowTs
  2463:           }
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()

===== HIT @ line 2504 (showing 2464..2584) =====
  2464:         };
  2465: 
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);

===== HIT @ line 2506 (showing 2466..2586) =====
  2466:         await env.AURA_KV.put(evidenceKey(host), JSON.stringify(evidence));
  2467:         lastEvidence = evidence;
  2468:         fetchEvidences.push(evidence);
  2469:       }
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;

===== HIT @ line 2510 (showing 2470..2590) =====
  2470:     }
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 

===== HIT @ line 2511 (showing 2471..2591) =====
  2471: 
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);

===== HIT @ line 2512 (showing 2472..2592) =====
  2472:     // ----------------------------
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });

===== HIT @ line 2513 (showing 2473..2593) =====
  2473:     // Target selection for questions:
  2474:     // Prefer an asked host (URL or bare domain mention). Otherwise use active HOST context.
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 

===== HIT @ line 2515 (showing 2475..2595) =====
  2475:     // ----------------------------
  2476:     const targetHostForQuestion = askedHost || activeHost || null;
  2477: 
  2478:     // Inline compute from VERIFIED_FETCH_URL executed in THIS message when asked host matches
  2479:     if (lastEvidence && targetHostForQuestion && lastEvidence.host === targetHostForQuestion) {
  2480:       const st = Number(lastEvidence.http_status || 0);
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(

===== HIT @ line 2521 (showing 2481..2601) =====
  2481:       const r = lastEvidence.ok && statusReachable(st);
  2482: 
  2483:       if (wantHttpStatus) return jsonReply(String(st));
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };

===== HIT @ line 2524 (showing 2484..2604) =====
  2484:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2485:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();

===== HIT @ line 2526 (showing 2486..2606) =====
  2486:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2487:     }
  2488: 
  2489:     // If VERIFIED_FETCH_URL ran and there is NO reachability question, return the evidence JSON by default.
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");

===== HIT @ line 2530 (showing 2490..2610) =====
  2490:     if (fetchEvidences.length > 0 && !hasReachabilityQuestion && !isShapeRequest) {
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 

===== HIT @ line 2531 (showing 2491..2611) =====
  2491:       const payload = fetchEvidences.length === 1 ? fetchEvidences[0] : fetchEvidences;
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);

===== HIT @ line 2532 (showing 2492..2612) =====
  2492:       return jsonReply(JSON.stringify(payload, null, 2));
  2493:     }
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };

===== HIT @ line 2534 (showing 2494..2614) =====
  2494: 
  2495:     // ----------------------------
  2496:     // Shape-only queries (no "reachable" keyword) using HOST context + existing evidence.
  2497:     // Example: "HOST example.com\nReturn ONLY the http_status"
  2498:     // ----------------------------
  2499:     if (!hasReachabilityQuestion && isShapeRequest) {
  2500:       const hostToUse = targetHostForQuestion;
  2501:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2502: 
  2503:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2504:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2505: 
  2506:       const evidence = JSON.parse(stored);
  2507:       const st = Number(evidence.http_status || 0);
  2508:       const r = evidence.ok && statusReachable(st);
  2509: 
  2510:       if (wantHttpStatus) return jsonReply(String(st));
  2511:       if (want200or000) return jsonReply(st === 200 ? "200" : "000");
  2512:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2513:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2514: 
  2515:       return jsonReply(String(st));
  2516:     }
  2517: 
  2518:     // Evidence-memory reachability path (host-scoped KV)
  2519:     if (hasReachabilityQuestion) {
  2520:       const hostToUse = targetHostForQuestion;
  2521:       if (!hostToUse) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2522: 
  2523:       const stored = await env.AURA_KV.get(evidenceKey(hostToUse));
  2524:       if (!stored) return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2525: 
  2526:       const evidence = JSON.parse(stored);
  2527:       const st = Number(evidence.http_status || 0);
  2528:       const r = evidence.ok && statusReachable(st);
  2529: 
  2530:       if (wantHttpStatus) return jsonReply(String(st));
  2531:       if (wantReachableUnreachable) return jsonReply(r ? "REACHABLE" : "UNREACHABLE");
  2532:       if (wantYesNo) return jsonReply(r ? "YES" : "NO");
  2533: 
  2534:       return jsonReply(r ? "YES" : "NO");
  2535:     }
  2536: 
  2537: // ----------------------------
  2538: // Memory Substrate Commands (explicit; storage-backed)
  2539: // ----------------------------
  2540: 
  2541: const importRegistryCore = async (typeName, items) => {
  2542:   const idsBefore = await registryGetIndex(env, typeName);
  2543:   const ids = [...idsBefore];
  2544: 
  2545:   let upserts = 0;
  2546:   for (const it of items) {
  2547:     if (!it || typeof it !== "object") continue;
  2548: 
  2549:     if (typeName === "domains") {
  2550:       const domainId = String(it.id || it.domain || "").trim().toLowerCase();
  2551:       if (!domainId) continue;
  2552: 
  2553:       const entry = {
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {

===== HIT @ line 2594 (showing 2554..2674) =====
  2554:         id: domainId,
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {

===== HIT @ line 2595 (showing 2555..2675) =====
  2555:         domain: String(it.domain || it.id || domainId).toLowerCase(),
  2556:         pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2557:         purpose: String(it.purpose || it.notes || "").trim(),
  2558:         priority: String(it.priority || "UNKNOWN").trim(),
  2559:         status: String(it.status || "UNKNOWN").trim()
  2560:       };
  2561: 
  2562:       const put = await registryPut(env, "domains", entry);
  2563:       if (put.ok) {
  2564:         upserts += 1;
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {

===== HIT @ line 2605 (showing 2565..2685) =====
  2565:         if (!ids.includes(entry.id)) ids.push(entry.id);
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");

===== HIT @ line 2606 (showing 2566..2686) =====
  2566:       }
  2567:       continue;
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();

===== HIT @ line 2608 (showing 2568..2688) =====
  2568:     }
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {

===== HIT @ line 2609 (showing 2569..2689) =====
  2569: 
  2570:     // assets
  2571:     const assetId = String(it.id || "").trim();
  2572:     if (!assetId) continue;
  2573: 
  2574:     const entry = {
  2575:       id: assetId,
  2576:       name: String(it.name || it.title || it.id || "").trim() || assetId,
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;

===== HIT @ line 2617 (showing 2577..2697) =====
  2577:       pillar: String(it.pillar || it.category || it.group || "").trim() || "UNKNOWN",
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();

===== HIT @ line 2618 (showing 2578..2698) =====
  2578:       notes: String(it.notes || "").trim(),
  2579:       tags: Array.isArray(it.tags) ? it.tags : [],
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();

===== HIT @ line 2620 (showing 2580..2700) =====
  2580:       sellability: String(it.sellability || "UNKNOWN").trim(),
  2581:       patent_cluster: String(it.patent_cluster || "").trim()
  2582:     };
  2583: 
  2584:     const put = await registryPut(env, "assets", entry);
  2585:     if (put.ok) {
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }

===== HIT @ line 2626 (showing 2586..2706) =====
  2586:       upserts += 1;
  2587:       if (!ids.includes(entry.id)) ids.push(entry.id);
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)

===== HIT @ line 2628 (showing 2588..2708) =====
  2588:     }
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 

===== HIT @ line 2629 (showing 2589..2709) =====
  2589:   }
  2590: 
  2591:   await registryPutIndex(env, typeName, ids);
  2592:   await auditWrite(env, { action: "REGISTRY_IMPORT", type: typeName, details: { upserts } });
  2593: 
  2594:   return jsonReply(
  2595:     JSON.stringify(
  2596:       { ok: true, type: typeName, upserts, total_index_count: ids.length, stamp: nowIso() },
  2597:       null,
  2598:       2
  2599:     )
  2600:   );
  2601: };
  2602: 
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));

===== HIT @ line 2643 (showing 2603..2723) =====
  2603: const importRegistry = async (typeName) => {
  2604:   const raw = body.replace(/^REGISTRY_IMPORT_(ASSETS|DOMAINS)\s*/i, "").trim();
  2605:   const parsed = safeJsonParse(raw);
  2606:   if (!parsed) return jsonReply("BAD_REQUEST");
  2607: 
  2608:   const items = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.items) ? parsed.items : null);
  2609:   if (!items) return jsonReply("BAD_REQUEST");
  2610: 
  2611:   return await importRegistryCore(typeName, items);
  2612: };
  2613: 
  2614: const importRegistryGeneric = async () => {
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");

===== HIT @ line 2655 (showing 2615..2735) =====
  2615:   // Accept: REGISTRY_IMPORT {"type":"assets","items":[...]} OR {"type":"domains","items":[...]} OR {"type":"assets","items":...}
  2616:   const raw = body.replace(/^REGISTRY_IMPORT\s*/i, "").trim();
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");

===== HIT @ line 2657 (showing 2617..2737) =====
  2617:   const parsed = safeJsonParse(raw);
  2618:   if (!parsed || typeof parsed !== "object") return jsonReply("BAD_REQUEST");
  2619: 
  2620:   const typeName = String(parsed.type || "").toLowerCase().trim();
  2621:   const normalized =
  2622:     typeName === "asset" || typeName === "assets" ? "assets" :
  2623:     typeName === "domain" || typeName === "domains" ? "domains" :
  2624:     "";
  2625: 
  2626:   if (!normalized) return jsonReply("BAD_REQUEST");
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();

===== HIT @ line 2667 (showing 2627..2747) =====
  2627: 
  2628:   const items = Array.isArray(parsed.items) ? parsed.items : (Array.isArray(parsed) ? parsed : null);
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 

===== HIT @ line 2669 (showing 2629..2749) =====
  2629:   if (!items) return jsonReply("BAD_REQUEST");
  2630: 
  2631:   return await importRegistryCore(normalized, items);
  2632: };
  2633: 
  2634: 
  2635: 
  2636: // DISABLED: legacy import handler (batch mode authoritative)
  2637: 
  2638: 
  2639: 
  2640: // DISABLED: legacy import handler (batch mode authoritative)
  2641: 
  2642: 
  2643: // REGISTRY_IMPORT (generic): body is JSON object { type: "assets"|"domains", items: [...] }
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");

===== HIT @ line 2684 (showing 2644..2764) =====
  2644: 
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();

===== HIT @ line 2685 (showing 2645..2765) =====
  2645: // DISABLED: legacy import handler (batch mode authoritative)
  2646: 
  2647: 
  2648: 
  2649: // REGISTRY_GET <type> <id>
  2650: for (const line of lines) {
  2651:   if (line.startsWith("REGISTRY_GET")) {
  2652:     const parts = line.split(" ").filter(Boolean);
  2653:     const type = String(parts[1] || "").toLowerCase();
  2654:     const id = String(parts[2] || "").trim();
  2655:     if (!type || !id) return jsonReply("BAD_REQUEST");
  2656:     const e = await registryGet(env, type, id);
  2657:     return jsonReply(e ? JSON.stringify(e, null, 2) : "MISSING");
  2658:   }
  2659: }
  2660: 
  2661: // REGISTRY_LIST <type> [limit]
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();

===== HIT @ line 2702 (showing 2662..2782) =====
  2662: for (const line of lines) {
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },

===== HIT @ line 2703 (showing 2663..2783) =====
  2663:   if (line.startsWith("REGISTRY_LIST")) {
  2664:     const parts = line.split(" ").filter(Boolean);
  2665:     const type = String(parts[1] || "").toLowerCase();
  2666:     const limit = Number(parts[2] || 50);
  2667:     if (!type) return jsonReply("BAD_REQUEST");
  2668:     const payload = await registryList(env, type, limit);
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 

===== HIT @ line 2709 (showing 2669..2789) =====
  2669:     return jsonReply(JSON.stringify(payload, null, 2));
  2670:   }
  2671: }
  2672: 
  2673: // REGISTRY_FILTER <type> <field> <value> [limit]
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,

===== HIT @ line 2714 (showing 2674..2794) =====
  2674: for (const line of lines) {
  2675:   if (line.startsWith("REGISTRY_FILTER")) {
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };

===== HIT @ line 2716 (showing 2676..2796) =====
  2676:     const raw = line.slice("REGISTRY_FILTER".length).trim();
  2677:     let type = "";
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {

===== HIT @ line 2718 (showing 2678..2798) =====
  2678:     let field = "";
  2679:     let value = "";
  2680:     let limit = 50;
  2681:     let where = null;
  2682: 
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }

===== HIT @ line 2723 (showing 2683..2801) =====
  2683:     if (raw.startsWith("{")) {
  2684:       const obj = safeJsonParse(raw);
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2725 (showing 2685..2801) =====
  2685:       if (!obj || typeof obj !== "object") return jsonReply("BAD_REQUEST");
  2686:       type = String(obj.type || "").toLowerCase();
  2687:       limit = Number(obj.limit || 50);
  2688:       if (obj.where && typeof obj.where === "object") {
  2689:         where = obj.where;
  2690:       } else {
  2691:         field = String(obj.field || "").trim();
  2692:         value = String(obj.value ?? "").trim();
  2693:       }
  2694:     } else {
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2735 (showing 2695..2801) =====
  2695:       const parts = line.split(" ").filter(Boolean);
  2696:       type = String(parts[1] || "").toLowerCase();
  2697:       field = String(parts[2] || "").trim();
  2698:       value = String(parts[3] || "").trim();
  2699:       limit = Number(parts[4] || 50);
  2700:     }
  2701: 
  2702:     if (!type) return jsonReply("BAD_REQUEST");
  2703:     if (!where && (!field || !value)) return jsonReply("BAD_REQUEST");
  2704: 
  2705:     const payload = where
  2706:       ? await registryFilterWhere(env, type, where, limit)
  2707:       : await registryFilter(env, type, field, value, limit);
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2748 (showing 2708..2801) =====
  2708: 
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2749 (showing 2709..2801) =====
  2709:     return jsonReply(JSON.stringify(payload, null, 2));
  2710:   }
  2711: }
  2712: 
  2713: if (bodyTrim === "AUDIT_CLEAR") {
  2714:   if (!isOperator) return jsonReply("UNAUTHORIZED");
  2715:   // Require a VERIFIED_FETCH seed for the active host before allowing audit mutation.
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2756 (showing 2716..2801) =====
  2716:   if (!activeHost) return jsonReply("BAD_REQUEST");
  2717:   const evSeed = await env.AURA_KV.get(evidenceKey(activeHost));
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2758 (showing 2718..2801) =====
  2718:   if (!evSeed) return jsonReply("NOT_WIRED: VERIFIED_FETCH REQUIRED");
  2719:   try {
  2720:     // Fast-clear: resetting seq makes prior events unreachable without KV list/delete.
  2721:     await env.AURA_KV.put(auditSeqKey, "0");
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2762 (showing 2722..2801) =====
  2722:     await env.AURA_KV.put(auditClearedAtKey, nowIso());
  2723:     return jsonReply("CLEARED");
  2724:   } catch (e) {
  2725:     return jsonReply(JSON.stringify({ ok: false, error: "AUDIT_CLEAR_EXCEPTION", message: String(e?.message || e) }));
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2766 (showing 2726..2801) =====
  2726:   }
  2727: }
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2768 (showing 2728..2801) =====
  2728: 
  2729:     // ----------------------------
  2730:     // Consent-first Intent (explicit commands only)
  2731:     // ----------------------------
  2732:     for (const line of lines) {
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2773 (showing 2733..2801) =====
  2733:       if (line.startsWith("INTENT_ADD")) {
  2734:         const m = line.match(/^INTENT_ADD\s+(\S+)\s+(\S+)\s+(.+)$/);
  2735:         if (!m) return jsonReply("BAD_REQUEST");
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2776 (showing 2736..2801) =====
  2736:         const host = m[1].toLowerCase();
  2737:         const tag = m[2].toLowerCase();
  2738:         const text = m[3];
  2739: 
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2780 (showing 2740..2801) =====
  2740:         const payload = {
  2741:           host,
  2742:           tag,
  2743:           text,
  2744:           created_at: new Date().toISOString(),
  2745:           consent: "EXPLICIT_COMMAND"
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2786 (showing 2746..2801) =====
  2746:         };
  2747: 
  2748:         await env.AURA_KV.put(intentKey(host, tag), JSON.stringify(payload));
  2749:         return jsonReply("INTENT_SAVED");
  2750:       }
  2751: 
  2752:       if (line.startsWith("INTENT_GET")) {
  2753:         const parts = line.split(" ").filter(Boolean);
  2754:         const host = (parts[1] || "").toLowerCase();
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };

===== HIT @ line 2795 (showing 2755..2801) =====
  2755:         const tag = (parts[2] || "").toLowerCase();
  2756:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2757:         const stored = await env.AURA_KV.get(intentKey(host, tag));
  2758:         return jsonReply(stored ? stored : "INTENT_MISSING");
  2759:       }
  2760: 
  2761:       if (line.startsWith("INTENT_CLEAR")) {
  2762:         if (!isOperator) return jsonReply("UNAUTHORIZED");
  2763:         const parts = line.split(" ").filter(Boolean);
  2764:         const host = (parts[1] || "").toLowerCase();
  2765:         const tag = (parts[2] || "").toLowerCase();
  2766:         if (!host || !tag) return jsonReply("BAD_REQUEST");
  2767:         await env.AURA_KV.delete(intentKey(host, tag));
  2768:         return jsonReply("CLEARED");
  2769:       }
  2770:     }
  2771:     if (lines && lines.length === 1) {
  2772:       const nl = await naturalLanguageReply(lines[0], env, activeHost);
  2773:       if (nl) return jsonReply(nl);
  2774:     }
  2775: 
  2776:     return jsonReply("NOT WIRED: VERIFIED_FETCH REQUIRED");
  2777:   
  2778:     } catch (err) {
  2779:       const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
  2780:       return new Response(JSON.stringify({ ok: false, error: msg }), { status: 500, headers: { 'content-type': 'application/json; charset=utf-8' } });
  2781:     }
  2782: },
  2783: 
  2784:   async scheduled(event, env, ctx) {
  2785:     try {
  2786:       const prev = await env.AURA_KV.get(autonomyTickKey, { type: "json" });
  2787:       const count = Number((prev && prev.count) || 0) + 1;
  2788:       const payload = {
  2789:         ok: true,
  2790:         ts: new Date().toISOString(),
  2791:         count,
  2792:         build: BUILD,
  2793:         note: "AUTONOMY_LOOP_TICK"
  2794:       };
  2795:       await env.AURA_KV.put(autonomyTickKey, JSON.stringify(payload));
  2796:     } catch (_) {
  2797:       // Fail-closed: never throw from cron.
  2798:     }
  2799:   }
  2800: 
  2801: };
